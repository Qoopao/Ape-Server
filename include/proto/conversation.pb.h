// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conversation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_conversation_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_conversation_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sdkws.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_conversation_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_conversation_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conversation_2eproto;
namespace conversation {
class ClearUserConversationMsgReq;
struct ClearUserConversationMsgReqDefaultTypeInternal;
extern ClearUserConversationMsgReqDefaultTypeInternal _ClearUserConversationMsgReq_default_instance_;
class ClearUserConversationMsgResp;
struct ClearUserConversationMsgRespDefaultTypeInternal;
extern ClearUserConversationMsgRespDefaultTypeInternal _ClearUserConversationMsgResp_default_instance_;
class Conversation;
struct ConversationDefaultTypeInternal;
extern ConversationDefaultTypeInternal _Conversation_default_instance_;
class ConversationElem;
struct ConversationElemDefaultTypeInternal;
extern ConversationElemDefaultTypeInternal _ConversationElem_default_instance_;
class ConversationInfo;
struct ConversationInfoDefaultTypeInternal;
extern ConversationInfoDefaultTypeInternal _ConversationInfo_default_instance_;
class ConversationReq;
struct ConversationReqDefaultTypeInternal;
extern ConversationReqDefaultTypeInternal _ConversationReq_default_instance_;
class CreateGroupChatConversationsReq;
struct CreateGroupChatConversationsReqDefaultTypeInternal;
extern CreateGroupChatConversationsReqDefaultTypeInternal _CreateGroupChatConversationsReq_default_instance_;
class CreateGroupChatConversationsResp;
struct CreateGroupChatConversationsRespDefaultTypeInternal;
extern CreateGroupChatConversationsRespDefaultTypeInternal _CreateGroupChatConversationsResp_default_instance_;
class CreateSingleChatConversationsReq;
struct CreateSingleChatConversationsReqDefaultTypeInternal;
extern CreateSingleChatConversationsReqDefaultTypeInternal _CreateSingleChatConversationsReq_default_instance_;
class CreateSingleChatConversationsResp;
struct CreateSingleChatConversationsRespDefaultTypeInternal;
extern CreateSingleChatConversationsRespDefaultTypeInternal _CreateSingleChatConversationsResp_default_instance_;
class GetAllConversationsReq;
struct GetAllConversationsReqDefaultTypeInternal;
extern GetAllConversationsReqDefaultTypeInternal _GetAllConversationsReq_default_instance_;
class GetAllConversationsResp;
struct GetAllConversationsRespDefaultTypeInternal;
extern GetAllConversationsRespDefaultTypeInternal _GetAllConversationsResp_default_instance_;
class GetConversationIDsReq;
struct GetConversationIDsReqDefaultTypeInternal;
extern GetConversationIDsReqDefaultTypeInternal _GetConversationIDsReq_default_instance_;
class GetConversationIDsResp;
struct GetConversationIDsRespDefaultTypeInternal;
extern GetConversationIDsRespDefaultTypeInternal _GetConversationIDsResp_default_instance_;
class GetConversationNotReceiveMessageUserIDsReq;
struct GetConversationNotReceiveMessageUserIDsReqDefaultTypeInternal;
extern GetConversationNotReceiveMessageUserIDsReqDefaultTypeInternal _GetConversationNotReceiveMessageUserIDsReq_default_instance_;
class GetConversationNotReceiveMessageUserIDsResp;
struct GetConversationNotReceiveMessageUserIDsRespDefaultTypeInternal;
extern GetConversationNotReceiveMessageUserIDsRespDefaultTypeInternal _GetConversationNotReceiveMessageUserIDsResp_default_instance_;
class GetConversationOfflinePushUserIDsReq;
struct GetConversationOfflinePushUserIDsReqDefaultTypeInternal;
extern GetConversationOfflinePushUserIDsReqDefaultTypeInternal _GetConversationOfflinePushUserIDsReq_default_instance_;
class GetConversationOfflinePushUserIDsResp;
struct GetConversationOfflinePushUserIDsRespDefaultTypeInternal;
extern GetConversationOfflinePushUserIDsRespDefaultTypeInternal _GetConversationOfflinePushUserIDsResp_default_instance_;
class GetConversationReq;
struct GetConversationReqDefaultTypeInternal;
extern GetConversationReqDefaultTypeInternal _GetConversationReq_default_instance_;
class GetConversationResp;
struct GetConversationRespDefaultTypeInternal;
extern GetConversationRespDefaultTypeInternal _GetConversationResp_default_instance_;
class GetConversationsByConversationIDReq;
struct GetConversationsByConversationIDReqDefaultTypeInternal;
extern GetConversationsByConversationIDReqDefaultTypeInternal _GetConversationsByConversationIDReq_default_instance_;
class GetConversationsByConversationIDResp;
struct GetConversationsByConversationIDRespDefaultTypeInternal;
extern GetConversationsByConversationIDRespDefaultTypeInternal _GetConversationsByConversationIDResp_default_instance_;
class GetConversationsNeedClearMsgReq;
struct GetConversationsNeedClearMsgReqDefaultTypeInternal;
extern GetConversationsNeedClearMsgReqDefaultTypeInternal _GetConversationsNeedClearMsgReq_default_instance_;
class GetConversationsNeedClearMsgResp;
struct GetConversationsNeedClearMsgRespDefaultTypeInternal;
extern GetConversationsNeedClearMsgRespDefaultTypeInternal _GetConversationsNeedClearMsgResp_default_instance_;
class GetConversationsReq;
struct GetConversationsReqDefaultTypeInternal;
extern GetConversationsReqDefaultTypeInternal _GetConversationsReq_default_instance_;
class GetConversationsResp;
struct GetConversationsRespDefaultTypeInternal;
extern GetConversationsRespDefaultTypeInternal _GetConversationsResp_default_instance_;
class GetFullOwnerConversationIDsReq;
struct GetFullOwnerConversationIDsReqDefaultTypeInternal;
extern GetFullOwnerConversationIDsReqDefaultTypeInternal _GetFullOwnerConversationIDsReq_default_instance_;
class GetFullOwnerConversationIDsResp;
struct GetFullOwnerConversationIDsRespDefaultTypeInternal;
extern GetFullOwnerConversationIDsRespDefaultTypeInternal _GetFullOwnerConversationIDsResp_default_instance_;
class GetIncrementalConversationReq;
struct GetIncrementalConversationReqDefaultTypeInternal;
extern GetIncrementalConversationReqDefaultTypeInternal _GetIncrementalConversationReq_default_instance_;
class GetIncrementalConversationResp;
struct GetIncrementalConversationRespDefaultTypeInternal;
extern GetIncrementalConversationRespDefaultTypeInternal _GetIncrementalConversationResp_default_instance_;
class GetNotNotifyConversationIDsReq;
struct GetNotNotifyConversationIDsReqDefaultTypeInternal;
extern GetNotNotifyConversationIDsReqDefaultTypeInternal _GetNotNotifyConversationIDsReq_default_instance_;
class GetNotNotifyConversationIDsResp;
struct GetNotNotifyConversationIDsRespDefaultTypeInternal;
extern GetNotNotifyConversationIDsRespDefaultTypeInternal _GetNotNotifyConversationIDsResp_default_instance_;
class GetOwnerConversationReq;
struct GetOwnerConversationReqDefaultTypeInternal;
extern GetOwnerConversationReqDefaultTypeInternal _GetOwnerConversationReq_default_instance_;
class GetOwnerConversationResp;
struct GetOwnerConversationRespDefaultTypeInternal;
extern GetOwnerConversationRespDefaultTypeInternal _GetOwnerConversationResp_default_instance_;
class GetPinnedConversationIDsReq;
struct GetPinnedConversationIDsReqDefaultTypeInternal;
extern GetPinnedConversationIDsReqDefaultTypeInternal _GetPinnedConversationIDsReq_default_instance_;
class GetPinnedConversationIDsResp;
struct GetPinnedConversationIDsRespDefaultTypeInternal;
extern GetPinnedConversationIDsRespDefaultTypeInternal _GetPinnedConversationIDsResp_default_instance_;
class GetRecvMsgNotNotifyUserIDsReq;
struct GetRecvMsgNotNotifyUserIDsReqDefaultTypeInternal;
extern GetRecvMsgNotNotifyUserIDsReqDefaultTypeInternal _GetRecvMsgNotNotifyUserIDsReq_default_instance_;
class GetRecvMsgNotNotifyUserIDsResp;
struct GetRecvMsgNotNotifyUserIDsRespDefaultTypeInternal;
extern GetRecvMsgNotNotifyUserIDsRespDefaultTypeInternal _GetRecvMsgNotNotifyUserIDsResp_default_instance_;
class GetSortedConversationListReq;
struct GetSortedConversationListReqDefaultTypeInternal;
extern GetSortedConversationListReqDefaultTypeInternal _GetSortedConversationListReq_default_instance_;
class GetSortedConversationListResp;
struct GetSortedConversationListRespDefaultTypeInternal;
extern GetSortedConversationListRespDefaultTypeInternal _GetSortedConversationListResp_default_instance_;
class GetUserConversationIDsHashReq;
struct GetUserConversationIDsHashReqDefaultTypeInternal;
extern GetUserConversationIDsHashReqDefaultTypeInternal _GetUserConversationIDsHashReq_default_instance_;
class GetUserConversationIDsHashResp;
struct GetUserConversationIDsHashRespDefaultTypeInternal;
extern GetUserConversationIDsHashRespDefaultTypeInternal _GetUserConversationIDsHashResp_default_instance_;
class MsgInfo;
struct MsgInfoDefaultTypeInternal;
extern MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
class SetConversationMaxSeqReq;
struct SetConversationMaxSeqReqDefaultTypeInternal;
extern SetConversationMaxSeqReqDefaultTypeInternal _SetConversationMaxSeqReq_default_instance_;
class SetConversationMaxSeqResp;
struct SetConversationMaxSeqRespDefaultTypeInternal;
extern SetConversationMaxSeqRespDefaultTypeInternal _SetConversationMaxSeqResp_default_instance_;
class SetConversationMinSeqReq;
struct SetConversationMinSeqReqDefaultTypeInternal;
extern SetConversationMinSeqReqDefaultTypeInternal _SetConversationMinSeqReq_default_instance_;
class SetConversationMinSeqResp;
struct SetConversationMinSeqRespDefaultTypeInternal;
extern SetConversationMinSeqRespDefaultTypeInternal _SetConversationMinSeqResp_default_instance_;
class SetConversationReq;
struct SetConversationReqDefaultTypeInternal;
extern SetConversationReqDefaultTypeInternal _SetConversationReq_default_instance_;
class SetConversationResp;
struct SetConversationRespDefaultTypeInternal;
extern SetConversationRespDefaultTypeInternal _SetConversationResp_default_instance_;
class SetConversationsReq;
struct SetConversationsReqDefaultTypeInternal;
extern SetConversationsReqDefaultTypeInternal _SetConversationsReq_default_instance_;
class SetConversationsResp;
struct SetConversationsRespDefaultTypeInternal;
extern SetConversationsRespDefaultTypeInternal _SetConversationsResp_default_instance_;
class UpdateConversationReq;
struct UpdateConversationReqDefaultTypeInternal;
extern UpdateConversationReqDefaultTypeInternal _UpdateConversationReq_default_instance_;
class UpdateConversationResp;
struct UpdateConversationRespDefaultTypeInternal;
extern UpdateConversationRespDefaultTypeInternal _UpdateConversationResp_default_instance_;
class UpdateConversationsByUserReq;
struct UpdateConversationsByUserReqDefaultTypeInternal;
extern UpdateConversationsByUserReqDefaultTypeInternal _UpdateConversationsByUserReq_default_instance_;
class UpdateConversationsByUserResp;
struct UpdateConversationsByUserRespDefaultTypeInternal;
extern UpdateConversationsByUserRespDefaultTypeInternal _UpdateConversationsByUserResp_default_instance_;
}  // namespace conversation
PROTOBUF_NAMESPACE_OPEN
template<> ::conversation::ClearUserConversationMsgReq* Arena::CreateMaybeMessage<::conversation::ClearUserConversationMsgReq>(Arena*);
template<> ::conversation::ClearUserConversationMsgResp* Arena::CreateMaybeMessage<::conversation::ClearUserConversationMsgResp>(Arena*);
template<> ::conversation::Conversation* Arena::CreateMaybeMessage<::conversation::Conversation>(Arena*);
template<> ::conversation::ConversationElem* Arena::CreateMaybeMessage<::conversation::ConversationElem>(Arena*);
template<> ::conversation::ConversationInfo* Arena::CreateMaybeMessage<::conversation::ConversationInfo>(Arena*);
template<> ::conversation::ConversationReq* Arena::CreateMaybeMessage<::conversation::ConversationReq>(Arena*);
template<> ::conversation::CreateGroupChatConversationsReq* Arena::CreateMaybeMessage<::conversation::CreateGroupChatConversationsReq>(Arena*);
template<> ::conversation::CreateGroupChatConversationsResp* Arena::CreateMaybeMessage<::conversation::CreateGroupChatConversationsResp>(Arena*);
template<> ::conversation::CreateSingleChatConversationsReq* Arena::CreateMaybeMessage<::conversation::CreateSingleChatConversationsReq>(Arena*);
template<> ::conversation::CreateSingleChatConversationsResp* Arena::CreateMaybeMessage<::conversation::CreateSingleChatConversationsResp>(Arena*);
template<> ::conversation::GetAllConversationsReq* Arena::CreateMaybeMessage<::conversation::GetAllConversationsReq>(Arena*);
template<> ::conversation::GetAllConversationsResp* Arena::CreateMaybeMessage<::conversation::GetAllConversationsResp>(Arena*);
template<> ::conversation::GetConversationIDsReq* Arena::CreateMaybeMessage<::conversation::GetConversationIDsReq>(Arena*);
template<> ::conversation::GetConversationIDsResp* Arena::CreateMaybeMessage<::conversation::GetConversationIDsResp>(Arena*);
template<> ::conversation::GetConversationNotReceiveMessageUserIDsReq* Arena::CreateMaybeMessage<::conversation::GetConversationNotReceiveMessageUserIDsReq>(Arena*);
template<> ::conversation::GetConversationNotReceiveMessageUserIDsResp* Arena::CreateMaybeMessage<::conversation::GetConversationNotReceiveMessageUserIDsResp>(Arena*);
template<> ::conversation::GetConversationOfflinePushUserIDsReq* Arena::CreateMaybeMessage<::conversation::GetConversationOfflinePushUserIDsReq>(Arena*);
template<> ::conversation::GetConversationOfflinePushUserIDsResp* Arena::CreateMaybeMessage<::conversation::GetConversationOfflinePushUserIDsResp>(Arena*);
template<> ::conversation::GetConversationReq* Arena::CreateMaybeMessage<::conversation::GetConversationReq>(Arena*);
template<> ::conversation::GetConversationResp* Arena::CreateMaybeMessage<::conversation::GetConversationResp>(Arena*);
template<> ::conversation::GetConversationsByConversationIDReq* Arena::CreateMaybeMessage<::conversation::GetConversationsByConversationIDReq>(Arena*);
template<> ::conversation::GetConversationsByConversationIDResp* Arena::CreateMaybeMessage<::conversation::GetConversationsByConversationIDResp>(Arena*);
template<> ::conversation::GetConversationsNeedClearMsgReq* Arena::CreateMaybeMessage<::conversation::GetConversationsNeedClearMsgReq>(Arena*);
template<> ::conversation::GetConversationsNeedClearMsgResp* Arena::CreateMaybeMessage<::conversation::GetConversationsNeedClearMsgResp>(Arena*);
template<> ::conversation::GetConversationsReq* Arena::CreateMaybeMessage<::conversation::GetConversationsReq>(Arena*);
template<> ::conversation::GetConversationsResp* Arena::CreateMaybeMessage<::conversation::GetConversationsResp>(Arena*);
template<> ::conversation::GetFullOwnerConversationIDsReq* Arena::CreateMaybeMessage<::conversation::GetFullOwnerConversationIDsReq>(Arena*);
template<> ::conversation::GetFullOwnerConversationIDsResp* Arena::CreateMaybeMessage<::conversation::GetFullOwnerConversationIDsResp>(Arena*);
template<> ::conversation::GetIncrementalConversationReq* Arena::CreateMaybeMessage<::conversation::GetIncrementalConversationReq>(Arena*);
template<> ::conversation::GetIncrementalConversationResp* Arena::CreateMaybeMessage<::conversation::GetIncrementalConversationResp>(Arena*);
template<> ::conversation::GetNotNotifyConversationIDsReq* Arena::CreateMaybeMessage<::conversation::GetNotNotifyConversationIDsReq>(Arena*);
template<> ::conversation::GetNotNotifyConversationIDsResp* Arena::CreateMaybeMessage<::conversation::GetNotNotifyConversationIDsResp>(Arena*);
template<> ::conversation::GetOwnerConversationReq* Arena::CreateMaybeMessage<::conversation::GetOwnerConversationReq>(Arena*);
template<> ::conversation::GetOwnerConversationResp* Arena::CreateMaybeMessage<::conversation::GetOwnerConversationResp>(Arena*);
template<> ::conversation::GetPinnedConversationIDsReq* Arena::CreateMaybeMessage<::conversation::GetPinnedConversationIDsReq>(Arena*);
template<> ::conversation::GetPinnedConversationIDsResp* Arena::CreateMaybeMessage<::conversation::GetPinnedConversationIDsResp>(Arena*);
template<> ::conversation::GetRecvMsgNotNotifyUserIDsReq* Arena::CreateMaybeMessage<::conversation::GetRecvMsgNotNotifyUserIDsReq>(Arena*);
template<> ::conversation::GetRecvMsgNotNotifyUserIDsResp* Arena::CreateMaybeMessage<::conversation::GetRecvMsgNotNotifyUserIDsResp>(Arena*);
template<> ::conversation::GetSortedConversationListReq* Arena::CreateMaybeMessage<::conversation::GetSortedConversationListReq>(Arena*);
template<> ::conversation::GetSortedConversationListResp* Arena::CreateMaybeMessage<::conversation::GetSortedConversationListResp>(Arena*);
template<> ::conversation::GetUserConversationIDsHashReq* Arena::CreateMaybeMessage<::conversation::GetUserConversationIDsHashReq>(Arena*);
template<> ::conversation::GetUserConversationIDsHashResp* Arena::CreateMaybeMessage<::conversation::GetUserConversationIDsHashResp>(Arena*);
template<> ::conversation::MsgInfo* Arena::CreateMaybeMessage<::conversation::MsgInfo>(Arena*);
template<> ::conversation::SetConversationMaxSeqReq* Arena::CreateMaybeMessage<::conversation::SetConversationMaxSeqReq>(Arena*);
template<> ::conversation::SetConversationMaxSeqResp* Arena::CreateMaybeMessage<::conversation::SetConversationMaxSeqResp>(Arena*);
template<> ::conversation::SetConversationMinSeqReq* Arena::CreateMaybeMessage<::conversation::SetConversationMinSeqReq>(Arena*);
template<> ::conversation::SetConversationMinSeqResp* Arena::CreateMaybeMessage<::conversation::SetConversationMinSeqResp>(Arena*);
template<> ::conversation::SetConversationReq* Arena::CreateMaybeMessage<::conversation::SetConversationReq>(Arena*);
template<> ::conversation::SetConversationResp* Arena::CreateMaybeMessage<::conversation::SetConversationResp>(Arena*);
template<> ::conversation::SetConversationsReq* Arena::CreateMaybeMessage<::conversation::SetConversationsReq>(Arena*);
template<> ::conversation::SetConversationsResp* Arena::CreateMaybeMessage<::conversation::SetConversationsResp>(Arena*);
template<> ::conversation::UpdateConversationReq* Arena::CreateMaybeMessage<::conversation::UpdateConversationReq>(Arena*);
template<> ::conversation::UpdateConversationResp* Arena::CreateMaybeMessage<::conversation::UpdateConversationResp>(Arena*);
template<> ::conversation::UpdateConversationsByUserReq* Arena::CreateMaybeMessage<::conversation::UpdateConversationsByUserReq>(Arena*);
template<> ::conversation::UpdateConversationsByUserResp* Arena::CreateMaybeMessage<::conversation::UpdateConversationsByUserResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace conversation {

// ===================================================================

class Conversation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.Conversation) */ {
 public:
  inline Conversation() : Conversation(nullptr) {}
  ~Conversation() override;
  explicit PROTOBUF_CONSTEXPR Conversation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Conversation(const Conversation& from);
  Conversation(Conversation&& from) noexcept
    : Conversation() {
    *this = ::std::move(from);
  }

  inline Conversation& operator=(const Conversation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Conversation& operator=(Conversation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Conversation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Conversation* internal_default_instance() {
    return reinterpret_cast<const Conversation*>(
               &_Conversation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Conversation& a, Conversation& b) {
    a.Swap(&b);
  }
  inline void Swap(Conversation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Conversation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Conversation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Conversation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Conversation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Conversation& from) {
    Conversation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Conversation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.Conversation";
  }
  protected:
  explicit Conversation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 1,
    kConversationIDFieldNumber = 2,
    kUserIDFieldNumber = 5,
    kGroupIDFieldNumber = 6,
    kAttachedInfoFieldNumber = 8,
    kExFieldNumber = 11,
    kRecvMsgOptFieldNumber = 3,
    kConversationTypeFieldNumber = 4,
    kGroupAtTypeFieldNumber = 10,
    kIsPinnedFieldNumber = 7,
    kIsPrivateChatFieldNumber = 9,
    kIsMsgDestructFieldNumber = 17,
    kMinSeqFieldNumber = 13,
    kMaxSeqFieldNumber = 14,
    kMsgDestructTimeFieldNumber = 15,
    kLatestMsgDestructTimeFieldNumber = 16,
    kBurnDurationFieldNumber = 12,
  };
  // string ownerUserID = 1;
  void clear_owneruserid();
  const std::string& owneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* owneruserid);
  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(const std::string& value);
  std::string* _internal_mutable_owneruserid();
  public:

  // string conversationID = 2;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 5;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string groupID = 6;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // string attachedInfo = 8;
  void clear_attachedinfo();
  const std::string& attachedinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachedinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachedinfo();
  PROTOBUF_NODISCARD std::string* release_attachedinfo();
  void set_allocated_attachedinfo(std::string* attachedinfo);
  private:
  const std::string& _internal_attachedinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachedinfo(const std::string& value);
  std::string* _internal_mutable_attachedinfo();
  public:

  // string ex = 11;
  void clear_ex();
  const std::string& ex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ex();
  PROTOBUF_NODISCARD std::string* release_ex();
  void set_allocated_ex(std::string* ex);
  private:
  const std::string& _internal_ex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ex(const std::string& value);
  std::string* _internal_mutable_ex();
  public:

  // int32 recvMsgOpt = 3;
  void clear_recvmsgopt();
  int32_t recvmsgopt() const;
  void set_recvmsgopt(int32_t value);
  private:
  int32_t _internal_recvmsgopt() const;
  void _internal_set_recvmsgopt(int32_t value);
  public:

  // int32 conversationType = 4;
  void clear_conversationtype();
  int32_t conversationtype() const;
  void set_conversationtype(int32_t value);
  private:
  int32_t _internal_conversationtype() const;
  void _internal_set_conversationtype(int32_t value);
  public:

  // int32 groupAtType = 10;
  void clear_groupattype();
  int32_t groupattype() const;
  void set_groupattype(int32_t value);
  private:
  int32_t _internal_groupattype() const;
  void _internal_set_groupattype(int32_t value);
  public:

  // bool isPinned = 7;
  void clear_ispinned();
  bool ispinned() const;
  void set_ispinned(bool value);
  private:
  bool _internal_ispinned() const;
  void _internal_set_ispinned(bool value);
  public:

  // bool isPrivateChat = 9;
  void clear_isprivatechat();
  bool isprivatechat() const;
  void set_isprivatechat(bool value);
  private:
  bool _internal_isprivatechat() const;
  void _internal_set_isprivatechat(bool value);
  public:

  // bool isMsgDestruct = 17;
  void clear_ismsgdestruct();
  bool ismsgdestruct() const;
  void set_ismsgdestruct(bool value);
  private:
  bool _internal_ismsgdestruct() const;
  void _internal_set_ismsgdestruct(bool value);
  public:

  // int64 minSeq = 13;
  void clear_minseq();
  int64_t minseq() const;
  void set_minseq(int64_t value);
  private:
  int64_t _internal_minseq() const;
  void _internal_set_minseq(int64_t value);
  public:

  // int64 maxSeq = 14;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // int64 msgDestructTime = 15;
  void clear_msgdestructtime();
  int64_t msgdestructtime() const;
  void set_msgdestructtime(int64_t value);
  private:
  int64_t _internal_msgdestructtime() const;
  void _internal_set_msgdestructtime(int64_t value);
  public:

  // int64 latestMsgDestructTime = 16;
  void clear_latestmsgdestructtime();
  int64_t latestmsgdestructtime() const;
  void set_latestmsgdestructtime(int64_t value);
  private:
  int64_t _internal_latestmsgdestructtime() const;
  void _internal_set_latestmsgdestructtime(int64_t value);
  public:

  // int32 burnDuration = 12;
  void clear_burnduration();
  int32_t burnduration() const;
  void set_burnduration(int32_t value);
  private:
  int32_t _internal_burnduration() const;
  void _internal_set_burnduration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.Conversation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachedinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ex_;
    int32_t recvmsgopt_;
    int32_t conversationtype_;
    int32_t groupattype_;
    bool ispinned_;
    bool isprivatechat_;
    bool ismsgdestruct_;
    int64_t minseq_;
    int64_t maxseq_;
    int64_t msgdestructtime_;
    int64_t latestmsgdestructtime_;
    int32_t burnduration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class ConversationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.ConversationInfo) */ {
 public:
  inline ConversationInfo() : ConversationInfo(nullptr) {}
  ~ConversationInfo() override;
  explicit PROTOBUF_CONSTEXPR ConversationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConversationInfo(const ConversationInfo& from);
  ConversationInfo(ConversationInfo&& from) noexcept
    : ConversationInfo() {
    *this = ::std::move(from);
  }

  inline ConversationInfo& operator=(const ConversationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationInfo& operator=(ConversationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConversationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConversationInfo* internal_default_instance() {
    return reinterpret_cast<const ConversationInfo*>(
               &_ConversationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConversationInfo& a, ConversationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConversationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConversationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConversationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConversationInfo& from) {
    ConversationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.ConversationInfo";
  }
  protected:
  explicit ConversationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantUIDsFieldNumber = 6,
    kTopUIDsFieldNumber = 7,
    kMuteUIDsFieldNumber = 9,
    kFoldUIDsFieldNumber = 10,
    kConversationIDFieldNumber = 1,
    kOwnerUserIDFieldNumber = 2,
    kConversationNameFieldNumber = 4,
    kConversationAvatarFieldNumber = 5,
    kUnreadCountFieldNumber = 8,
    kConversationTypeFieldNumber = 3,
  };
  // repeated string participantUIDs = 6;
  int participantuids_size() const;
  private:
  int _internal_participantuids_size() const;
  public:
  void clear_participantuids();
  const std::string& participantuids(int index) const;
  std::string* mutable_participantuids(int index);
  void set_participantuids(int index, const std::string& value);
  void set_participantuids(int index, std::string&& value);
  void set_participantuids(int index, const char* value);
  void set_participantuids(int index, const char* value, size_t size);
  std::string* add_participantuids();
  void add_participantuids(const std::string& value);
  void add_participantuids(std::string&& value);
  void add_participantuids(const char* value);
  void add_participantuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participantuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participantuids();
  private:
  const std::string& _internal_participantuids(int index) const;
  std::string* _internal_add_participantuids();
  public:

  // repeated string topUIDs = 7;
  int topuids_size() const;
  private:
  int _internal_topuids_size() const;
  public:
  void clear_topuids();
  const std::string& topuids(int index) const;
  std::string* mutable_topuids(int index);
  void set_topuids(int index, const std::string& value);
  void set_topuids(int index, std::string&& value);
  void set_topuids(int index, const char* value);
  void set_topuids(int index, const char* value, size_t size);
  std::string* add_topuids();
  void add_topuids(const std::string& value);
  void add_topuids(std::string&& value);
  void add_topuids(const char* value);
  void add_topuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topuids();
  private:
  const std::string& _internal_topuids(int index) const;
  std::string* _internal_add_topuids();
  public:

  // repeated string muteUIDs = 9;
  int muteuids_size() const;
  private:
  int _internal_muteuids_size() const;
  public:
  void clear_muteuids();
  const std::string& muteuids(int index) const;
  std::string* mutable_muteuids(int index);
  void set_muteuids(int index, const std::string& value);
  void set_muteuids(int index, std::string&& value);
  void set_muteuids(int index, const char* value);
  void set_muteuids(int index, const char* value, size_t size);
  std::string* add_muteuids();
  void add_muteuids(const std::string& value);
  void add_muteuids(std::string&& value);
  void add_muteuids(const char* value);
  void add_muteuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& muteuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_muteuids();
  private:
  const std::string& _internal_muteuids(int index) const;
  std::string* _internal_add_muteuids();
  public:

  // repeated string foldUIDs = 10;
  int folduids_size() const;
  private:
  int _internal_folduids_size() const;
  public:
  void clear_folduids();
  const std::string& folduids(int index) const;
  std::string* mutable_folduids(int index);
  void set_folduids(int index, const std::string& value);
  void set_folduids(int index, std::string&& value);
  void set_folduids(int index, const char* value);
  void set_folduids(int index, const char* value, size_t size);
  std::string* add_folduids();
  void add_folduids(const std::string& value);
  void add_folduids(std::string&& value);
  void add_folduids(const char* value);
  void add_folduids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& folduids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_folduids();
  private:
  const std::string& _internal_folduids(int index) const;
  std::string* _internal_add_folduids();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string ownerUserID = 2;
  void clear_owneruserid();
  const std::string& owneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* owneruserid);
  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(const std::string& value);
  std::string* _internal_mutable_owneruserid();
  public:

  // string conversationName = 4;
  void clear_conversationname();
  const std::string& conversationname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationname();
  PROTOBUF_NODISCARD std::string* release_conversationname();
  void set_allocated_conversationname(std::string* conversationname);
  private:
  const std::string& _internal_conversationname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationname(const std::string& value);
  std::string* _internal_mutable_conversationname();
  public:

  // string conversationAvatar = 5;
  void clear_conversationavatar();
  const std::string& conversationavatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationavatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationavatar();
  PROTOBUF_NODISCARD std::string* release_conversationavatar();
  void set_allocated_conversationavatar(std::string* conversationavatar);
  private:
  const std::string& _internal_conversationavatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationavatar(const std::string& value);
  std::string* _internal_mutable_conversationavatar();
  public:

  // int64 unreadCount = 8;
  void clear_unreadcount();
  int64_t unreadcount() const;
  void set_unreadcount(int64_t value);
  private:
  int64_t _internal_unreadcount() const;
  void _internal_set_unreadcount(int64_t value);
  public:

  // int32 conversationType = 3;
  void clear_conversationtype();
  int32_t conversationtype() const;
  void set_conversationtype(int32_t value);
  private:
  int32_t _internal_conversationtype() const;
  void _internal_set_conversationtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.ConversationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participantuids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topuids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> muteuids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> folduids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationavatar_;
    int64_t unreadcount_;
    int32_t conversationtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class ConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.ConversationReq) */ {
 public:
  inline ConversationReq() : ConversationReq(nullptr) {}
  ~ConversationReq() override;
  explicit PROTOBUF_CONSTEXPR ConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConversationReq(const ConversationReq& from);
  ConversationReq(ConversationReq&& from) noexcept
    : ConversationReq() {
    *this = ::std::move(from);
  }

  inline ConversationReq& operator=(const ConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationReq& operator=(ConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConversationReq* internal_default_instance() {
    return reinterpret_cast<const ConversationReq*>(
               &_ConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConversationReq& a, ConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConversationReq& from) {
    ConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.ConversationReq";
  }
  protected:
  explicit ConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kUserIDFieldNumber = 3,
    kGroupIDFieldNumber = 4,
    kAttachedInfoFieldNumber = 7,
    kExFieldNumber = 9,
    kConversationTypeFieldNumber = 2,
    kRecvMsgOptFieldNumber = 5,
    kIsPinnedFieldNumber = 6,
    kIsPrivateChatFieldNumber = 8,
    kIsMsgDestructFieldNumber = 15,
    kBurnDurationFieldNumber = 10,
    kMinSeqFieldNumber = 11,
    kMaxSeqFieldNumber = 12,
    kMsgDestructTimeFieldNumber = 14,
    kGroupAtTypeFieldNumber = 13,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 3;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string groupID = 4;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // string attachedInfo = 7;
  void clear_attachedinfo();
  const std::string& attachedinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachedinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachedinfo();
  PROTOBUF_NODISCARD std::string* release_attachedinfo();
  void set_allocated_attachedinfo(std::string* attachedinfo);
  private:
  const std::string& _internal_attachedinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachedinfo(const std::string& value);
  std::string* _internal_mutable_attachedinfo();
  public:

  // string ex = 9;
  void clear_ex();
  const std::string& ex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ex();
  PROTOBUF_NODISCARD std::string* release_ex();
  void set_allocated_ex(std::string* ex);
  private:
  const std::string& _internal_ex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ex(const std::string& value);
  std::string* _internal_mutable_ex();
  public:

  // int32 conversationType = 2;
  void clear_conversationtype();
  int32_t conversationtype() const;
  void set_conversationtype(int32_t value);
  private:
  int32_t _internal_conversationtype() const;
  void _internal_set_conversationtype(int32_t value);
  public:

  // int32 recvMsgOpt = 5;
  void clear_recvmsgopt();
  int32_t recvmsgopt() const;
  void set_recvmsgopt(int32_t value);
  private:
  int32_t _internal_recvmsgopt() const;
  void _internal_set_recvmsgopt(int32_t value);
  public:

  // bool isPinned = 6;
  void clear_ispinned();
  bool ispinned() const;
  void set_ispinned(bool value);
  private:
  bool _internal_ispinned() const;
  void _internal_set_ispinned(bool value);
  public:

  // bool isPrivateChat = 8;
  void clear_isprivatechat();
  bool isprivatechat() const;
  void set_isprivatechat(bool value);
  private:
  bool _internal_isprivatechat() const;
  void _internal_set_isprivatechat(bool value);
  public:

  // bool isMsgDestruct = 15;
  void clear_ismsgdestruct();
  bool ismsgdestruct() const;
  void set_ismsgdestruct(bool value);
  private:
  bool _internal_ismsgdestruct() const;
  void _internal_set_ismsgdestruct(bool value);
  public:

  // int32 burnDuration = 10;
  void clear_burnduration();
  int32_t burnduration() const;
  void set_burnduration(int32_t value);
  private:
  int32_t _internal_burnduration() const;
  void _internal_set_burnduration(int32_t value);
  public:

  // int64 minSeq = 11;
  void clear_minseq();
  int64_t minseq() const;
  void set_minseq(int64_t value);
  private:
  int64_t _internal_minseq() const;
  void _internal_set_minseq(int64_t value);
  public:

  // int64 maxSeq = 12;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // int64 msgDestructTime = 14;
  void clear_msgdestructtime();
  int64_t msgdestructtime() const;
  void set_msgdestructtime(int64_t value);
  private:
  int64_t _internal_msgdestructtime() const;
  void _internal_set_msgdestructtime(int64_t value);
  public:

  // int32 groupAtType = 13;
  void clear_groupattype();
  int32_t groupattype() const;
  void set_groupattype(int32_t value);
  private:
  int32_t _internal_groupattype() const;
  void _internal_set_groupattype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.ConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachedinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ex_;
    int32_t conversationtype_;
    int32_t recvmsgopt_;
    bool ispinned_;
    bool isprivatechat_;
    bool ismsgdestruct_;
    int32_t burnduration_;
    int64_t minseq_;
    int64_t maxseq_;
    int64_t msgdestructtime_;
    int32_t groupattype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.SetConversationReq) */ {
 public:
  inline SetConversationReq() : SetConversationReq(nullptr) {}
  ~SetConversationReq() override;
  explicit PROTOBUF_CONSTEXPR SetConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationReq(const SetConversationReq& from);
  SetConversationReq(SetConversationReq&& from) noexcept
    : SetConversationReq() {
    *this = ::std::move(from);
  }

  inline SetConversationReq& operator=(const SetConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationReq& operator=(SetConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationReq* internal_default_instance() {
    return reinterpret_cast<const SetConversationReq*>(
               &_SetConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetConversationReq& a, SetConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetConversationReq& from) {
    SetConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationReq";
  }
  protected:
  explicit SetConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationFieldNumber = 1,
  };
  // .conversation.Conversation conversation = 1;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const ::conversation::Conversation& conversation() const;
  PROTOBUF_NODISCARD ::conversation::Conversation* release_conversation();
  ::conversation::Conversation* mutable_conversation();
  void set_allocated_conversation(::conversation::Conversation* conversation);
  private:
  const ::conversation::Conversation& _internal_conversation() const;
  ::conversation::Conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::conversation::Conversation* conversation);
  ::conversation::Conversation* unsafe_arena_release_conversation();

  // @@protoc_insertion_point(class_scope:conversation.SetConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::conversation::Conversation* conversation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.SetConversationResp) */ {
 public:
  inline SetConversationResp() : SetConversationResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationResp(const SetConversationResp& from);
  SetConversationResp(SetConversationResp&& from) noexcept
    : SetConversationResp() {
    *this = ::std::move(from);
  }

  inline SetConversationResp& operator=(const SetConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationResp& operator=(SetConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationResp* internal_default_instance() {
    return reinterpret_cast<const SetConversationResp*>(
               &_SetConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetConversationResp& a, SetConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConversationResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConversationResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationResp";
  }
  protected:
  explicit SetConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.SetConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationReq) */ {
 public:
  inline GetConversationReq() : GetConversationReq(nullptr) {}
  ~GetConversationReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationReq(const GetConversationReq& from);
  GetConversationReq(GetConversationReq&& from) noexcept
    : GetConversationReq() {
    *this = ::std::move(from);
  }

  inline GetConversationReq& operator=(const GetConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationReq& operator=(GetConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationReq*>(
               &_GetConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetConversationReq& a, GetConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationReq& from) {
    GetConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationReq";
  }
  protected:
  explicit GetConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kOwnerUserIDFieldNumber = 2,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string ownerUserID = 2;
  void clear_owneruserid();
  const std::string& owneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* owneruserid);
  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(const std::string& value);
  std::string* _internal_mutable_owneruserid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationResp) */ {
 public:
  inline GetConversationResp() : GetConversationResp(nullptr) {}
  ~GetConversationResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationResp(const GetConversationResp& from);
  GetConversationResp(GetConversationResp&& from) noexcept
    : GetConversationResp() {
    *this = ::std::move(from);
  }

  inline GetConversationResp& operator=(const GetConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationResp& operator=(GetConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationResp*>(
               &_GetConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetConversationResp& a, GetConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationResp& from) {
    GetConversationResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationResp";
  }
  protected:
  explicit GetConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationFieldNumber = 2,
  };
  // .conversation.Conversation conversation = 2;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const ::conversation::Conversation& conversation() const;
  PROTOBUF_NODISCARD ::conversation::Conversation* release_conversation();
  ::conversation::Conversation* mutable_conversation();
  void set_allocated_conversation(::conversation::Conversation* conversation);
  private:
  const ::conversation::Conversation& _internal_conversation() const;
  ::conversation::Conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::conversation::Conversation* conversation);
  ::conversation::Conversation* unsafe_arena_release_conversation();

  // @@protoc_insertion_point(class_scope:conversation.GetConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::conversation::Conversation* conversation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetSortedConversationListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetSortedConversationListReq) */ {
 public:
  inline GetSortedConversationListReq() : GetSortedConversationListReq(nullptr) {}
  ~GetSortedConversationListReq() override;
  explicit PROTOBUF_CONSTEXPR GetSortedConversationListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSortedConversationListReq(const GetSortedConversationListReq& from);
  GetSortedConversationListReq(GetSortedConversationListReq&& from) noexcept
    : GetSortedConversationListReq() {
    *this = ::std::move(from);
  }

  inline GetSortedConversationListReq& operator=(const GetSortedConversationListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSortedConversationListReq& operator=(GetSortedConversationListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSortedConversationListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSortedConversationListReq* internal_default_instance() {
    return reinterpret_cast<const GetSortedConversationListReq*>(
               &_GetSortedConversationListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetSortedConversationListReq& a, GetSortedConversationListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSortedConversationListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSortedConversationListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSortedConversationListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSortedConversationListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSortedConversationListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSortedConversationListReq& from) {
    GetSortedConversationListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSortedConversationListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetSortedConversationListReq";
  }
  protected:
  explicit GetSortedConversationListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 2,
    kUserIDFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated string conversationIDs = 2;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sdkws.RequestPagination pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sdkws::RequestPagination& pagination() const;
  PROTOBUF_NODISCARD ::sdkws::RequestPagination* release_pagination();
  ::sdkws::RequestPagination* mutable_pagination();
  void set_allocated_pagination(::sdkws::RequestPagination* pagination);
  private:
  const ::sdkws::RequestPagination& _internal_pagination() const;
  ::sdkws::RequestPagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sdkws::RequestPagination* pagination);
  ::sdkws::RequestPagination* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:conversation.GetSortedConversationListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::sdkws::RequestPagination* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetSortedConversationListResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetSortedConversationListResp) */ {
 public:
  inline GetSortedConversationListResp() : GetSortedConversationListResp(nullptr) {}
  ~GetSortedConversationListResp() override;
  explicit PROTOBUF_CONSTEXPR GetSortedConversationListResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSortedConversationListResp(const GetSortedConversationListResp& from);
  GetSortedConversationListResp(GetSortedConversationListResp&& from) noexcept
    : GetSortedConversationListResp() {
    *this = ::std::move(from);
  }

  inline GetSortedConversationListResp& operator=(const GetSortedConversationListResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSortedConversationListResp& operator=(GetSortedConversationListResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSortedConversationListResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSortedConversationListResp* internal_default_instance() {
    return reinterpret_cast<const GetSortedConversationListResp*>(
               &_GetSortedConversationListResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetSortedConversationListResp& a, GetSortedConversationListResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSortedConversationListResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSortedConversationListResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSortedConversationListResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSortedConversationListResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSortedConversationListResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSortedConversationListResp& from) {
    GetSortedConversationListResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSortedConversationListResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetSortedConversationListResp";
  }
  protected:
  explicit GetSortedConversationListResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationElemsFieldNumber = 3,
    kConversationTotalFieldNumber = 1,
    kUnreadTotalFieldNumber = 2,
  };
  // repeated .conversation.ConversationElem conversationElems = 3;
  int conversationelems_size() const;
  private:
  int _internal_conversationelems_size() const;
  public:
  void clear_conversationelems();
  ::conversation::ConversationElem* mutable_conversationelems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::ConversationElem >*
      mutable_conversationelems();
  private:
  const ::conversation::ConversationElem& _internal_conversationelems(int index) const;
  ::conversation::ConversationElem* _internal_add_conversationelems();
  public:
  const ::conversation::ConversationElem& conversationelems(int index) const;
  ::conversation::ConversationElem* add_conversationelems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::ConversationElem >&
      conversationelems() const;

  // int64 conversationTotal = 1;
  void clear_conversationtotal();
  int64_t conversationtotal() const;
  void set_conversationtotal(int64_t value);
  private:
  int64_t _internal_conversationtotal() const;
  void _internal_set_conversationtotal(int64_t value);
  public:

  // int64 unreadTotal = 2;
  void clear_unreadtotal();
  int64_t unreadtotal() const;
  void set_unreadtotal(int64_t value);
  private:
  int64_t _internal_unreadtotal() const;
  void _internal_set_unreadtotal(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetSortedConversationListResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::ConversationElem > conversationelems_;
    int64_t conversationtotal_;
    int64_t unreadtotal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class ConversationElem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.ConversationElem) */ {
 public:
  inline ConversationElem() : ConversationElem(nullptr) {}
  ~ConversationElem() override;
  explicit PROTOBUF_CONSTEXPR ConversationElem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConversationElem(const ConversationElem& from);
  ConversationElem(ConversationElem&& from) noexcept
    : ConversationElem() {
    *this = ::std::move(from);
  }

  inline ConversationElem& operator=(const ConversationElem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationElem& operator=(ConversationElem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConversationElem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConversationElem* internal_default_instance() {
    return reinterpret_cast<const ConversationElem*>(
               &_ConversationElem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConversationElem& a, ConversationElem& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationElem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationElem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConversationElem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConversationElem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConversationElem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConversationElem& from) {
    ConversationElem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationElem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.ConversationElem";
  }
  protected:
  explicit ConversationElem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kMsgInfoFieldNumber = 5,
    kUnreadCountFieldNumber = 3,
    kRecvMsgOptFieldNumber = 2,
    kIsPinnedFieldNumber = 4,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // .conversation.MsgInfo msgInfo = 5;
  bool has_msginfo() const;
  private:
  bool _internal_has_msginfo() const;
  public:
  void clear_msginfo();
  const ::conversation::MsgInfo& msginfo() const;
  PROTOBUF_NODISCARD ::conversation::MsgInfo* release_msginfo();
  ::conversation::MsgInfo* mutable_msginfo();
  void set_allocated_msginfo(::conversation::MsgInfo* msginfo);
  private:
  const ::conversation::MsgInfo& _internal_msginfo() const;
  ::conversation::MsgInfo* _internal_mutable_msginfo();
  public:
  void unsafe_arena_set_allocated_msginfo(
      ::conversation::MsgInfo* msginfo);
  ::conversation::MsgInfo* unsafe_arena_release_msginfo();

  // int64 unreadCount = 3;
  void clear_unreadcount();
  int64_t unreadcount() const;
  void set_unreadcount(int64_t value);
  private:
  int64_t _internal_unreadcount() const;
  void _internal_set_unreadcount(int64_t value);
  public:

  // int32 recvMsgOpt = 2;
  void clear_recvmsgopt();
  int32_t recvmsgopt() const;
  void set_recvmsgopt(int32_t value);
  private:
  int32_t _internal_recvmsgopt() const;
  void _internal_set_recvmsgopt(int32_t value);
  public:

  // bool IsPinned = 4;
  void clear_ispinned();
  bool ispinned() const;
  void set_ispinned(bool value);
  private:
  bool _internal_ispinned() const;
  void _internal_set_ispinned(bool value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.ConversationElem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::conversation::MsgInfo* msginfo_;
    int64_t unreadcount_;
    int32_t recvmsgopt_;
    bool ispinned_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class MsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.MsgInfo) */ {
 public:
  inline MsgInfo() : MsgInfo(nullptr) {}
  ~MsgInfo() override;
  explicit PROTOBUF_CONSTEXPR MsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInfo(const MsgInfo& from);
  MsgInfo(MsgInfo&& from) noexcept
    : MsgInfo() {
    *this = ::std::move(from);
  }

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInfo& operator=(MsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInfo* internal_default_instance() {
    return reinterpret_cast<const MsgInfo*>(
               &_MsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MsgInfo& a, MsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgInfo& from) {
    MsgInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.MsgInfo";
  }
  protected:
  explicit MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerMsgIDFieldNumber = 1,
    kClientMsgIDFieldNumber = 2,
    kSendIDFieldNumber = 4,
    kRecvIDFieldNumber = 5,
    kSenderNameFieldNumber = 6,
    kFaceURLFieldNumber = 7,
    kGroupIDFieldNumber = 8,
    kGroupNameFieldNumber = 9,
    kGroupFaceURLFieldNumber = 10,
    kContentFieldNumber = 16,
    kExFieldNumber = 17,
    kSessionTypeFieldNumber = 3,
    kGroupTypeFieldNumber = 11,
    kLatestMsgRecvTimeFieldNumber = 13,
    kGroupMemberCountFieldNumber = 12,
    kMsgFromFieldNumber = 14,
    kContentTypeFieldNumber = 15,
  };
  // string serverMsgID = 1;
  void clear_servermsgid();
  const std::string& servermsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servermsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servermsgid();
  PROTOBUF_NODISCARD std::string* release_servermsgid();
  void set_allocated_servermsgid(std::string* servermsgid);
  private:
  const std::string& _internal_servermsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servermsgid(const std::string& value);
  std::string* _internal_mutable_servermsgid();
  public:

  // string clientMsgID = 2;
  void clear_clientmsgid();
  const std::string& clientmsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientmsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientmsgid();
  PROTOBUF_NODISCARD std::string* release_clientmsgid();
  void set_allocated_clientmsgid(std::string* clientmsgid);
  private:
  const std::string& _internal_clientmsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientmsgid(const std::string& value);
  std::string* _internal_mutable_clientmsgid();
  public:

  // string sendID = 4;
  void clear_sendid();
  const std::string& sendid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendid();
  PROTOBUF_NODISCARD std::string* release_sendid();
  void set_allocated_sendid(std::string* sendid);
  private:
  const std::string& _internal_sendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendid(const std::string& value);
  std::string* _internal_mutable_sendid();
  public:

  // string recvID = 5;
  void clear_recvid();
  const std::string& recvid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recvid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recvid();
  PROTOBUF_NODISCARD std::string* release_recvid();
  void set_allocated_recvid(std::string* recvid);
  private:
  const std::string& _internal_recvid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recvid(const std::string& value);
  std::string* _internal_mutable_recvid();
  public:

  // string senderName = 6;
  void clear_sendername();
  const std::string& sendername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendername();
  PROTOBUF_NODISCARD std::string* release_sendername();
  void set_allocated_sendername(std::string* sendername);
  private:
  const std::string& _internal_sendername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendername(const std::string& value);
  std::string* _internal_mutable_sendername();
  public:

  // string faceURL = 7;
  void clear_faceurl();
  const std::string& faceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_faceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_faceurl();
  PROTOBUF_NODISCARD std::string* release_faceurl();
  void set_allocated_faceurl(std::string* faceurl);
  private:
  const std::string& _internal_faceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_faceurl(const std::string& value);
  std::string* _internal_mutable_faceurl();
  public:

  // string groupID = 8;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // string groupName = 9;
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // string groupFaceURL = 10;
  void clear_groupfaceurl();
  const std::string& groupfaceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupfaceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupfaceurl();
  PROTOBUF_NODISCARD std::string* release_groupfaceurl();
  void set_allocated_groupfaceurl(std::string* groupfaceurl);
  private:
  const std::string& _internal_groupfaceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupfaceurl(const std::string& value);
  std::string* _internal_mutable_groupfaceurl();
  public:

  // string content = 16;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string ex = 17;
  void clear_ex();
  const std::string& ex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ex();
  PROTOBUF_NODISCARD std::string* release_ex();
  void set_allocated_ex(std::string* ex);
  private:
  const std::string& _internal_ex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ex(const std::string& value);
  std::string* _internal_mutable_ex();
  public:

  // int32 sessionType = 3;
  void clear_sessiontype();
  int32_t sessiontype() const;
  void set_sessiontype(int32_t value);
  private:
  int32_t _internal_sessiontype() const;
  void _internal_set_sessiontype(int32_t value);
  public:

  // int32 groupType = 11;
  void clear_grouptype();
  int32_t grouptype() const;
  void set_grouptype(int32_t value);
  private:
  int32_t _internal_grouptype() const;
  void _internal_set_grouptype(int32_t value);
  public:

  // int64 LatestMsgRecvTime = 13;
  void clear_latestmsgrecvtime();
  int64_t latestmsgrecvtime() const;
  void set_latestmsgrecvtime(int64_t value);
  private:
  int64_t _internal_latestmsgrecvtime() const;
  void _internal_set_latestmsgrecvtime(int64_t value);
  public:

  // uint32 groupMemberCount = 12;
  void clear_groupmembercount();
  uint32_t groupmembercount() const;
  void set_groupmembercount(uint32_t value);
  private:
  uint32_t _internal_groupmembercount() const;
  void _internal_set_groupmembercount(uint32_t value);
  public:

  // int32 msgFrom = 14;
  void clear_msgfrom();
  int32_t msgfrom() const;
  void set_msgfrom(int32_t value);
  private:
  int32_t _internal_msgfrom() const;
  void _internal_set_msgfrom(int32_t value);
  public:

  // int32 contentType = 15;
  void clear_contenttype();
  int32_t contenttype() const;
  void set_contenttype(int32_t value);
  private:
  int32_t _internal_contenttype() const;
  void _internal_set_contenttype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.MsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servermsgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientmsgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recvid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr faceurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupfaceurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ex_;
    int32_t sessiontype_;
    int32_t grouptype_;
    int64_t latestmsgrecvtime_;
    uint32_t groupmembercount_;
    int32_t msgfrom_;
    int32_t contenttype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationsReq) */ {
 public:
  inline GetConversationsReq() : GetConversationsReq(nullptr) {}
  ~GetConversationsReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsReq(const GetConversationsReq& from);
  GetConversationsReq(GetConversationsReq&& from) noexcept
    : GetConversationsReq() {
    *this = ::std::move(from);
  }

  inline GetConversationsReq& operator=(const GetConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsReq& operator=(GetConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationsReq*>(
               &_GetConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetConversationsReq& a, GetConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsReq& from) {
    GetConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationsReq";
  }
  protected:
  explicit GetConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 2,
    kOwnerUserIDFieldNumber = 1,
  };
  // repeated string conversationIDs = 2;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string ownerUserID = 1;
  void clear_owneruserid();
  const std::string& owneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* owneruserid);
  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(const std::string& value);
  std::string* _internal_mutable_owneruserid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationsResp) */ {
 public:
  inline GetConversationsResp() : GetConversationsResp(nullptr) {}
  ~GetConversationsResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsResp(const GetConversationsResp& from);
  GetConversationsResp(GetConversationsResp&& from) noexcept
    : GetConversationsResp() {
    *this = ::std::move(from);
  }

  inline GetConversationsResp& operator=(const GetConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsResp& operator=(GetConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationsResp*>(
               &_GetConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetConversationsResp& a, GetConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsResp& from) {
    GetConversationsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationsResp";
  }
  protected:
  explicit GetConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
  };
  // repeated .conversation.Conversation conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::conversation::Conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_conversations();
  private:
  const ::conversation::Conversation& _internal_conversations(int index) const;
  ::conversation::Conversation* _internal_add_conversations();
  public:
  const ::conversation::Conversation& conversations(int index) const;
  ::conversation::Conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      conversations() const;

  // @@protoc_insertion_point(class_scope:conversation.GetConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetAllConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetAllConversationsReq) */ {
 public:
  inline GetAllConversationsReq() : GetAllConversationsReq(nullptr) {}
  ~GetAllConversationsReq() override;
  explicit PROTOBUF_CONSTEXPR GetAllConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllConversationsReq(const GetAllConversationsReq& from);
  GetAllConversationsReq(GetAllConversationsReq&& from) noexcept
    : GetAllConversationsReq() {
    *this = ::std::move(from);
  }

  inline GetAllConversationsReq& operator=(const GetAllConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllConversationsReq& operator=(GetAllConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllConversationsReq* internal_default_instance() {
    return reinterpret_cast<const GetAllConversationsReq*>(
               &_GetAllConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetAllConversationsReq& a, GetAllConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllConversationsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllConversationsReq& from) {
    GetAllConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetAllConversationsReq";
  }
  protected:
  explicit GetAllConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 1,
  };
  // string ownerUserID = 1;
  void clear_owneruserid();
  const std::string& owneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* owneruserid);
  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(const std::string& value);
  std::string* _internal_mutable_owneruserid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetAllConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetAllConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetAllConversationsResp) */ {
 public:
  inline GetAllConversationsResp() : GetAllConversationsResp(nullptr) {}
  ~GetAllConversationsResp() override;
  explicit PROTOBUF_CONSTEXPR GetAllConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllConversationsResp(const GetAllConversationsResp& from);
  GetAllConversationsResp(GetAllConversationsResp&& from) noexcept
    : GetAllConversationsResp() {
    *this = ::std::move(from);
  }

  inline GetAllConversationsResp& operator=(const GetAllConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllConversationsResp& operator=(GetAllConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllConversationsResp* internal_default_instance() {
    return reinterpret_cast<const GetAllConversationsResp*>(
               &_GetAllConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetAllConversationsResp& a, GetAllConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllConversationsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllConversationsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllConversationsResp& from) {
    GetAllConversationsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllConversationsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetAllConversationsResp";
  }
  protected:
  explicit GetAllConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
  };
  // repeated .conversation.Conversation conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::conversation::Conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_conversations();
  private:
  const ::conversation::Conversation& _internal_conversations(int index) const;
  ::conversation::Conversation* _internal_add_conversations();
  public:
  const ::conversation::Conversation& conversations(int index) const;
  ::conversation::Conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      conversations() const;

  // @@protoc_insertion_point(class_scope:conversation.GetAllConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetRecvMsgNotNotifyUserIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetRecvMsgNotNotifyUserIDsReq) */ {
 public:
  inline GetRecvMsgNotNotifyUserIDsReq() : GetRecvMsgNotNotifyUserIDsReq(nullptr) {}
  ~GetRecvMsgNotNotifyUserIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetRecvMsgNotNotifyUserIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRecvMsgNotNotifyUserIDsReq(const GetRecvMsgNotNotifyUserIDsReq& from);
  GetRecvMsgNotNotifyUserIDsReq(GetRecvMsgNotNotifyUserIDsReq&& from) noexcept
    : GetRecvMsgNotNotifyUserIDsReq() {
    *this = ::std::move(from);
  }

  inline GetRecvMsgNotNotifyUserIDsReq& operator=(const GetRecvMsgNotNotifyUserIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRecvMsgNotNotifyUserIDsReq& operator=(GetRecvMsgNotNotifyUserIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRecvMsgNotNotifyUserIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRecvMsgNotNotifyUserIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetRecvMsgNotNotifyUserIDsReq*>(
               &_GetRecvMsgNotNotifyUserIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetRecvMsgNotNotifyUserIDsReq& a, GetRecvMsgNotNotifyUserIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRecvMsgNotNotifyUserIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRecvMsgNotNotifyUserIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRecvMsgNotNotifyUserIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRecvMsgNotNotifyUserIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRecvMsgNotNotifyUserIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRecvMsgNotNotifyUserIDsReq& from) {
    GetRecvMsgNotNotifyUserIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRecvMsgNotNotifyUserIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetRecvMsgNotNotifyUserIDsReq";
  }
  protected:
  explicit GetRecvMsgNotNotifyUserIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIDFieldNumber = 1,
  };
  // string groupID = 1;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetRecvMsgNotNotifyUserIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetRecvMsgNotNotifyUserIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetRecvMsgNotNotifyUserIDsResp) */ {
 public:
  inline GetRecvMsgNotNotifyUserIDsResp() : GetRecvMsgNotNotifyUserIDsResp(nullptr) {}
  ~GetRecvMsgNotNotifyUserIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetRecvMsgNotNotifyUserIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRecvMsgNotNotifyUserIDsResp(const GetRecvMsgNotNotifyUserIDsResp& from);
  GetRecvMsgNotNotifyUserIDsResp(GetRecvMsgNotNotifyUserIDsResp&& from) noexcept
    : GetRecvMsgNotNotifyUserIDsResp() {
    *this = ::std::move(from);
  }

  inline GetRecvMsgNotNotifyUserIDsResp& operator=(const GetRecvMsgNotNotifyUserIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRecvMsgNotNotifyUserIDsResp& operator=(GetRecvMsgNotNotifyUserIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRecvMsgNotNotifyUserIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRecvMsgNotNotifyUserIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetRecvMsgNotNotifyUserIDsResp*>(
               &_GetRecvMsgNotNotifyUserIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetRecvMsgNotNotifyUserIDsResp& a, GetRecvMsgNotNotifyUserIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRecvMsgNotNotifyUserIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRecvMsgNotNotifyUserIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRecvMsgNotNotifyUserIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRecvMsgNotNotifyUserIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRecvMsgNotNotifyUserIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRecvMsgNotNotifyUserIDsResp& from) {
    GetRecvMsgNotNotifyUserIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRecvMsgNotNotifyUserIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetRecvMsgNotNotifyUserIDsResp";
  }
  protected:
  explicit GetRecvMsgNotNotifyUserIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetRecvMsgNotNotifyUserIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class CreateSingleChatConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.CreateSingleChatConversationsReq) */ {
 public:
  inline CreateSingleChatConversationsReq() : CreateSingleChatConversationsReq(nullptr) {}
  ~CreateSingleChatConversationsReq() override;
  explicit PROTOBUF_CONSTEXPR CreateSingleChatConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSingleChatConversationsReq(const CreateSingleChatConversationsReq& from);
  CreateSingleChatConversationsReq(CreateSingleChatConversationsReq&& from) noexcept
    : CreateSingleChatConversationsReq() {
    *this = ::std::move(from);
  }

  inline CreateSingleChatConversationsReq& operator=(const CreateSingleChatConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSingleChatConversationsReq& operator=(CreateSingleChatConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSingleChatConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSingleChatConversationsReq* internal_default_instance() {
    return reinterpret_cast<const CreateSingleChatConversationsReq*>(
               &_CreateSingleChatConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateSingleChatConversationsReq& a, CreateSingleChatConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSingleChatConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSingleChatConversationsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSingleChatConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSingleChatConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSingleChatConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSingleChatConversationsReq& from) {
    CreateSingleChatConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSingleChatConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.CreateSingleChatConversationsReq";
  }
  protected:
  explicit CreateSingleChatConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecvIDFieldNumber = 1,
    kSendIDFieldNumber = 2,
    kConversationIDFieldNumber = 3,
    kConversationTypeFieldNumber = 4,
  };
  // string recvID = 1;
  void clear_recvid();
  const std::string& recvid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recvid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recvid();
  PROTOBUF_NODISCARD std::string* release_recvid();
  void set_allocated_recvid(std::string* recvid);
  private:
  const std::string& _internal_recvid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recvid(const std::string& value);
  std::string* _internal_mutable_recvid();
  public:

  // string sendID = 2;
  void clear_sendid();
  const std::string& sendid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendid();
  PROTOBUF_NODISCARD std::string* release_sendid();
  void set_allocated_sendid(std::string* sendid);
  private:
  const std::string& _internal_sendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendid(const std::string& value);
  std::string* _internal_mutable_sendid();
  public:

  // string conversationID = 3;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int32 conversationType = 4;
  void clear_conversationtype();
  int32_t conversationtype() const;
  void set_conversationtype(int32_t value);
  private:
  int32_t _internal_conversationtype() const;
  void _internal_set_conversationtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.CreateSingleChatConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recvid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int32_t conversationtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class CreateSingleChatConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.CreateSingleChatConversationsResp) */ {
 public:
  inline CreateSingleChatConversationsResp() : CreateSingleChatConversationsResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateSingleChatConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSingleChatConversationsResp(const CreateSingleChatConversationsResp& from);
  CreateSingleChatConversationsResp(CreateSingleChatConversationsResp&& from) noexcept
    : CreateSingleChatConversationsResp() {
    *this = ::std::move(from);
  }

  inline CreateSingleChatConversationsResp& operator=(const CreateSingleChatConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSingleChatConversationsResp& operator=(CreateSingleChatConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSingleChatConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSingleChatConversationsResp* internal_default_instance() {
    return reinterpret_cast<const CreateSingleChatConversationsResp*>(
               &_CreateSingleChatConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateSingleChatConversationsResp& a, CreateSingleChatConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSingleChatConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSingleChatConversationsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSingleChatConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSingleChatConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateSingleChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateSingleChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.CreateSingleChatConversationsResp";
  }
  protected:
  explicit CreateSingleChatConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.CreateSingleChatConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupChatConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.CreateGroupChatConversationsReq) */ {
 public:
  inline CreateGroupChatConversationsReq() : CreateGroupChatConversationsReq(nullptr) {}
  ~CreateGroupChatConversationsReq() override;
  explicit PROTOBUF_CONSTEXPR CreateGroupChatConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupChatConversationsReq(const CreateGroupChatConversationsReq& from);
  CreateGroupChatConversationsReq(CreateGroupChatConversationsReq&& from) noexcept
    : CreateGroupChatConversationsReq() {
    *this = ::std::move(from);
  }

  inline CreateGroupChatConversationsReq& operator=(const CreateGroupChatConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupChatConversationsReq& operator=(CreateGroupChatConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupChatConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupChatConversationsReq* internal_default_instance() {
    return reinterpret_cast<const CreateGroupChatConversationsReq*>(
               &_CreateGroupChatConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateGroupChatConversationsReq& a, CreateGroupChatConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupChatConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupChatConversationsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupChatConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupChatConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGroupChatConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGroupChatConversationsReq& from) {
    CreateGroupChatConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupChatConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.CreateGroupChatConversationsReq";
  }
  protected:
  explicit CreateGroupChatConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
    kGroupIDFieldNumber = 2,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // string groupID = 2;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.CreateGroupChatConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupChatConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.CreateGroupChatConversationsResp) */ {
 public:
  inline CreateGroupChatConversationsResp() : CreateGroupChatConversationsResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateGroupChatConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupChatConversationsResp(const CreateGroupChatConversationsResp& from);
  CreateGroupChatConversationsResp(CreateGroupChatConversationsResp&& from) noexcept
    : CreateGroupChatConversationsResp() {
    *this = ::std::move(from);
  }

  inline CreateGroupChatConversationsResp& operator=(const CreateGroupChatConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupChatConversationsResp& operator=(CreateGroupChatConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupChatConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupChatConversationsResp* internal_default_instance() {
    return reinterpret_cast<const CreateGroupChatConversationsResp*>(
               &_CreateGroupChatConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateGroupChatConversationsResp& a, CreateGroupChatConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupChatConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupChatConversationsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupChatConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupChatConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateGroupChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateGroupChatConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.CreateGroupChatConversationsResp";
  }
  protected:
  explicit CreateGroupChatConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.CreateGroupChatConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationMaxSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.SetConversationMaxSeqReq) */ {
 public:
  inline SetConversationMaxSeqReq() : SetConversationMaxSeqReq(nullptr) {}
  ~SetConversationMaxSeqReq() override;
  explicit PROTOBUF_CONSTEXPR SetConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationMaxSeqReq(const SetConversationMaxSeqReq& from);
  SetConversationMaxSeqReq(SetConversationMaxSeqReq&& from) noexcept
    : SetConversationMaxSeqReq() {
    *this = ::std::move(from);
  }

  inline SetConversationMaxSeqReq& operator=(const SetConversationMaxSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationMaxSeqReq& operator=(SetConversationMaxSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationMaxSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationMaxSeqReq* internal_default_instance() {
    return reinterpret_cast<const SetConversationMaxSeqReq*>(
               &_SetConversationMaxSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetConversationMaxSeqReq& a, SetConversationMaxSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationMaxSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationMaxSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationMaxSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationMaxSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetConversationMaxSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetConversationMaxSeqReq& from) {
    SetConversationMaxSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetConversationMaxSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationMaxSeqReq";
  }
  protected:
  explicit SetConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kMaxSeqFieldNumber = 3,
  };
  // repeated string ownerUserID = 2;
  int owneruserid_size() const;
  private:
  int _internal_owneruserid_size() const;
  public:
  void clear_owneruserid();
  const std::string& owneruserid(int index) const;
  std::string* mutable_owneruserid(int index);
  void set_owneruserid(int index, const std::string& value);
  void set_owneruserid(int index, std::string&& value);
  void set_owneruserid(int index, const char* value);
  void set_owneruserid(int index, const char* value, size_t size);
  std::string* add_owneruserid();
  void add_owneruserid(const std::string& value);
  void add_owneruserid(std::string&& value);
  void add_owneruserid(const char* value);
  void add_owneruserid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owneruserid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owneruserid();
  private:
  const std::string& _internal_owneruserid(int index) const;
  std::string* _internal_add_owneruserid();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 maxSeq = 3;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.SetConversationMaxSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t maxseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationMaxSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.SetConversationMaxSeqResp) */ {
 public:
  inline SetConversationMaxSeqResp() : SetConversationMaxSeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationMaxSeqResp(const SetConversationMaxSeqResp& from);
  SetConversationMaxSeqResp(SetConversationMaxSeqResp&& from) noexcept
    : SetConversationMaxSeqResp() {
    *this = ::std::move(from);
  }

  inline SetConversationMaxSeqResp& operator=(const SetConversationMaxSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationMaxSeqResp& operator=(SetConversationMaxSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationMaxSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationMaxSeqResp* internal_default_instance() {
    return reinterpret_cast<const SetConversationMaxSeqResp*>(
               &_SetConversationMaxSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetConversationMaxSeqResp& a, SetConversationMaxSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationMaxSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationMaxSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationMaxSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationMaxSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConversationMaxSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConversationMaxSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationMaxSeqResp";
  }
  protected:
  explicit SetConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.SetConversationMaxSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationMinSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.SetConversationMinSeqReq) */ {
 public:
  inline SetConversationMinSeqReq() : SetConversationMinSeqReq(nullptr) {}
  ~SetConversationMinSeqReq() override;
  explicit PROTOBUF_CONSTEXPR SetConversationMinSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationMinSeqReq(const SetConversationMinSeqReq& from);
  SetConversationMinSeqReq(SetConversationMinSeqReq&& from) noexcept
    : SetConversationMinSeqReq() {
    *this = ::std::move(from);
  }

  inline SetConversationMinSeqReq& operator=(const SetConversationMinSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationMinSeqReq& operator=(SetConversationMinSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationMinSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationMinSeqReq* internal_default_instance() {
    return reinterpret_cast<const SetConversationMinSeqReq*>(
               &_SetConversationMinSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SetConversationMinSeqReq& a, SetConversationMinSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationMinSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationMinSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationMinSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationMinSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetConversationMinSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetConversationMinSeqReq& from) {
    SetConversationMinSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetConversationMinSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationMinSeqReq";
  }
  protected:
  explicit SetConversationMinSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kMinSeqFieldNumber = 3,
  };
  // repeated string ownerUserID = 2;
  int owneruserid_size() const;
  private:
  int _internal_owneruserid_size() const;
  public:
  void clear_owneruserid();
  const std::string& owneruserid(int index) const;
  std::string* mutable_owneruserid(int index);
  void set_owneruserid(int index, const std::string& value);
  void set_owneruserid(int index, std::string&& value);
  void set_owneruserid(int index, const char* value);
  void set_owneruserid(int index, const char* value, size_t size);
  std::string* add_owneruserid();
  void add_owneruserid(const std::string& value);
  void add_owneruserid(std::string&& value);
  void add_owneruserid(const char* value);
  void add_owneruserid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owneruserid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owneruserid();
  private:
  const std::string& _internal_owneruserid(int index) const;
  std::string* _internal_add_owneruserid();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 minSeq = 3;
  void clear_minseq();
  int64_t minseq() const;
  void set_minseq(int64_t value);
  private:
  int64_t _internal_minseq() const;
  void _internal_set_minseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.SetConversationMinSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t minseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationMinSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.SetConversationMinSeqResp) */ {
 public:
  inline SetConversationMinSeqResp() : SetConversationMinSeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetConversationMinSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationMinSeqResp(const SetConversationMinSeqResp& from);
  SetConversationMinSeqResp(SetConversationMinSeqResp&& from) noexcept
    : SetConversationMinSeqResp() {
    *this = ::std::move(from);
  }

  inline SetConversationMinSeqResp& operator=(const SetConversationMinSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationMinSeqResp& operator=(SetConversationMinSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationMinSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationMinSeqResp* internal_default_instance() {
    return reinterpret_cast<const SetConversationMinSeqResp*>(
               &_SetConversationMinSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SetConversationMinSeqResp& a, SetConversationMinSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationMinSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationMinSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationMinSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationMinSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConversationMinSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConversationMinSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationMinSeqResp";
  }
  protected:
  explicit SetConversationMinSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.SetConversationMinSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationIDsReq) */ {
 public:
  inline GetConversationIDsReq() : GetConversationIDsReq(nullptr) {}
  ~GetConversationIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationIDsReq(const GetConversationIDsReq& from);
  GetConversationIDsReq(GetConversationIDsReq&& from) noexcept
    : GetConversationIDsReq() {
    *this = ::std::move(from);
  }

  inline GetConversationIDsReq& operator=(const GetConversationIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationIDsReq& operator=(GetConversationIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationIDsReq*>(
               &_GetConversationIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetConversationIDsReq& a, GetConversationIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationIDsReq& from) {
    GetConversationIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationIDsReq";
  }
  protected:
  explicit GetConversationIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationIDsResp) */ {
 public:
  inline GetConversationIDsResp() : GetConversationIDsResp(nullptr) {}
  ~GetConversationIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationIDsResp(const GetConversationIDsResp& from);
  GetConversationIDsResp(GetConversationIDsResp&& from) noexcept
    : GetConversationIDsResp() {
    *this = ::std::move(from);
  }

  inline GetConversationIDsResp& operator=(const GetConversationIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationIDsResp& operator=(GetConversationIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationIDsResp*>(
               &_GetConversationIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetConversationIDsResp& a, GetConversationIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationIDsResp& from) {
    GetConversationIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationIDsResp";
  }
  protected:
  explicit GetConversationIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.SetConversationsReq) */ {
 public:
  inline SetConversationsReq() : SetConversationsReq(nullptr) {}
  ~SetConversationsReq() override;
  explicit PROTOBUF_CONSTEXPR SetConversationsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationsReq(const SetConversationsReq& from);
  SetConversationsReq(SetConversationsReq&& from) noexcept
    : SetConversationsReq() {
    *this = ::std::move(from);
  }

  inline SetConversationsReq& operator=(const SetConversationsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationsReq& operator=(SetConversationsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationsReq* internal_default_instance() {
    return reinterpret_cast<const SetConversationsReq*>(
               &_SetConversationsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetConversationsReq& a, SetConversationsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetConversationsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetConversationsReq& from) {
    SetConversationsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetConversationsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationsReq";
  }
  protected:
  explicit SetConversationsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
    kConversationFieldNumber = 2,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // .conversation.ConversationReq conversation = 2;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const ::conversation::ConversationReq& conversation() const;
  PROTOBUF_NODISCARD ::conversation::ConversationReq* release_conversation();
  ::conversation::ConversationReq* mutable_conversation();
  void set_allocated_conversation(::conversation::ConversationReq* conversation);
  private:
  const ::conversation::ConversationReq& _internal_conversation() const;
  ::conversation::ConversationReq* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::conversation::ConversationReq* conversation);
  ::conversation::ConversationReq* unsafe_arena_release_conversation();

  // @@protoc_insertion_point(class_scope:conversation.SetConversationsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    ::conversation::ConversationReq* conversation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class SetConversationsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.SetConversationsResp) */ {
 public:
  inline SetConversationsResp() : SetConversationsResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetConversationsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationsResp(const SetConversationsResp& from);
  SetConversationsResp(SetConversationsResp&& from) noexcept
    : SetConversationsResp() {
    *this = ::std::move(from);
  }

  inline SetConversationsResp& operator=(const SetConversationsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationsResp& operator=(SetConversationsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationsResp* internal_default_instance() {
    return reinterpret_cast<const SetConversationsResp*>(
               &_SetConversationsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SetConversationsResp& a, SetConversationsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConversationsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.SetConversationsResp";
  }
  protected:
  explicit SetConversationsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.SetConversationsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetUserConversationIDsHashReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetUserConversationIDsHashReq) */ {
 public:
  inline GetUserConversationIDsHashReq() : GetUserConversationIDsHashReq(nullptr) {}
  ~GetUserConversationIDsHashReq() override;
  explicit PROTOBUF_CONSTEXPR GetUserConversationIDsHashReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserConversationIDsHashReq(const GetUserConversationIDsHashReq& from);
  GetUserConversationIDsHashReq(GetUserConversationIDsHashReq&& from) noexcept
    : GetUserConversationIDsHashReq() {
    *this = ::std::move(from);
  }

  inline GetUserConversationIDsHashReq& operator=(const GetUserConversationIDsHashReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserConversationIDsHashReq& operator=(GetUserConversationIDsHashReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserConversationIDsHashReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserConversationIDsHashReq* internal_default_instance() {
    return reinterpret_cast<const GetUserConversationIDsHashReq*>(
               &_GetUserConversationIDsHashReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetUserConversationIDsHashReq& a, GetUserConversationIDsHashReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserConversationIDsHashReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserConversationIDsHashReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserConversationIDsHashReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserConversationIDsHashReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserConversationIDsHashReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserConversationIDsHashReq& from) {
    GetUserConversationIDsHashReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserConversationIDsHashReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetUserConversationIDsHashReq";
  }
  protected:
  explicit GetUserConversationIDsHashReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 1,
  };
  // string ownerUserID = 1;
  void clear_owneruserid();
  const std::string& owneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owneruserid();
  PROTOBUF_NODISCARD std::string* release_owneruserid();
  void set_allocated_owneruserid(std::string* owneruserid);
  private:
  const std::string& _internal_owneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owneruserid(const std::string& value);
  std::string* _internal_mutable_owneruserid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetUserConversationIDsHashReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owneruserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetUserConversationIDsHashResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetUserConversationIDsHashResp) */ {
 public:
  inline GetUserConversationIDsHashResp() : GetUserConversationIDsHashResp(nullptr) {}
  ~GetUserConversationIDsHashResp() override;
  explicit PROTOBUF_CONSTEXPR GetUserConversationIDsHashResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserConversationIDsHashResp(const GetUserConversationIDsHashResp& from);
  GetUserConversationIDsHashResp(GetUserConversationIDsHashResp&& from) noexcept
    : GetUserConversationIDsHashResp() {
    *this = ::std::move(from);
  }

  inline GetUserConversationIDsHashResp& operator=(const GetUserConversationIDsHashResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserConversationIDsHashResp& operator=(GetUserConversationIDsHashResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserConversationIDsHashResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserConversationIDsHashResp* internal_default_instance() {
    return reinterpret_cast<const GetUserConversationIDsHashResp*>(
               &_GetUserConversationIDsHashResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetUserConversationIDsHashResp& a, GetUserConversationIDsHashResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserConversationIDsHashResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserConversationIDsHashResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserConversationIDsHashResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserConversationIDsHashResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserConversationIDsHashResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserConversationIDsHashResp& from) {
    GetUserConversationIDsHashResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserConversationIDsHashResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetUserConversationIDsHashResp";
  }
  protected:
  explicit GetUserConversationIDsHashResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // uint64 hash = 1;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetUserConversationIDsHashResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsByConversationIDReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationsByConversationIDReq) */ {
 public:
  inline GetConversationsByConversationIDReq() : GetConversationsByConversationIDReq(nullptr) {}
  ~GetConversationsByConversationIDReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsByConversationIDReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsByConversationIDReq(const GetConversationsByConversationIDReq& from);
  GetConversationsByConversationIDReq(GetConversationsByConversationIDReq&& from) noexcept
    : GetConversationsByConversationIDReq() {
    *this = ::std::move(from);
  }

  inline GetConversationsByConversationIDReq& operator=(const GetConversationsByConversationIDReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsByConversationIDReq& operator=(GetConversationsByConversationIDReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsByConversationIDReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsByConversationIDReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationsByConversationIDReq*>(
               &_GetConversationsByConversationIDReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetConversationsByConversationIDReq& a, GetConversationsByConversationIDReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsByConversationIDReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsByConversationIDReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsByConversationIDReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsByConversationIDReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsByConversationIDReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsByConversationIDReq& from) {
    GetConversationsByConversationIDReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsByConversationIDReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationsByConversationIDReq";
  }
  protected:
  explicit GetConversationsByConversationIDReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationsByConversationIDReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsByConversationIDResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationsByConversationIDResp) */ {
 public:
  inline GetConversationsByConversationIDResp() : GetConversationsByConversationIDResp(nullptr) {}
  ~GetConversationsByConversationIDResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsByConversationIDResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsByConversationIDResp(const GetConversationsByConversationIDResp& from);
  GetConversationsByConversationIDResp(GetConversationsByConversationIDResp&& from) noexcept
    : GetConversationsByConversationIDResp() {
    *this = ::std::move(from);
  }

  inline GetConversationsByConversationIDResp& operator=(const GetConversationsByConversationIDResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsByConversationIDResp& operator=(GetConversationsByConversationIDResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsByConversationIDResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsByConversationIDResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationsByConversationIDResp*>(
               &_GetConversationsByConversationIDResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetConversationsByConversationIDResp& a, GetConversationsByConversationIDResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsByConversationIDResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsByConversationIDResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsByConversationIDResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsByConversationIDResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsByConversationIDResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsByConversationIDResp& from) {
    GetConversationsByConversationIDResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsByConversationIDResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationsByConversationIDResp";
  }
  protected:
  explicit GetConversationsByConversationIDResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 1,
  };
  // repeated .conversation.Conversation conversations = 1;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::conversation::Conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_conversations();
  private:
  const ::conversation::Conversation& _internal_conversations(int index) const;
  ::conversation::Conversation* _internal_add_conversations();
  public:
  const ::conversation::Conversation& conversations(int index) const;
  ::conversation::Conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      conversations() const;

  // @@protoc_insertion_point(class_scope:conversation.GetConversationsByConversationIDResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationOfflinePushUserIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationOfflinePushUserIDsReq) */ {
 public:
  inline GetConversationOfflinePushUserIDsReq() : GetConversationOfflinePushUserIDsReq(nullptr) {}
  ~GetConversationOfflinePushUserIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationOfflinePushUserIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationOfflinePushUserIDsReq(const GetConversationOfflinePushUserIDsReq& from);
  GetConversationOfflinePushUserIDsReq(GetConversationOfflinePushUserIDsReq&& from) noexcept
    : GetConversationOfflinePushUserIDsReq() {
    *this = ::std::move(from);
  }

  inline GetConversationOfflinePushUserIDsReq& operator=(const GetConversationOfflinePushUserIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationOfflinePushUserIDsReq& operator=(GetConversationOfflinePushUserIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationOfflinePushUserIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationOfflinePushUserIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationOfflinePushUserIDsReq*>(
               &_GetConversationOfflinePushUserIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetConversationOfflinePushUserIDsReq& a, GetConversationOfflinePushUserIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationOfflinePushUserIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationOfflinePushUserIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationOfflinePushUserIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationOfflinePushUserIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationOfflinePushUserIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationOfflinePushUserIDsReq& from) {
    GetConversationOfflinePushUserIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationOfflinePushUserIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationOfflinePushUserIDsReq";
  }
  protected:
  explicit GetConversationOfflinePushUserIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 2,
    kConversationIDFieldNumber = 1,
  };
  // repeated string userIDs = 2;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationOfflinePushUserIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationOfflinePushUserIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationOfflinePushUserIDsResp) */ {
 public:
  inline GetConversationOfflinePushUserIDsResp() : GetConversationOfflinePushUserIDsResp(nullptr) {}
  ~GetConversationOfflinePushUserIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationOfflinePushUserIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationOfflinePushUserIDsResp(const GetConversationOfflinePushUserIDsResp& from);
  GetConversationOfflinePushUserIDsResp(GetConversationOfflinePushUserIDsResp&& from) noexcept
    : GetConversationOfflinePushUserIDsResp() {
    *this = ::std::move(from);
  }

  inline GetConversationOfflinePushUserIDsResp& operator=(const GetConversationOfflinePushUserIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationOfflinePushUserIDsResp& operator=(GetConversationOfflinePushUserIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationOfflinePushUserIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationOfflinePushUserIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationOfflinePushUserIDsResp*>(
               &_GetConversationOfflinePushUserIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetConversationOfflinePushUserIDsResp& a, GetConversationOfflinePushUserIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationOfflinePushUserIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationOfflinePushUserIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationOfflinePushUserIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationOfflinePushUserIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationOfflinePushUserIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationOfflinePushUserIDsResp& from) {
    GetConversationOfflinePushUserIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationOfflinePushUserIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationOfflinePushUserIDsResp";
  }
  protected:
  explicit GetConversationOfflinePushUserIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationOfflinePushUserIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationNotReceiveMessageUserIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationNotReceiveMessageUserIDsReq) */ {
 public:
  inline GetConversationNotReceiveMessageUserIDsReq() : GetConversationNotReceiveMessageUserIDsReq(nullptr) {}
  ~GetConversationNotReceiveMessageUserIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationNotReceiveMessageUserIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationNotReceiveMessageUserIDsReq(const GetConversationNotReceiveMessageUserIDsReq& from);
  GetConversationNotReceiveMessageUserIDsReq(GetConversationNotReceiveMessageUserIDsReq&& from) noexcept
    : GetConversationNotReceiveMessageUserIDsReq() {
    *this = ::std::move(from);
  }

  inline GetConversationNotReceiveMessageUserIDsReq& operator=(const GetConversationNotReceiveMessageUserIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationNotReceiveMessageUserIDsReq& operator=(GetConversationNotReceiveMessageUserIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationNotReceiveMessageUserIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationNotReceiveMessageUserIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationNotReceiveMessageUserIDsReq*>(
               &_GetConversationNotReceiveMessageUserIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetConversationNotReceiveMessageUserIDsReq& a, GetConversationNotReceiveMessageUserIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationNotReceiveMessageUserIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationNotReceiveMessageUserIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationNotReceiveMessageUserIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationNotReceiveMessageUserIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationNotReceiveMessageUserIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationNotReceiveMessageUserIDsReq& from) {
    GetConversationNotReceiveMessageUserIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationNotReceiveMessageUserIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationNotReceiveMessageUserIDsReq";
  }
  protected:
  explicit GetConversationNotReceiveMessageUserIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationNotReceiveMessageUserIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationNotReceiveMessageUserIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationNotReceiveMessageUserIDsResp) */ {
 public:
  inline GetConversationNotReceiveMessageUserIDsResp() : GetConversationNotReceiveMessageUserIDsResp(nullptr) {}
  ~GetConversationNotReceiveMessageUserIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationNotReceiveMessageUserIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationNotReceiveMessageUserIDsResp(const GetConversationNotReceiveMessageUserIDsResp& from);
  GetConversationNotReceiveMessageUserIDsResp(GetConversationNotReceiveMessageUserIDsResp&& from) noexcept
    : GetConversationNotReceiveMessageUserIDsResp() {
    *this = ::std::move(from);
  }

  inline GetConversationNotReceiveMessageUserIDsResp& operator=(const GetConversationNotReceiveMessageUserIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationNotReceiveMessageUserIDsResp& operator=(GetConversationNotReceiveMessageUserIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationNotReceiveMessageUserIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationNotReceiveMessageUserIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationNotReceiveMessageUserIDsResp*>(
               &_GetConversationNotReceiveMessageUserIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetConversationNotReceiveMessageUserIDsResp& a, GetConversationNotReceiveMessageUserIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationNotReceiveMessageUserIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationNotReceiveMessageUserIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationNotReceiveMessageUserIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationNotReceiveMessageUserIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationNotReceiveMessageUserIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationNotReceiveMessageUserIDsResp& from) {
    GetConversationNotReceiveMessageUserIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationNotReceiveMessageUserIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationNotReceiveMessageUserIDsResp";
  }
  protected:
  explicit GetConversationNotReceiveMessageUserIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetConversationNotReceiveMessageUserIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class UpdateConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.UpdateConversationReq) */ {
 public:
  inline UpdateConversationReq() : UpdateConversationReq(nullptr) {}
  ~UpdateConversationReq() override;
  explicit PROTOBUF_CONSTEXPR UpdateConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateConversationReq(const UpdateConversationReq& from);
  UpdateConversationReq(UpdateConversationReq&& from) noexcept
    : UpdateConversationReq() {
    *this = ::std::move(from);
  }

  inline UpdateConversationReq& operator=(const UpdateConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConversationReq& operator=(UpdateConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConversationReq* internal_default_instance() {
    return reinterpret_cast<const UpdateConversationReq*>(
               &_UpdateConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(UpdateConversationReq& a, UpdateConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateConversationReq& from) {
    UpdateConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.UpdateConversationReq";
  }
  protected:
  explicit UpdateConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kAttachedInfoFieldNumber = 5,
    kExFieldNumber = 7,
    kRecvMsgOptFieldNumber = 3,
    kIsPinnedFieldNumber = 4,
    kIsPrivateChatFieldNumber = 6,
    kIsMsgDestructFieldNumber = 13,
    kMinSeqFieldNumber = 9,
    kBurnDurationFieldNumber = 8,
    kGroupAtTypeFieldNumber = 11,
    kMaxSeqFieldNumber = 10,
    kMsgDestructTimeFieldNumber = 12,
    kLatestMsgDestructTimeFieldNumber = 14,
  };
  // repeated string userIDs = 2;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string attachedInfo = 5;
  void clear_attachedinfo();
  const std::string& attachedinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachedinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachedinfo();
  PROTOBUF_NODISCARD std::string* release_attachedinfo();
  void set_allocated_attachedinfo(std::string* attachedinfo);
  private:
  const std::string& _internal_attachedinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachedinfo(const std::string& value);
  std::string* _internal_mutable_attachedinfo();
  public:

  // string ex = 7;
  void clear_ex();
  const std::string& ex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ex();
  PROTOBUF_NODISCARD std::string* release_ex();
  void set_allocated_ex(std::string* ex);
  private:
  const std::string& _internal_ex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ex(const std::string& value);
  std::string* _internal_mutable_ex();
  public:

  // int32 recvMsgOpt = 3;
  void clear_recvmsgopt();
  int32_t recvmsgopt() const;
  void set_recvmsgopt(int32_t value);
  private:
  int32_t _internal_recvmsgopt() const;
  void _internal_set_recvmsgopt(int32_t value);
  public:

  // bool isPinned = 4;
  void clear_ispinned();
  bool ispinned() const;
  void set_ispinned(bool value);
  private:
  bool _internal_ispinned() const;
  void _internal_set_ispinned(bool value);
  public:

  // bool isPrivateChat = 6;
  void clear_isprivatechat();
  bool isprivatechat() const;
  void set_isprivatechat(bool value);
  private:
  bool _internal_isprivatechat() const;
  void _internal_set_isprivatechat(bool value);
  public:

  // bool isMsgDestruct = 13;
  void clear_ismsgdestruct();
  bool ismsgdestruct() const;
  void set_ismsgdestruct(bool value);
  private:
  bool _internal_ismsgdestruct() const;
  void _internal_set_ismsgdestruct(bool value);
  public:

  // int64 minSeq = 9;
  void clear_minseq();
  int64_t minseq() const;
  void set_minseq(int64_t value);
  private:
  int64_t _internal_minseq() const;
  void _internal_set_minseq(int64_t value);
  public:

  // int32 burnDuration = 8;
  void clear_burnduration();
  int32_t burnduration() const;
  void set_burnduration(int32_t value);
  private:
  int32_t _internal_burnduration() const;
  void _internal_set_burnduration(int32_t value);
  public:

  // int32 groupAtType = 11;
  void clear_groupattype();
  int32_t groupattype() const;
  void set_groupattype(int32_t value);
  private:
  int32_t _internal_groupattype() const;
  void _internal_set_groupattype(int32_t value);
  public:

  // int64 maxSeq = 10;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // int64 msgDestructTime = 12;
  void clear_msgdestructtime();
  int64_t msgdestructtime() const;
  void set_msgdestructtime(int64_t value);
  private:
  int64_t _internal_msgdestructtime() const;
  void _internal_set_msgdestructtime(int64_t value);
  public:

  // int64 latestMsgDestructTime = 14;
  void clear_latestmsgdestructtime();
  int64_t latestmsgdestructtime() const;
  void set_latestmsgdestructtime(int64_t value);
  private:
  int64_t _internal_latestmsgdestructtime() const;
  void _internal_set_latestmsgdestructtime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.UpdateConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachedinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ex_;
    int32_t recvmsgopt_;
    bool ispinned_;
    bool isprivatechat_;
    bool ismsgdestruct_;
    int64_t minseq_;
    int32_t burnduration_;
    int32_t groupattype_;
    int64_t maxseq_;
    int64_t msgdestructtime_;
    int64_t latestmsgdestructtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class UpdateConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.UpdateConversationResp) */ {
 public:
  inline UpdateConversationResp() : UpdateConversationResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateConversationResp(const UpdateConversationResp& from);
  UpdateConversationResp(UpdateConversationResp&& from) noexcept
    : UpdateConversationResp() {
    *this = ::std::move(from);
  }

  inline UpdateConversationResp& operator=(const UpdateConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConversationResp& operator=(UpdateConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConversationResp* internal_default_instance() {
    return reinterpret_cast<const UpdateConversationResp*>(
               &_UpdateConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UpdateConversationResp& a, UpdateConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConversationResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateConversationResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateConversationResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.UpdateConversationResp";
  }
  protected:
  explicit UpdateConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.UpdateConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetFullOwnerConversationIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetFullOwnerConversationIDsReq) */ {
 public:
  inline GetFullOwnerConversationIDsReq() : GetFullOwnerConversationIDsReq(nullptr) {}
  ~GetFullOwnerConversationIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetFullOwnerConversationIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFullOwnerConversationIDsReq(const GetFullOwnerConversationIDsReq& from);
  GetFullOwnerConversationIDsReq(GetFullOwnerConversationIDsReq&& from) noexcept
    : GetFullOwnerConversationIDsReq() {
    *this = ::std::move(from);
  }

  inline GetFullOwnerConversationIDsReq& operator=(const GetFullOwnerConversationIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFullOwnerConversationIDsReq& operator=(GetFullOwnerConversationIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFullOwnerConversationIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFullOwnerConversationIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetFullOwnerConversationIDsReq*>(
               &_GetFullOwnerConversationIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetFullOwnerConversationIDsReq& a, GetFullOwnerConversationIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFullOwnerConversationIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFullOwnerConversationIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFullOwnerConversationIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFullOwnerConversationIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFullOwnerConversationIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFullOwnerConversationIDsReq& from) {
    GetFullOwnerConversationIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFullOwnerConversationIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetFullOwnerConversationIDsReq";
  }
  protected:
  explicit GetFullOwnerConversationIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 2,
    kIdHashFieldNumber = 1,
  };
  // string userID = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // uint64 idHash = 1;
  void clear_idhash();
  uint64_t idhash() const;
  void set_idhash(uint64_t value);
  private:
  uint64_t _internal_idhash() const;
  void _internal_set_idhash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetFullOwnerConversationIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    uint64_t idhash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetFullOwnerConversationIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetFullOwnerConversationIDsResp) */ {
 public:
  inline GetFullOwnerConversationIDsResp() : GetFullOwnerConversationIDsResp(nullptr) {}
  ~GetFullOwnerConversationIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetFullOwnerConversationIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFullOwnerConversationIDsResp(const GetFullOwnerConversationIDsResp& from);
  GetFullOwnerConversationIDsResp(GetFullOwnerConversationIDsResp&& from) noexcept
    : GetFullOwnerConversationIDsResp() {
    *this = ::std::move(from);
  }

  inline GetFullOwnerConversationIDsResp& operator=(const GetFullOwnerConversationIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFullOwnerConversationIDsResp& operator=(GetFullOwnerConversationIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFullOwnerConversationIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFullOwnerConversationIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetFullOwnerConversationIDsResp*>(
               &_GetFullOwnerConversationIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetFullOwnerConversationIDsResp& a, GetFullOwnerConversationIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFullOwnerConversationIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFullOwnerConversationIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFullOwnerConversationIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFullOwnerConversationIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFullOwnerConversationIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFullOwnerConversationIDsResp& from) {
    GetFullOwnerConversationIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFullOwnerConversationIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetFullOwnerConversationIDsResp";
  }
  protected:
  explicit GetFullOwnerConversationIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 4,
    kVersionIDFieldNumber = 2,
    kVersionFieldNumber = 1,
    kEqualFieldNumber = 3,
  };
  // repeated string conversationIDs = 4;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string versionID = 2;
  void clear_versionid();
  const std::string& versionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_versionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_versionid();
  PROTOBUF_NODISCARD std::string* release_versionid();
  void set_allocated_versionid(std::string* versionid);
  private:
  const std::string& _internal_versionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionid(const std::string& value);
  std::string* _internal_mutable_versionid();
  public:

  // uint64 version = 1;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // bool equal = 3;
  void clear_equal();
  bool equal() const;
  void set_equal(bool value);
  private:
  bool _internal_equal() const;
  void _internal_set_equal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetFullOwnerConversationIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionid_;
    uint64_t version_;
    bool equal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetIncrementalConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetIncrementalConversationReq) */ {
 public:
  inline GetIncrementalConversationReq() : GetIncrementalConversationReq(nullptr) {}
  ~GetIncrementalConversationReq() override;
  explicit PROTOBUF_CONSTEXPR GetIncrementalConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIncrementalConversationReq(const GetIncrementalConversationReq& from);
  GetIncrementalConversationReq(GetIncrementalConversationReq&& from) noexcept
    : GetIncrementalConversationReq() {
    *this = ::std::move(from);
  }

  inline GetIncrementalConversationReq& operator=(const GetIncrementalConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIncrementalConversationReq& operator=(GetIncrementalConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIncrementalConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIncrementalConversationReq* internal_default_instance() {
    return reinterpret_cast<const GetIncrementalConversationReq*>(
               &_GetIncrementalConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetIncrementalConversationReq& a, GetIncrementalConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIncrementalConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIncrementalConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIncrementalConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIncrementalConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIncrementalConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetIncrementalConversationReq& from) {
    GetIncrementalConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIncrementalConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetIncrementalConversationReq";
  }
  protected:
  explicit GetIncrementalConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kVersionIDFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string versionID = 2;
  void clear_versionid();
  const std::string& versionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_versionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_versionid();
  PROTOBUF_NODISCARD std::string* release_versionid();
  void set_allocated_versionid(std::string* versionid);
  private:
  const std::string& _internal_versionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionid(const std::string& value);
  std::string* _internal_mutable_versionid();
  public:

  // uint64 version = 3;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetIncrementalConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionid_;
    uint64_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetIncrementalConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetIncrementalConversationResp) */ {
 public:
  inline GetIncrementalConversationResp() : GetIncrementalConversationResp(nullptr) {}
  ~GetIncrementalConversationResp() override;
  explicit PROTOBUF_CONSTEXPR GetIncrementalConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIncrementalConversationResp(const GetIncrementalConversationResp& from);
  GetIncrementalConversationResp(GetIncrementalConversationResp&& from) noexcept
    : GetIncrementalConversationResp() {
    *this = ::std::move(from);
  }

  inline GetIncrementalConversationResp& operator=(const GetIncrementalConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIncrementalConversationResp& operator=(GetIncrementalConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIncrementalConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIncrementalConversationResp* internal_default_instance() {
    return reinterpret_cast<const GetIncrementalConversationResp*>(
               &_GetIncrementalConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetIncrementalConversationResp& a, GetIncrementalConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIncrementalConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIncrementalConversationResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIncrementalConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIncrementalConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIncrementalConversationResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetIncrementalConversationResp& from) {
    GetIncrementalConversationResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIncrementalConversationResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetIncrementalConversationResp";
  }
  protected:
  explicit GetIncrementalConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeleteFieldNumber = 4,
    kInsertFieldNumber = 5,
    kUpdateFieldNumber = 6,
    kVersionIDFieldNumber = 2,
    kVersionFieldNumber = 1,
    kFullFieldNumber = 3,
  };
  // repeated string delete = 4;
  int delete__size() const;
  private:
  int _internal_delete__size() const;
  public:
  void clear_delete_();
  const std::string& delete_(int index) const;
  std::string* mutable_delete_(int index);
  void set_delete_(int index, const std::string& value);
  void set_delete_(int index, std::string&& value);
  void set_delete_(int index, const char* value);
  void set_delete_(int index, const char* value, size_t size);
  std::string* add_delete_();
  void add_delete_(const std::string& value);
  void add_delete_(std::string&& value);
  void add_delete_(const char* value);
  void add_delete_(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delete_() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delete_();
  private:
  const std::string& _internal_delete_(int index) const;
  std::string* _internal_add_delete_();
  public:

  // repeated .conversation.Conversation insert = 5;
  int insert_size() const;
  private:
  int _internal_insert_size() const;
  public:
  void clear_insert();
  ::conversation::Conversation* mutable_insert(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_insert();
  private:
  const ::conversation::Conversation& _internal_insert(int index) const;
  ::conversation::Conversation* _internal_add_insert();
  public:
  const ::conversation::Conversation& insert(int index) const;
  ::conversation::Conversation* add_insert();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      insert() const;

  // repeated .conversation.Conversation update = 6;
  int update_size() const;
  private:
  int _internal_update_size() const;
  public:
  void clear_update();
  ::conversation::Conversation* mutable_update(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_update();
  private:
  const ::conversation::Conversation& _internal_update(int index) const;
  ::conversation::Conversation* _internal_add_update();
  public:
  const ::conversation::Conversation& update(int index) const;
  ::conversation::Conversation* add_update();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      update() const;

  // string versionID = 2;
  void clear_versionid();
  const std::string& versionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_versionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_versionid();
  PROTOBUF_NODISCARD std::string* release_versionid();
  void set_allocated_versionid(std::string* versionid);
  private:
  const std::string& _internal_versionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionid(const std::string& value);
  std::string* _internal_mutable_versionid();
  public:

  // uint64 version = 1;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // bool full = 3;
  void clear_full();
  bool full() const;
  void set_full(bool value);
  private:
  bool _internal_full() const;
  void _internal_set_full(bool value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetIncrementalConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delete__;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > insert_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > update_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionid_;
    uint64_t version_;
    bool full_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetOwnerConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetOwnerConversationReq) */ {
 public:
  inline GetOwnerConversationReq() : GetOwnerConversationReq(nullptr) {}
  ~GetOwnerConversationReq() override;
  explicit PROTOBUF_CONSTEXPR GetOwnerConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOwnerConversationReq(const GetOwnerConversationReq& from);
  GetOwnerConversationReq(GetOwnerConversationReq&& from) noexcept
    : GetOwnerConversationReq() {
    *this = ::std::move(from);
  }

  inline GetOwnerConversationReq& operator=(const GetOwnerConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOwnerConversationReq& operator=(GetOwnerConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOwnerConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOwnerConversationReq* internal_default_instance() {
    return reinterpret_cast<const GetOwnerConversationReq*>(
               &_GetOwnerConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetOwnerConversationReq& a, GetOwnerConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOwnerConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOwnerConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOwnerConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOwnerConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOwnerConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOwnerConversationReq& from) {
    GetOwnerConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOwnerConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetOwnerConversationReq";
  }
  protected:
  explicit GetOwnerConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kPaginationFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sdkws.RequestPagination pagination = 2;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sdkws::RequestPagination& pagination() const;
  PROTOBUF_NODISCARD ::sdkws::RequestPagination* release_pagination();
  ::sdkws::RequestPagination* mutable_pagination();
  void set_allocated_pagination(::sdkws::RequestPagination* pagination);
  private:
  const ::sdkws::RequestPagination& _internal_pagination() const;
  ::sdkws::RequestPagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sdkws::RequestPagination* pagination);
  ::sdkws::RequestPagination* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:conversation.GetOwnerConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::sdkws::RequestPagination* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetOwnerConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetOwnerConversationResp) */ {
 public:
  inline GetOwnerConversationResp() : GetOwnerConversationResp(nullptr) {}
  ~GetOwnerConversationResp() override;
  explicit PROTOBUF_CONSTEXPR GetOwnerConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOwnerConversationResp(const GetOwnerConversationResp& from);
  GetOwnerConversationResp(GetOwnerConversationResp&& from) noexcept
    : GetOwnerConversationResp() {
    *this = ::std::move(from);
  }

  inline GetOwnerConversationResp& operator=(const GetOwnerConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOwnerConversationResp& operator=(GetOwnerConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOwnerConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOwnerConversationResp* internal_default_instance() {
    return reinterpret_cast<const GetOwnerConversationResp*>(
               &_GetOwnerConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(GetOwnerConversationResp& a, GetOwnerConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOwnerConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOwnerConversationResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOwnerConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOwnerConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOwnerConversationResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOwnerConversationResp& from) {
    GetOwnerConversationResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOwnerConversationResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetOwnerConversationResp";
  }
  protected:
  explicit GetOwnerConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
    kTotalFieldNumber = 1,
  };
  // repeated .conversation.Conversation conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::conversation::Conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_conversations();
  private:
  const ::conversation::Conversation& _internal_conversations(int index) const;
  ::conversation::Conversation* _internal_add_conversations();
  public:
  const ::conversation::Conversation& conversations(int index) const;
  ::conversation::Conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      conversations() const;

  // int64 total = 1;
  void clear_total();
  int64_t total() const;
  void set_total(int64_t value);
  private:
  int64_t _internal_total() const;
  void _internal_set_total(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetOwnerConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > conversations_;
    int64_t total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsNeedClearMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.GetConversationsNeedClearMsgReq) */ {
 public:
  inline GetConversationsNeedClearMsgReq() : GetConversationsNeedClearMsgReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetConversationsNeedClearMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsNeedClearMsgReq(const GetConversationsNeedClearMsgReq& from);
  GetConversationsNeedClearMsgReq(GetConversationsNeedClearMsgReq&& from) noexcept
    : GetConversationsNeedClearMsgReq() {
    *this = ::std::move(from);
  }

  inline GetConversationsNeedClearMsgReq& operator=(const GetConversationsNeedClearMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsNeedClearMsgReq& operator=(GetConversationsNeedClearMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsNeedClearMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsNeedClearMsgReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationsNeedClearMsgReq*>(
               &_GetConversationsNeedClearMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(GetConversationsNeedClearMsgReq& a, GetConversationsNeedClearMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsNeedClearMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsNeedClearMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsNeedClearMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsNeedClearMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetConversationsNeedClearMsgReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetConversationsNeedClearMsgReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationsNeedClearMsgReq";
  }
  protected:
  explicit GetConversationsNeedClearMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.GetConversationsNeedClearMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsNeedClearMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetConversationsNeedClearMsgResp) */ {
 public:
  inline GetConversationsNeedClearMsgResp() : GetConversationsNeedClearMsgResp(nullptr) {}
  ~GetConversationsNeedClearMsgResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsNeedClearMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsNeedClearMsgResp(const GetConversationsNeedClearMsgResp& from);
  GetConversationsNeedClearMsgResp(GetConversationsNeedClearMsgResp&& from) noexcept
    : GetConversationsNeedClearMsgResp() {
    *this = ::std::move(from);
  }

  inline GetConversationsNeedClearMsgResp& operator=(const GetConversationsNeedClearMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsNeedClearMsgResp& operator=(GetConversationsNeedClearMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsNeedClearMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsNeedClearMsgResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationsNeedClearMsgResp*>(
               &_GetConversationsNeedClearMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(GetConversationsNeedClearMsgResp& a, GetConversationsNeedClearMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsNeedClearMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsNeedClearMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsNeedClearMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsNeedClearMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsNeedClearMsgResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsNeedClearMsgResp& from) {
    GetConversationsNeedClearMsgResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsNeedClearMsgResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetConversationsNeedClearMsgResp";
  }
  protected:
  explicit GetConversationsNeedClearMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 1,
  };
  // repeated .conversation.Conversation conversations = 1;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::conversation::Conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
      mutable_conversations();
  private:
  const ::conversation::Conversation& _internal_conversations(int index) const;
  ::conversation::Conversation* _internal_add_conversations();
  public:
  const ::conversation::Conversation& conversations(int index) const;
  ::conversation::Conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
      conversations() const;

  // @@protoc_insertion_point(class_scope:conversation.GetConversationsNeedClearMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetNotNotifyConversationIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetNotNotifyConversationIDsReq) */ {
 public:
  inline GetNotNotifyConversationIDsReq() : GetNotNotifyConversationIDsReq(nullptr) {}
  ~GetNotNotifyConversationIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetNotNotifyConversationIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNotNotifyConversationIDsReq(const GetNotNotifyConversationIDsReq& from);
  GetNotNotifyConversationIDsReq(GetNotNotifyConversationIDsReq&& from) noexcept
    : GetNotNotifyConversationIDsReq() {
    *this = ::std::move(from);
  }

  inline GetNotNotifyConversationIDsReq& operator=(const GetNotNotifyConversationIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNotNotifyConversationIDsReq& operator=(GetNotNotifyConversationIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNotNotifyConversationIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNotNotifyConversationIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetNotNotifyConversationIDsReq*>(
               &_GetNotNotifyConversationIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(GetNotNotifyConversationIDsReq& a, GetNotNotifyConversationIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNotNotifyConversationIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNotNotifyConversationIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNotNotifyConversationIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNotNotifyConversationIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNotNotifyConversationIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNotNotifyConversationIDsReq& from) {
    GetNotNotifyConversationIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNotNotifyConversationIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetNotNotifyConversationIDsReq";
  }
  protected:
  explicit GetNotNotifyConversationIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetNotNotifyConversationIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetNotNotifyConversationIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetNotNotifyConversationIDsResp) */ {
 public:
  inline GetNotNotifyConversationIDsResp() : GetNotNotifyConversationIDsResp(nullptr) {}
  ~GetNotNotifyConversationIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetNotNotifyConversationIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNotNotifyConversationIDsResp(const GetNotNotifyConversationIDsResp& from);
  GetNotNotifyConversationIDsResp(GetNotNotifyConversationIDsResp&& from) noexcept
    : GetNotNotifyConversationIDsResp() {
    *this = ::std::move(from);
  }

  inline GetNotNotifyConversationIDsResp& operator=(const GetNotNotifyConversationIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNotNotifyConversationIDsResp& operator=(GetNotNotifyConversationIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNotNotifyConversationIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNotNotifyConversationIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetNotNotifyConversationIDsResp*>(
               &_GetNotNotifyConversationIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GetNotNotifyConversationIDsResp& a, GetNotNotifyConversationIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNotNotifyConversationIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNotNotifyConversationIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNotNotifyConversationIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNotNotifyConversationIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNotNotifyConversationIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNotNotifyConversationIDsResp& from) {
    GetNotNotifyConversationIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNotNotifyConversationIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetNotNotifyConversationIDsResp";
  }
  protected:
  explicit GetNotNotifyConversationIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetNotNotifyConversationIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetPinnedConversationIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetPinnedConversationIDsReq) */ {
 public:
  inline GetPinnedConversationIDsReq() : GetPinnedConversationIDsReq(nullptr) {}
  ~GetPinnedConversationIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetPinnedConversationIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPinnedConversationIDsReq(const GetPinnedConversationIDsReq& from);
  GetPinnedConversationIDsReq(GetPinnedConversationIDsReq&& from) noexcept
    : GetPinnedConversationIDsReq() {
    *this = ::std::move(from);
  }

  inline GetPinnedConversationIDsReq& operator=(const GetPinnedConversationIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPinnedConversationIDsReq& operator=(GetPinnedConversationIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPinnedConversationIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPinnedConversationIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetPinnedConversationIDsReq*>(
               &_GetPinnedConversationIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetPinnedConversationIDsReq& a, GetPinnedConversationIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPinnedConversationIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPinnedConversationIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPinnedConversationIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPinnedConversationIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPinnedConversationIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPinnedConversationIDsReq& from) {
    GetPinnedConversationIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPinnedConversationIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetPinnedConversationIDsReq";
  }
  protected:
  explicit GetPinnedConversationIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetPinnedConversationIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class GetPinnedConversationIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.GetPinnedConversationIDsResp) */ {
 public:
  inline GetPinnedConversationIDsResp() : GetPinnedConversationIDsResp(nullptr) {}
  ~GetPinnedConversationIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetPinnedConversationIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPinnedConversationIDsResp(const GetPinnedConversationIDsResp& from);
  GetPinnedConversationIDsResp(GetPinnedConversationIDsResp&& from) noexcept
    : GetPinnedConversationIDsResp() {
    *this = ::std::move(from);
  }

  inline GetPinnedConversationIDsResp& operator=(const GetPinnedConversationIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPinnedConversationIDsResp& operator=(GetPinnedConversationIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPinnedConversationIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPinnedConversationIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetPinnedConversationIDsResp*>(
               &_GetPinnedConversationIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GetPinnedConversationIDsResp& a, GetPinnedConversationIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPinnedConversationIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPinnedConversationIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPinnedConversationIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPinnedConversationIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPinnedConversationIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPinnedConversationIDsResp& from) {
    GetPinnedConversationIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPinnedConversationIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.GetPinnedConversationIDsResp";
  }
  protected:
  explicit GetPinnedConversationIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // @@protoc_insertion_point(class_scope:conversation.GetPinnedConversationIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class ClearUserConversationMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.ClearUserConversationMsgReq) */ {
 public:
  inline ClearUserConversationMsgReq() : ClearUserConversationMsgReq(nullptr) {}
  ~ClearUserConversationMsgReq() override;
  explicit PROTOBUF_CONSTEXPR ClearUserConversationMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearUserConversationMsgReq(const ClearUserConversationMsgReq& from);
  ClearUserConversationMsgReq(ClearUserConversationMsgReq&& from) noexcept
    : ClearUserConversationMsgReq() {
    *this = ::std::move(from);
  }

  inline ClearUserConversationMsgReq& operator=(const ClearUserConversationMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearUserConversationMsgReq& operator=(ClearUserConversationMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearUserConversationMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearUserConversationMsgReq* internal_default_instance() {
    return reinterpret_cast<const ClearUserConversationMsgReq*>(
               &_ClearUserConversationMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ClearUserConversationMsgReq& a, ClearUserConversationMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearUserConversationMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearUserConversationMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearUserConversationMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearUserConversationMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearUserConversationMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearUserConversationMsgReq& from) {
    ClearUserConversationMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearUserConversationMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.ClearUserConversationMsgReq";
  }
  protected:
  explicit ClearUserConversationMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 limit = 2;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.ClearUserConversationMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class ClearUserConversationMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.ClearUserConversationMsgResp) */ {
 public:
  inline ClearUserConversationMsgResp() : ClearUserConversationMsgResp(nullptr) {}
  ~ClearUserConversationMsgResp() override;
  explicit PROTOBUF_CONSTEXPR ClearUserConversationMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearUserConversationMsgResp(const ClearUserConversationMsgResp& from);
  ClearUserConversationMsgResp(ClearUserConversationMsgResp&& from) noexcept
    : ClearUserConversationMsgResp() {
    *this = ::std::move(from);
  }

  inline ClearUserConversationMsgResp& operator=(const ClearUserConversationMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearUserConversationMsgResp& operator=(ClearUserConversationMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearUserConversationMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearUserConversationMsgResp* internal_default_instance() {
    return reinterpret_cast<const ClearUserConversationMsgResp*>(
               &_ClearUserConversationMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ClearUserConversationMsgResp& a, ClearUserConversationMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearUserConversationMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearUserConversationMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearUserConversationMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearUserConversationMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearUserConversationMsgResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearUserConversationMsgResp& from) {
    ClearUserConversationMsgResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearUserConversationMsgResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.ClearUserConversationMsgResp";
  }
  protected:
  explicit ClearUserConversationMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:conversation.ClearUserConversationMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class UpdateConversationsByUserReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:conversation.UpdateConversationsByUserReq) */ {
 public:
  inline UpdateConversationsByUserReq() : UpdateConversationsByUserReq(nullptr) {}
  ~UpdateConversationsByUserReq() override;
  explicit PROTOBUF_CONSTEXPR UpdateConversationsByUserReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateConversationsByUserReq(const UpdateConversationsByUserReq& from);
  UpdateConversationsByUserReq(UpdateConversationsByUserReq&& from) noexcept
    : UpdateConversationsByUserReq() {
    *this = ::std::move(from);
  }

  inline UpdateConversationsByUserReq& operator=(const UpdateConversationsByUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConversationsByUserReq& operator=(UpdateConversationsByUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConversationsByUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConversationsByUserReq* internal_default_instance() {
    return reinterpret_cast<const UpdateConversationsByUserReq*>(
               &_UpdateConversationsByUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(UpdateConversationsByUserReq& a, UpdateConversationsByUserReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConversationsByUserReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConversationsByUserReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConversationsByUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateConversationsByUserReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateConversationsByUserReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateConversationsByUserReq& from) {
    UpdateConversationsByUserReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConversationsByUserReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.UpdateConversationsByUserReq";
  }
  protected:
  explicit UpdateConversationsByUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kExFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string ex = 2;
  void clear_ex();
  const std::string& ex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ex();
  PROTOBUF_NODISCARD std::string* release_ex();
  void set_allocated_ex(std::string* ex);
  private:
  const std::string& _internal_ex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ex(const std::string& value);
  std::string* _internal_mutable_ex();
  public:

  // @@protoc_insertion_point(class_scope:conversation.UpdateConversationsByUserReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conversation_2eproto;
};
// -------------------------------------------------------------------

class UpdateConversationsByUserResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:conversation.UpdateConversationsByUserResp) */ {
 public:
  inline UpdateConversationsByUserResp() : UpdateConversationsByUserResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateConversationsByUserResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateConversationsByUserResp(const UpdateConversationsByUserResp& from);
  UpdateConversationsByUserResp(UpdateConversationsByUserResp&& from) noexcept
    : UpdateConversationsByUserResp() {
    *this = ::std::move(from);
  }

  inline UpdateConversationsByUserResp& operator=(const UpdateConversationsByUserResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConversationsByUserResp& operator=(UpdateConversationsByUserResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConversationsByUserResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConversationsByUserResp* internal_default_instance() {
    return reinterpret_cast<const UpdateConversationsByUserResp*>(
               &_UpdateConversationsByUserResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(UpdateConversationsByUserResp& a, UpdateConversationsByUserResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConversationsByUserResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConversationsByUserResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConversationsByUserResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateConversationsByUserResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateConversationsByUserResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateConversationsByUserResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "conversation.UpdateConversationsByUserResp";
  }
  protected:
  explicit UpdateConversationsByUserResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:conversation.UpdateConversationsByUserResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_conversation_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Conversation

// string ownerUserID = 1;
inline void Conversation::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& Conversation::owneruserid() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.ownerUserID)
  return _internal_owneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_owneruserid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.Conversation.ownerUserID)
}
inline std::string* Conversation::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:conversation.Conversation.ownerUserID)
  return _s;
}
inline const std::string& Conversation::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void Conversation::_internal_set_owneruserid(const std::string& value) {
  
  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_owneruserid() {
  
  return _impl_.owneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_owneruserid() {
  // @@protoc_insertion_point(field_release:conversation.Conversation.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void Conversation::set_allocated_owneruserid(std::string* owneruserid) {
  if (owneruserid != nullptr) {
    
  } else {
    
  }
  _impl_.owneruserid_.SetAllocated(owneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owneruserid_.IsDefault()) {
    _impl_.owneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.Conversation.ownerUserID)
}

// string conversationID = 2;
inline void Conversation::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& Conversation::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.Conversation.conversationID)
}
inline std::string* Conversation::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.Conversation.conversationID)
  return _s;
}
inline const std::string& Conversation::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void Conversation::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.Conversation.conversationID)
  return _impl_.conversationid_.Release();
}
inline void Conversation::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.Conversation.conversationID)
}

// int32 recvMsgOpt = 3;
inline void Conversation::clear_recvmsgopt() {
  _impl_.recvmsgopt_ = 0;
}
inline int32_t Conversation::_internal_recvmsgopt() const {
  return _impl_.recvmsgopt_;
}
inline int32_t Conversation::recvmsgopt() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.recvMsgOpt)
  return _internal_recvmsgopt();
}
inline void Conversation::_internal_set_recvmsgopt(int32_t value) {
  
  _impl_.recvmsgopt_ = value;
}
inline void Conversation::set_recvmsgopt(int32_t value) {
  _internal_set_recvmsgopt(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.recvMsgOpt)
}

// int32 conversationType = 4;
inline void Conversation::clear_conversationtype() {
  _impl_.conversationtype_ = 0;
}
inline int32_t Conversation::_internal_conversationtype() const {
  return _impl_.conversationtype_;
}
inline int32_t Conversation::conversationtype() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.conversationType)
  return _internal_conversationtype();
}
inline void Conversation::_internal_set_conversationtype(int32_t value) {
  
  _impl_.conversationtype_ = value;
}
inline void Conversation::set_conversationtype(int32_t value) {
  _internal_set_conversationtype(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.conversationType)
}

// string userID = 5;
inline void Conversation::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& Conversation::userid() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.Conversation.userID)
}
inline std::string* Conversation::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.Conversation.userID)
  return _s;
}
inline const std::string& Conversation::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void Conversation::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.Conversation.userID)
  return _impl_.userid_.Release();
}
inline void Conversation::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.Conversation.userID)
}

// string groupID = 6;
inline void Conversation::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& Conversation::groupid() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.groupID)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.Conversation.groupID)
}
inline std::string* Conversation::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:conversation.Conversation.groupID)
  return _s;
}
inline const std::string& Conversation::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void Conversation::_internal_set_groupid(const std::string& value) {
  
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_groupid() {
  
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_groupid() {
  // @@protoc_insertion_point(field_release:conversation.Conversation.groupID)
  return _impl_.groupid_.Release();
}
inline void Conversation::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.Conversation.groupID)
}

// bool isPinned = 7;
inline void Conversation::clear_ispinned() {
  _impl_.ispinned_ = false;
}
inline bool Conversation::_internal_ispinned() const {
  return _impl_.ispinned_;
}
inline bool Conversation::ispinned() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.isPinned)
  return _internal_ispinned();
}
inline void Conversation::_internal_set_ispinned(bool value) {
  
  _impl_.ispinned_ = value;
}
inline void Conversation::set_ispinned(bool value) {
  _internal_set_ispinned(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.isPinned)
}

// string attachedInfo = 8;
inline void Conversation::clear_attachedinfo() {
  _impl_.attachedinfo_.ClearToEmpty();
}
inline const std::string& Conversation::attachedinfo() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.attachedInfo)
  return _internal_attachedinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_attachedinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachedinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.Conversation.attachedInfo)
}
inline std::string* Conversation::mutable_attachedinfo() {
  std::string* _s = _internal_mutable_attachedinfo();
  // @@protoc_insertion_point(field_mutable:conversation.Conversation.attachedInfo)
  return _s;
}
inline const std::string& Conversation::_internal_attachedinfo() const {
  return _impl_.attachedinfo_.Get();
}
inline void Conversation::_internal_set_attachedinfo(const std::string& value) {
  
  _impl_.attachedinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_attachedinfo() {
  
  return _impl_.attachedinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_attachedinfo() {
  // @@protoc_insertion_point(field_release:conversation.Conversation.attachedInfo)
  return _impl_.attachedinfo_.Release();
}
inline void Conversation::set_allocated_attachedinfo(std::string* attachedinfo) {
  if (attachedinfo != nullptr) {
    
  } else {
    
  }
  _impl_.attachedinfo_.SetAllocated(attachedinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachedinfo_.IsDefault()) {
    _impl_.attachedinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.Conversation.attachedInfo)
}

// bool isPrivateChat = 9;
inline void Conversation::clear_isprivatechat() {
  _impl_.isprivatechat_ = false;
}
inline bool Conversation::_internal_isprivatechat() const {
  return _impl_.isprivatechat_;
}
inline bool Conversation::isprivatechat() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.isPrivateChat)
  return _internal_isprivatechat();
}
inline void Conversation::_internal_set_isprivatechat(bool value) {
  
  _impl_.isprivatechat_ = value;
}
inline void Conversation::set_isprivatechat(bool value) {
  _internal_set_isprivatechat(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.isPrivateChat)
}

// int32 groupAtType = 10;
inline void Conversation::clear_groupattype() {
  _impl_.groupattype_ = 0;
}
inline int32_t Conversation::_internal_groupattype() const {
  return _impl_.groupattype_;
}
inline int32_t Conversation::groupattype() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.groupAtType)
  return _internal_groupattype();
}
inline void Conversation::_internal_set_groupattype(int32_t value) {
  
  _impl_.groupattype_ = value;
}
inline void Conversation::set_groupattype(int32_t value) {
  _internal_set_groupattype(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.groupAtType)
}

// string ex = 11;
inline void Conversation::clear_ex() {
  _impl_.ex_.ClearToEmpty();
}
inline const std::string& Conversation::ex() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.ex)
  return _internal_ex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_ex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.Conversation.ex)
}
inline std::string* Conversation::mutable_ex() {
  std::string* _s = _internal_mutable_ex();
  // @@protoc_insertion_point(field_mutable:conversation.Conversation.ex)
  return _s;
}
inline const std::string& Conversation::_internal_ex() const {
  return _impl_.ex_.Get();
}
inline void Conversation::_internal_set_ex(const std::string& value) {
  
  _impl_.ex_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_ex() {
  
  return _impl_.ex_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_ex() {
  // @@protoc_insertion_point(field_release:conversation.Conversation.ex)
  return _impl_.ex_.Release();
}
inline void Conversation::set_allocated_ex(std::string* ex) {
  if (ex != nullptr) {
    
  } else {
    
  }
  _impl_.ex_.SetAllocated(ex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ex_.IsDefault()) {
    _impl_.ex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.Conversation.ex)
}

// int32 burnDuration = 12;
inline void Conversation::clear_burnduration() {
  _impl_.burnduration_ = 0;
}
inline int32_t Conversation::_internal_burnduration() const {
  return _impl_.burnduration_;
}
inline int32_t Conversation::burnduration() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.burnDuration)
  return _internal_burnduration();
}
inline void Conversation::_internal_set_burnduration(int32_t value) {
  
  _impl_.burnduration_ = value;
}
inline void Conversation::set_burnduration(int32_t value) {
  _internal_set_burnduration(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.burnDuration)
}

// int64 minSeq = 13;
inline void Conversation::clear_minseq() {
  _impl_.minseq_ = int64_t{0};
}
inline int64_t Conversation::_internal_minseq() const {
  return _impl_.minseq_;
}
inline int64_t Conversation::minseq() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.minSeq)
  return _internal_minseq();
}
inline void Conversation::_internal_set_minseq(int64_t value) {
  
  _impl_.minseq_ = value;
}
inline void Conversation::set_minseq(int64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.minSeq)
}

// int64 maxSeq = 14;
inline void Conversation::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t Conversation::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t Conversation::maxseq() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.maxSeq)
  return _internal_maxseq();
}
inline void Conversation::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void Conversation::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.maxSeq)
}

// int64 msgDestructTime = 15;
inline void Conversation::clear_msgdestructtime() {
  _impl_.msgdestructtime_ = int64_t{0};
}
inline int64_t Conversation::_internal_msgdestructtime() const {
  return _impl_.msgdestructtime_;
}
inline int64_t Conversation::msgdestructtime() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.msgDestructTime)
  return _internal_msgdestructtime();
}
inline void Conversation::_internal_set_msgdestructtime(int64_t value) {
  
  _impl_.msgdestructtime_ = value;
}
inline void Conversation::set_msgdestructtime(int64_t value) {
  _internal_set_msgdestructtime(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.msgDestructTime)
}

// int64 latestMsgDestructTime = 16;
inline void Conversation::clear_latestmsgdestructtime() {
  _impl_.latestmsgdestructtime_ = int64_t{0};
}
inline int64_t Conversation::_internal_latestmsgdestructtime() const {
  return _impl_.latestmsgdestructtime_;
}
inline int64_t Conversation::latestmsgdestructtime() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.latestMsgDestructTime)
  return _internal_latestmsgdestructtime();
}
inline void Conversation::_internal_set_latestmsgdestructtime(int64_t value) {
  
  _impl_.latestmsgdestructtime_ = value;
}
inline void Conversation::set_latestmsgdestructtime(int64_t value) {
  _internal_set_latestmsgdestructtime(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.latestMsgDestructTime)
}

// bool isMsgDestruct = 17;
inline void Conversation::clear_ismsgdestruct() {
  _impl_.ismsgdestruct_ = false;
}
inline bool Conversation::_internal_ismsgdestruct() const {
  return _impl_.ismsgdestruct_;
}
inline bool Conversation::ismsgdestruct() const {
  // @@protoc_insertion_point(field_get:conversation.Conversation.isMsgDestruct)
  return _internal_ismsgdestruct();
}
inline void Conversation::_internal_set_ismsgdestruct(bool value) {
  
  _impl_.ismsgdestruct_ = value;
}
inline void Conversation::set_ismsgdestruct(bool value) {
  _internal_set_ismsgdestruct(value);
  // @@protoc_insertion_point(field_set:conversation.Conversation.isMsgDestruct)
}

// -------------------------------------------------------------------

// ConversationInfo

// string conversationID = 1;
inline void ConversationInfo::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& ConversationInfo::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationInfo::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.conversationID)
}
inline std::string* ConversationInfo::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.conversationID)
  return _s;
}
inline const std::string& ConversationInfo::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void ConversationInfo::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationInfo::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationInfo::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.ConversationInfo.conversationID)
  return _impl_.conversationid_.Release();
}
inline void ConversationInfo::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationInfo.conversationID)
}

// string ownerUserID = 2;
inline void ConversationInfo::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& ConversationInfo::owneruserid() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.ownerUserID)
  return _internal_owneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationInfo::set_owneruserid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.ownerUserID)
}
inline std::string* ConversationInfo::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.ownerUserID)
  return _s;
}
inline const std::string& ConversationInfo::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void ConversationInfo::_internal_set_owneruserid(const std::string& value) {
  
  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationInfo::_internal_mutable_owneruserid() {
  
  return _impl_.owneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationInfo::release_owneruserid() {
  // @@protoc_insertion_point(field_release:conversation.ConversationInfo.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void ConversationInfo::set_allocated_owneruserid(std::string* owneruserid) {
  if (owneruserid != nullptr) {
    
  } else {
    
  }
  _impl_.owneruserid_.SetAllocated(owneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owneruserid_.IsDefault()) {
    _impl_.owneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationInfo.ownerUserID)
}

// int32 conversationType = 3;
inline void ConversationInfo::clear_conversationtype() {
  _impl_.conversationtype_ = 0;
}
inline int32_t ConversationInfo::_internal_conversationtype() const {
  return _impl_.conversationtype_;
}
inline int32_t ConversationInfo::conversationtype() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.conversationType)
  return _internal_conversationtype();
}
inline void ConversationInfo::_internal_set_conversationtype(int32_t value) {
  
  _impl_.conversationtype_ = value;
}
inline void ConversationInfo::set_conversationtype(int32_t value) {
  _internal_set_conversationtype(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.conversationType)
}

// string conversationName = 4;
inline void ConversationInfo::clear_conversationname() {
  _impl_.conversationname_.ClearToEmpty();
}
inline const std::string& ConversationInfo::conversationname() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.conversationName)
  return _internal_conversationname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationInfo::set_conversationname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.conversationName)
}
inline std::string* ConversationInfo::mutable_conversationname() {
  std::string* _s = _internal_mutable_conversationname();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.conversationName)
  return _s;
}
inline const std::string& ConversationInfo::_internal_conversationname() const {
  return _impl_.conversationname_.Get();
}
inline void ConversationInfo::_internal_set_conversationname(const std::string& value) {
  
  _impl_.conversationname_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationInfo::_internal_mutable_conversationname() {
  
  return _impl_.conversationname_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationInfo::release_conversationname() {
  // @@protoc_insertion_point(field_release:conversation.ConversationInfo.conversationName)
  return _impl_.conversationname_.Release();
}
inline void ConversationInfo::set_allocated_conversationname(std::string* conversationname) {
  if (conversationname != nullptr) {
    
  } else {
    
  }
  _impl_.conversationname_.SetAllocated(conversationname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationname_.IsDefault()) {
    _impl_.conversationname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationInfo.conversationName)
}

// string conversationAvatar = 5;
inline void ConversationInfo::clear_conversationavatar() {
  _impl_.conversationavatar_.ClearToEmpty();
}
inline const std::string& ConversationInfo::conversationavatar() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.conversationAvatar)
  return _internal_conversationavatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationInfo::set_conversationavatar(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationavatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.conversationAvatar)
}
inline std::string* ConversationInfo::mutable_conversationavatar() {
  std::string* _s = _internal_mutable_conversationavatar();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.conversationAvatar)
  return _s;
}
inline const std::string& ConversationInfo::_internal_conversationavatar() const {
  return _impl_.conversationavatar_.Get();
}
inline void ConversationInfo::_internal_set_conversationavatar(const std::string& value) {
  
  _impl_.conversationavatar_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationInfo::_internal_mutable_conversationavatar() {
  
  return _impl_.conversationavatar_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationInfo::release_conversationavatar() {
  // @@protoc_insertion_point(field_release:conversation.ConversationInfo.conversationAvatar)
  return _impl_.conversationavatar_.Release();
}
inline void ConversationInfo::set_allocated_conversationavatar(std::string* conversationavatar) {
  if (conversationavatar != nullptr) {
    
  } else {
    
  }
  _impl_.conversationavatar_.SetAllocated(conversationavatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationavatar_.IsDefault()) {
    _impl_.conversationavatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationInfo.conversationAvatar)
}

// repeated string participantUIDs = 6;
inline int ConversationInfo::_internal_participantuids_size() const {
  return _impl_.participantuids_.size();
}
inline int ConversationInfo::participantuids_size() const {
  return _internal_participantuids_size();
}
inline void ConversationInfo::clear_participantuids() {
  _impl_.participantuids_.Clear();
}
inline std::string* ConversationInfo::add_participantuids() {
  std::string* _s = _internal_add_participantuids();
  // @@protoc_insertion_point(field_add_mutable:conversation.ConversationInfo.participantUIDs)
  return _s;
}
inline const std::string& ConversationInfo::_internal_participantuids(int index) const {
  return _impl_.participantuids_.Get(index);
}
inline const std::string& ConversationInfo::participantuids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.participantUIDs)
  return _internal_participantuids(index);
}
inline std::string* ConversationInfo::mutable_participantuids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.participantUIDs)
  return _impl_.participantuids_.Mutable(index);
}
inline void ConversationInfo::set_participantuids(int index, const std::string& value) {
  _impl_.participantuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.participantUIDs)
}
inline void ConversationInfo::set_participantuids(int index, std::string&& value) {
  _impl_.participantuids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.participantUIDs)
}
inline void ConversationInfo::set_participantuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participantuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.ConversationInfo.participantUIDs)
}
inline void ConversationInfo::set_participantuids(int index, const char* value, size_t size) {
  _impl_.participantuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.ConversationInfo.participantUIDs)
}
inline std::string* ConversationInfo::_internal_add_participantuids() {
  return _impl_.participantuids_.Add();
}
inline void ConversationInfo::add_participantuids(const std::string& value) {
  _impl_.participantuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.participantUIDs)
}
inline void ConversationInfo::add_participantuids(std::string&& value) {
  _impl_.participantuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.participantUIDs)
}
inline void ConversationInfo::add_participantuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participantuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.ConversationInfo.participantUIDs)
}
inline void ConversationInfo::add_participantuids(const char* value, size_t size) {
  _impl_.participantuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.ConversationInfo.participantUIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationInfo::participantuids() const {
  // @@protoc_insertion_point(field_list:conversation.ConversationInfo.participantUIDs)
  return _impl_.participantuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationInfo::mutable_participantuids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.ConversationInfo.participantUIDs)
  return &_impl_.participantuids_;
}

// repeated string topUIDs = 7;
inline int ConversationInfo::_internal_topuids_size() const {
  return _impl_.topuids_.size();
}
inline int ConversationInfo::topuids_size() const {
  return _internal_topuids_size();
}
inline void ConversationInfo::clear_topuids() {
  _impl_.topuids_.Clear();
}
inline std::string* ConversationInfo::add_topuids() {
  std::string* _s = _internal_add_topuids();
  // @@protoc_insertion_point(field_add_mutable:conversation.ConversationInfo.topUIDs)
  return _s;
}
inline const std::string& ConversationInfo::_internal_topuids(int index) const {
  return _impl_.topuids_.Get(index);
}
inline const std::string& ConversationInfo::topuids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.topUIDs)
  return _internal_topuids(index);
}
inline std::string* ConversationInfo::mutable_topuids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.topUIDs)
  return _impl_.topuids_.Mutable(index);
}
inline void ConversationInfo::set_topuids(int index, const std::string& value) {
  _impl_.topuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.topUIDs)
}
inline void ConversationInfo::set_topuids(int index, std::string&& value) {
  _impl_.topuids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.topUIDs)
}
inline void ConversationInfo::set_topuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.ConversationInfo.topUIDs)
}
inline void ConversationInfo::set_topuids(int index, const char* value, size_t size) {
  _impl_.topuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.ConversationInfo.topUIDs)
}
inline std::string* ConversationInfo::_internal_add_topuids() {
  return _impl_.topuids_.Add();
}
inline void ConversationInfo::add_topuids(const std::string& value) {
  _impl_.topuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.topUIDs)
}
inline void ConversationInfo::add_topuids(std::string&& value) {
  _impl_.topuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.topUIDs)
}
inline void ConversationInfo::add_topuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.ConversationInfo.topUIDs)
}
inline void ConversationInfo::add_topuids(const char* value, size_t size) {
  _impl_.topuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.ConversationInfo.topUIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationInfo::topuids() const {
  // @@protoc_insertion_point(field_list:conversation.ConversationInfo.topUIDs)
  return _impl_.topuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationInfo::mutable_topuids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.ConversationInfo.topUIDs)
  return &_impl_.topuids_;
}

// int64 unreadCount = 8;
inline void ConversationInfo::clear_unreadcount() {
  _impl_.unreadcount_ = int64_t{0};
}
inline int64_t ConversationInfo::_internal_unreadcount() const {
  return _impl_.unreadcount_;
}
inline int64_t ConversationInfo::unreadcount() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.unreadCount)
  return _internal_unreadcount();
}
inline void ConversationInfo::_internal_set_unreadcount(int64_t value) {
  
  _impl_.unreadcount_ = value;
}
inline void ConversationInfo::set_unreadcount(int64_t value) {
  _internal_set_unreadcount(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.unreadCount)
}

// repeated string muteUIDs = 9;
inline int ConversationInfo::_internal_muteuids_size() const {
  return _impl_.muteuids_.size();
}
inline int ConversationInfo::muteuids_size() const {
  return _internal_muteuids_size();
}
inline void ConversationInfo::clear_muteuids() {
  _impl_.muteuids_.Clear();
}
inline std::string* ConversationInfo::add_muteuids() {
  std::string* _s = _internal_add_muteuids();
  // @@protoc_insertion_point(field_add_mutable:conversation.ConversationInfo.muteUIDs)
  return _s;
}
inline const std::string& ConversationInfo::_internal_muteuids(int index) const {
  return _impl_.muteuids_.Get(index);
}
inline const std::string& ConversationInfo::muteuids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.muteUIDs)
  return _internal_muteuids(index);
}
inline std::string* ConversationInfo::mutable_muteuids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.muteUIDs)
  return _impl_.muteuids_.Mutable(index);
}
inline void ConversationInfo::set_muteuids(int index, const std::string& value) {
  _impl_.muteuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.muteUIDs)
}
inline void ConversationInfo::set_muteuids(int index, std::string&& value) {
  _impl_.muteuids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.muteUIDs)
}
inline void ConversationInfo::set_muteuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.muteuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.ConversationInfo.muteUIDs)
}
inline void ConversationInfo::set_muteuids(int index, const char* value, size_t size) {
  _impl_.muteuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.ConversationInfo.muteUIDs)
}
inline std::string* ConversationInfo::_internal_add_muteuids() {
  return _impl_.muteuids_.Add();
}
inline void ConversationInfo::add_muteuids(const std::string& value) {
  _impl_.muteuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.muteUIDs)
}
inline void ConversationInfo::add_muteuids(std::string&& value) {
  _impl_.muteuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.muteUIDs)
}
inline void ConversationInfo::add_muteuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.muteuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.ConversationInfo.muteUIDs)
}
inline void ConversationInfo::add_muteuids(const char* value, size_t size) {
  _impl_.muteuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.ConversationInfo.muteUIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationInfo::muteuids() const {
  // @@protoc_insertion_point(field_list:conversation.ConversationInfo.muteUIDs)
  return _impl_.muteuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationInfo::mutable_muteuids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.ConversationInfo.muteUIDs)
  return &_impl_.muteuids_;
}

// repeated string foldUIDs = 10;
inline int ConversationInfo::_internal_folduids_size() const {
  return _impl_.folduids_.size();
}
inline int ConversationInfo::folduids_size() const {
  return _internal_folduids_size();
}
inline void ConversationInfo::clear_folduids() {
  _impl_.folduids_.Clear();
}
inline std::string* ConversationInfo::add_folduids() {
  std::string* _s = _internal_add_folduids();
  // @@protoc_insertion_point(field_add_mutable:conversation.ConversationInfo.foldUIDs)
  return _s;
}
inline const std::string& ConversationInfo::_internal_folduids(int index) const {
  return _impl_.folduids_.Get(index);
}
inline const std::string& ConversationInfo::folduids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.ConversationInfo.foldUIDs)
  return _internal_folduids(index);
}
inline std::string* ConversationInfo::mutable_folduids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.ConversationInfo.foldUIDs)
  return _impl_.folduids_.Mutable(index);
}
inline void ConversationInfo::set_folduids(int index, const std::string& value) {
  _impl_.folduids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.foldUIDs)
}
inline void ConversationInfo::set_folduids(int index, std::string&& value) {
  _impl_.folduids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.ConversationInfo.foldUIDs)
}
inline void ConversationInfo::set_folduids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.folduids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.ConversationInfo.foldUIDs)
}
inline void ConversationInfo::set_folduids(int index, const char* value, size_t size) {
  _impl_.folduids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.ConversationInfo.foldUIDs)
}
inline std::string* ConversationInfo::_internal_add_folduids() {
  return _impl_.folduids_.Add();
}
inline void ConversationInfo::add_folduids(const std::string& value) {
  _impl_.folduids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.foldUIDs)
}
inline void ConversationInfo::add_folduids(std::string&& value) {
  _impl_.folduids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.ConversationInfo.foldUIDs)
}
inline void ConversationInfo::add_folduids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.folduids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.ConversationInfo.foldUIDs)
}
inline void ConversationInfo::add_folduids(const char* value, size_t size) {
  _impl_.folduids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.ConversationInfo.foldUIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationInfo::folduids() const {
  // @@protoc_insertion_point(field_list:conversation.ConversationInfo.foldUIDs)
  return _impl_.folduids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationInfo::mutable_folduids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.ConversationInfo.foldUIDs)
  return &_impl_.folduids_;
}

// -------------------------------------------------------------------

// ConversationReq

// string conversationID = 1;
inline void ConversationReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& ConversationReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.conversationID)
}
inline std::string* ConversationReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationReq.conversationID)
  return _s;
}
inline const std::string& ConversationReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void ConversationReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.ConversationReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void ConversationReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationReq.conversationID)
}

// int32 conversationType = 2;
inline void ConversationReq::clear_conversationtype() {
  _impl_.conversationtype_ = 0;
}
inline int32_t ConversationReq::_internal_conversationtype() const {
  return _impl_.conversationtype_;
}
inline int32_t ConversationReq::conversationtype() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.conversationType)
  return _internal_conversationtype();
}
inline void ConversationReq::_internal_set_conversationtype(int32_t value) {
  
  _impl_.conversationtype_ = value;
}
inline void ConversationReq::set_conversationtype(int32_t value) {
  _internal_set_conversationtype(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.conversationType)
}

// string userID = 3;
inline void ConversationReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& ConversationReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.userID)
}
inline std::string* ConversationReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationReq.userID)
  return _s;
}
inline const std::string& ConversationReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ConversationReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.ConversationReq.userID)
  return _impl_.userid_.Release();
}
inline void ConversationReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationReq.userID)
}

// string groupID = 4;
inline void ConversationReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& ConversationReq::groupid() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.groupID)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationReq::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.groupID)
}
inline std::string* ConversationReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationReq.groupID)
  return _s;
}
inline const std::string& ConversationReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void ConversationReq::_internal_set_groupid(const std::string& value) {
  
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationReq::_internal_mutable_groupid() {
  
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationReq::release_groupid() {
  // @@protoc_insertion_point(field_release:conversation.ConversationReq.groupID)
  return _impl_.groupid_.Release();
}
inline void ConversationReq::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationReq.groupID)
}

// int32 recvMsgOpt = 5;
inline void ConversationReq::clear_recvmsgopt() {
  _impl_.recvmsgopt_ = 0;
}
inline int32_t ConversationReq::_internal_recvmsgopt() const {
  return _impl_.recvmsgopt_;
}
inline int32_t ConversationReq::recvmsgopt() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.recvMsgOpt)
  return _internal_recvmsgopt();
}
inline void ConversationReq::_internal_set_recvmsgopt(int32_t value) {
  
  _impl_.recvmsgopt_ = value;
}
inline void ConversationReq::set_recvmsgopt(int32_t value) {
  _internal_set_recvmsgopt(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.recvMsgOpt)
}

// bool isPinned = 6;
inline void ConversationReq::clear_ispinned() {
  _impl_.ispinned_ = false;
}
inline bool ConversationReq::_internal_ispinned() const {
  return _impl_.ispinned_;
}
inline bool ConversationReq::ispinned() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.isPinned)
  return _internal_ispinned();
}
inline void ConversationReq::_internal_set_ispinned(bool value) {
  
  _impl_.ispinned_ = value;
}
inline void ConversationReq::set_ispinned(bool value) {
  _internal_set_ispinned(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.isPinned)
}

// string attachedInfo = 7;
inline void ConversationReq::clear_attachedinfo() {
  _impl_.attachedinfo_.ClearToEmpty();
}
inline const std::string& ConversationReq::attachedinfo() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.attachedInfo)
  return _internal_attachedinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationReq::set_attachedinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachedinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.attachedInfo)
}
inline std::string* ConversationReq::mutable_attachedinfo() {
  std::string* _s = _internal_mutable_attachedinfo();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationReq.attachedInfo)
  return _s;
}
inline const std::string& ConversationReq::_internal_attachedinfo() const {
  return _impl_.attachedinfo_.Get();
}
inline void ConversationReq::_internal_set_attachedinfo(const std::string& value) {
  
  _impl_.attachedinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationReq::_internal_mutable_attachedinfo() {
  
  return _impl_.attachedinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationReq::release_attachedinfo() {
  // @@protoc_insertion_point(field_release:conversation.ConversationReq.attachedInfo)
  return _impl_.attachedinfo_.Release();
}
inline void ConversationReq::set_allocated_attachedinfo(std::string* attachedinfo) {
  if (attachedinfo != nullptr) {
    
  } else {
    
  }
  _impl_.attachedinfo_.SetAllocated(attachedinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachedinfo_.IsDefault()) {
    _impl_.attachedinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationReq.attachedInfo)
}

// bool isPrivateChat = 8;
inline void ConversationReq::clear_isprivatechat() {
  _impl_.isprivatechat_ = false;
}
inline bool ConversationReq::_internal_isprivatechat() const {
  return _impl_.isprivatechat_;
}
inline bool ConversationReq::isprivatechat() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.isPrivateChat)
  return _internal_isprivatechat();
}
inline void ConversationReq::_internal_set_isprivatechat(bool value) {
  
  _impl_.isprivatechat_ = value;
}
inline void ConversationReq::set_isprivatechat(bool value) {
  _internal_set_isprivatechat(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.isPrivateChat)
}

// string ex = 9;
inline void ConversationReq::clear_ex() {
  _impl_.ex_.ClearToEmpty();
}
inline const std::string& ConversationReq::ex() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.ex)
  return _internal_ex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationReq::set_ex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.ex)
}
inline std::string* ConversationReq::mutable_ex() {
  std::string* _s = _internal_mutable_ex();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationReq.ex)
  return _s;
}
inline const std::string& ConversationReq::_internal_ex() const {
  return _impl_.ex_.Get();
}
inline void ConversationReq::_internal_set_ex(const std::string& value) {
  
  _impl_.ex_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationReq::_internal_mutable_ex() {
  
  return _impl_.ex_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationReq::release_ex() {
  // @@protoc_insertion_point(field_release:conversation.ConversationReq.ex)
  return _impl_.ex_.Release();
}
inline void ConversationReq::set_allocated_ex(std::string* ex) {
  if (ex != nullptr) {
    
  } else {
    
  }
  _impl_.ex_.SetAllocated(ex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ex_.IsDefault()) {
    _impl_.ex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationReq.ex)
}

// int32 burnDuration = 10;
inline void ConversationReq::clear_burnduration() {
  _impl_.burnduration_ = 0;
}
inline int32_t ConversationReq::_internal_burnduration() const {
  return _impl_.burnduration_;
}
inline int32_t ConversationReq::burnduration() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.burnDuration)
  return _internal_burnduration();
}
inline void ConversationReq::_internal_set_burnduration(int32_t value) {
  
  _impl_.burnduration_ = value;
}
inline void ConversationReq::set_burnduration(int32_t value) {
  _internal_set_burnduration(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.burnDuration)
}

// int64 minSeq = 11;
inline void ConversationReq::clear_minseq() {
  _impl_.minseq_ = int64_t{0};
}
inline int64_t ConversationReq::_internal_minseq() const {
  return _impl_.minseq_;
}
inline int64_t ConversationReq::minseq() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.minSeq)
  return _internal_minseq();
}
inline void ConversationReq::_internal_set_minseq(int64_t value) {
  
  _impl_.minseq_ = value;
}
inline void ConversationReq::set_minseq(int64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.minSeq)
}

// int64 maxSeq = 12;
inline void ConversationReq::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t ConversationReq::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t ConversationReq::maxseq() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.maxSeq)
  return _internal_maxseq();
}
inline void ConversationReq::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void ConversationReq::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.maxSeq)
}

// int32 groupAtType = 13;
inline void ConversationReq::clear_groupattype() {
  _impl_.groupattype_ = 0;
}
inline int32_t ConversationReq::_internal_groupattype() const {
  return _impl_.groupattype_;
}
inline int32_t ConversationReq::groupattype() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.groupAtType)
  return _internal_groupattype();
}
inline void ConversationReq::_internal_set_groupattype(int32_t value) {
  
  _impl_.groupattype_ = value;
}
inline void ConversationReq::set_groupattype(int32_t value) {
  _internal_set_groupattype(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.groupAtType)
}

// int64 msgDestructTime = 14;
inline void ConversationReq::clear_msgdestructtime() {
  _impl_.msgdestructtime_ = int64_t{0};
}
inline int64_t ConversationReq::_internal_msgdestructtime() const {
  return _impl_.msgdestructtime_;
}
inline int64_t ConversationReq::msgdestructtime() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.msgDestructTime)
  return _internal_msgdestructtime();
}
inline void ConversationReq::_internal_set_msgdestructtime(int64_t value) {
  
  _impl_.msgdestructtime_ = value;
}
inline void ConversationReq::set_msgdestructtime(int64_t value) {
  _internal_set_msgdestructtime(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.msgDestructTime)
}

// bool isMsgDestruct = 15;
inline void ConversationReq::clear_ismsgdestruct() {
  _impl_.ismsgdestruct_ = false;
}
inline bool ConversationReq::_internal_ismsgdestruct() const {
  return _impl_.ismsgdestruct_;
}
inline bool ConversationReq::ismsgdestruct() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationReq.isMsgDestruct)
  return _internal_ismsgdestruct();
}
inline void ConversationReq::_internal_set_ismsgdestruct(bool value) {
  
  _impl_.ismsgdestruct_ = value;
}
inline void ConversationReq::set_ismsgdestruct(bool value) {
  _internal_set_ismsgdestruct(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationReq.isMsgDestruct)
}

// -------------------------------------------------------------------

// SetConversationReq

// .conversation.Conversation conversation = 1;
inline bool SetConversationReq::_internal_has_conversation() const {
  return this != internal_default_instance() && _impl_.conversation_ != nullptr;
}
inline bool SetConversationReq::has_conversation() const {
  return _internal_has_conversation();
}
inline void SetConversationReq::clear_conversation() {
  if (GetArenaForAllocation() == nullptr && _impl_.conversation_ != nullptr) {
    delete _impl_.conversation_;
  }
  _impl_.conversation_ = nullptr;
}
inline const ::conversation::Conversation& SetConversationReq::_internal_conversation() const {
  const ::conversation::Conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::conversation::Conversation&>(
      ::conversation::_Conversation_default_instance_);
}
inline const ::conversation::Conversation& SetConversationReq::conversation() const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationReq.conversation)
  return _internal_conversation();
}
inline void SetConversationReq::unsafe_arena_set_allocated_conversation(
    ::conversation::Conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:conversation.SetConversationReq.conversation)
}
inline ::conversation::Conversation* SetConversationReq::release_conversation() {
  
  ::conversation::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::conversation::Conversation* SetConversationReq::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:conversation.SetConversationReq.conversation)
  
  ::conversation::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::conversation::Conversation* SetConversationReq::_internal_mutable_conversation() {
  
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::conversation::Conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::conversation::Conversation* SetConversationReq::mutable_conversation() {
  ::conversation::Conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationReq.conversation)
  return _msg;
}
inline void SetConversationReq::set_allocated_conversation(::conversation::Conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:conversation.SetConversationReq.conversation)
}

// -------------------------------------------------------------------

// SetConversationResp

// -------------------------------------------------------------------

// GetConversationReq

// string conversationID = 1;
inline void GetConversationReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& GetConversationReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetConversationReq.conversationID)
}
inline std::string* GetConversationReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationReq.conversationID)
  return _s;
}
inline const std::string& GetConversationReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void GetConversationReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void GetConversationReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationReq.conversationID)
}

// string ownerUserID = 2;
inline void GetConversationReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& GetConversationReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationReq::set_owneruserid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetConversationReq.ownerUserID)
}
inline std::string* GetConversationReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationReq.ownerUserID)
  return _s;
}
inline const std::string& GetConversationReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void GetConversationReq::_internal_set_owneruserid(const std::string& value) {
  
  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationReq::_internal_mutable_owneruserid() {
  
  return _impl_.owneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void GetConversationReq::set_allocated_owneruserid(std::string* owneruserid) {
  if (owneruserid != nullptr) {
    
  } else {
    
  }
  _impl_.owneruserid_.SetAllocated(owneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owneruserid_.IsDefault()) {
    _impl_.owneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationReq.ownerUserID)
}

// -------------------------------------------------------------------

// GetConversationResp

// .conversation.Conversation conversation = 2;
inline bool GetConversationResp::_internal_has_conversation() const {
  return this != internal_default_instance() && _impl_.conversation_ != nullptr;
}
inline bool GetConversationResp::has_conversation() const {
  return _internal_has_conversation();
}
inline void GetConversationResp::clear_conversation() {
  if (GetArenaForAllocation() == nullptr && _impl_.conversation_ != nullptr) {
    delete _impl_.conversation_;
  }
  _impl_.conversation_ = nullptr;
}
inline const ::conversation::Conversation& GetConversationResp::_internal_conversation() const {
  const ::conversation::Conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::conversation::Conversation&>(
      ::conversation::_Conversation_default_instance_);
}
inline const ::conversation::Conversation& GetConversationResp::conversation() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationResp.conversation)
  return _internal_conversation();
}
inline void GetConversationResp::unsafe_arena_set_allocated_conversation(
    ::conversation::Conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:conversation.GetConversationResp.conversation)
}
inline ::conversation::Conversation* GetConversationResp::release_conversation() {
  
  ::conversation::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::conversation::Conversation* GetConversationResp::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationResp.conversation)
  
  ::conversation::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::conversation::Conversation* GetConversationResp::_internal_mutable_conversation() {
  
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::conversation::Conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::conversation::Conversation* GetConversationResp::mutable_conversation() {
  ::conversation::Conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationResp.conversation)
  return _msg;
}
inline void GetConversationResp::set_allocated_conversation(::conversation::Conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationResp.conversation)
}

// -------------------------------------------------------------------

// GetSortedConversationListReq

// string userID = 1;
inline void GetSortedConversationListReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetSortedConversationListReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetSortedConversationListReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSortedConversationListReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetSortedConversationListReq.userID)
}
inline std::string* GetSortedConversationListReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetSortedConversationListReq.userID)
  return _s;
}
inline const std::string& GetSortedConversationListReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetSortedConversationListReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSortedConversationListReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSortedConversationListReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetSortedConversationListReq.userID)
  return _impl_.userid_.Release();
}
inline void GetSortedConversationListReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetSortedConversationListReq.userID)
}

// repeated string conversationIDs = 2;
inline int GetSortedConversationListReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetSortedConversationListReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetSortedConversationListReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetSortedConversationListReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetSortedConversationListReq.conversationIDs)
  return _s;
}
inline const std::string& GetSortedConversationListReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetSortedConversationListReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetSortedConversationListReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetSortedConversationListReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetSortedConversationListReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetSortedConversationListReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetSortedConversationListReq.conversationIDs)
}
inline void GetSortedConversationListReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetSortedConversationListReq.conversationIDs)
}
inline void GetSortedConversationListReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetSortedConversationListReq.conversationIDs)
}
inline void GetSortedConversationListReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetSortedConversationListReq.conversationIDs)
}
inline std::string* GetSortedConversationListReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetSortedConversationListReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetSortedConversationListReq.conversationIDs)
}
inline void GetSortedConversationListReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetSortedConversationListReq.conversationIDs)
}
inline void GetSortedConversationListReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetSortedConversationListReq.conversationIDs)
}
inline void GetSortedConversationListReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetSortedConversationListReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetSortedConversationListReq::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetSortedConversationListReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetSortedConversationListReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetSortedConversationListReq.conversationIDs)
  return &_impl_.conversationids_;
}

// .sdkws.RequestPagination pagination = 3;
inline bool GetSortedConversationListReq::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetSortedConversationListReq::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sdkws::RequestPagination& GetSortedConversationListReq::_internal_pagination() const {
  const ::sdkws::RequestPagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::RequestPagination&>(
      ::sdkws::_RequestPagination_default_instance_);
}
inline const ::sdkws::RequestPagination& GetSortedConversationListReq::pagination() const {
  // @@protoc_insertion_point(field_get:conversation.GetSortedConversationListReq.pagination)
  return _internal_pagination();
}
inline void GetSortedConversationListReq::unsafe_arena_set_allocated_pagination(
    ::sdkws::RequestPagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:conversation.GetSortedConversationListReq.pagination)
}
inline ::sdkws::RequestPagination* GetSortedConversationListReq::release_pagination() {
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::RequestPagination* GetSortedConversationListReq::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:conversation.GetSortedConversationListReq.pagination)
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sdkws::RequestPagination* GetSortedConversationListReq::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::RequestPagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sdkws::RequestPagination* GetSortedConversationListReq::mutable_pagination() {
  ::sdkws::RequestPagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:conversation.GetSortedConversationListReq.pagination)
  return _msg;
}
inline void GetSortedConversationListReq::set_allocated_pagination(::sdkws::RequestPagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:conversation.GetSortedConversationListReq.pagination)
}

// -------------------------------------------------------------------

// GetSortedConversationListResp

// int64 conversationTotal = 1;
inline void GetSortedConversationListResp::clear_conversationtotal() {
  _impl_.conversationtotal_ = int64_t{0};
}
inline int64_t GetSortedConversationListResp::_internal_conversationtotal() const {
  return _impl_.conversationtotal_;
}
inline int64_t GetSortedConversationListResp::conversationtotal() const {
  // @@protoc_insertion_point(field_get:conversation.GetSortedConversationListResp.conversationTotal)
  return _internal_conversationtotal();
}
inline void GetSortedConversationListResp::_internal_set_conversationtotal(int64_t value) {
  
  _impl_.conversationtotal_ = value;
}
inline void GetSortedConversationListResp::set_conversationtotal(int64_t value) {
  _internal_set_conversationtotal(value);
  // @@protoc_insertion_point(field_set:conversation.GetSortedConversationListResp.conversationTotal)
}

// int64 unreadTotal = 2;
inline void GetSortedConversationListResp::clear_unreadtotal() {
  _impl_.unreadtotal_ = int64_t{0};
}
inline int64_t GetSortedConversationListResp::_internal_unreadtotal() const {
  return _impl_.unreadtotal_;
}
inline int64_t GetSortedConversationListResp::unreadtotal() const {
  // @@protoc_insertion_point(field_get:conversation.GetSortedConversationListResp.unreadTotal)
  return _internal_unreadtotal();
}
inline void GetSortedConversationListResp::_internal_set_unreadtotal(int64_t value) {
  
  _impl_.unreadtotal_ = value;
}
inline void GetSortedConversationListResp::set_unreadtotal(int64_t value) {
  _internal_set_unreadtotal(value);
  // @@protoc_insertion_point(field_set:conversation.GetSortedConversationListResp.unreadTotal)
}

// repeated .conversation.ConversationElem conversationElems = 3;
inline int GetSortedConversationListResp::_internal_conversationelems_size() const {
  return _impl_.conversationelems_.size();
}
inline int GetSortedConversationListResp::conversationelems_size() const {
  return _internal_conversationelems_size();
}
inline void GetSortedConversationListResp::clear_conversationelems() {
  _impl_.conversationelems_.Clear();
}
inline ::conversation::ConversationElem* GetSortedConversationListResp::mutable_conversationelems(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetSortedConversationListResp.conversationElems)
  return _impl_.conversationelems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::ConversationElem >*
GetSortedConversationListResp::mutable_conversationelems() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetSortedConversationListResp.conversationElems)
  return &_impl_.conversationelems_;
}
inline const ::conversation::ConversationElem& GetSortedConversationListResp::_internal_conversationelems(int index) const {
  return _impl_.conversationelems_.Get(index);
}
inline const ::conversation::ConversationElem& GetSortedConversationListResp::conversationelems(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetSortedConversationListResp.conversationElems)
  return _internal_conversationelems(index);
}
inline ::conversation::ConversationElem* GetSortedConversationListResp::_internal_add_conversationelems() {
  return _impl_.conversationelems_.Add();
}
inline ::conversation::ConversationElem* GetSortedConversationListResp::add_conversationelems() {
  ::conversation::ConversationElem* _add = _internal_add_conversationelems();
  // @@protoc_insertion_point(field_add:conversation.GetSortedConversationListResp.conversationElems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::ConversationElem >&
GetSortedConversationListResp::conversationelems() const {
  // @@protoc_insertion_point(field_list:conversation.GetSortedConversationListResp.conversationElems)
  return _impl_.conversationelems_;
}

// -------------------------------------------------------------------

// ConversationElem

// string conversationID = 1;
inline void ConversationElem::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& ConversationElem::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationElem.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationElem::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.ConversationElem.conversationID)
}
inline std::string* ConversationElem::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationElem.conversationID)
  return _s;
}
inline const std::string& ConversationElem::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void ConversationElem::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationElem::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationElem::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.ConversationElem.conversationID)
  return _impl_.conversationid_.Release();
}
inline void ConversationElem::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationElem.conversationID)
}

// int32 recvMsgOpt = 2;
inline void ConversationElem::clear_recvmsgopt() {
  _impl_.recvmsgopt_ = 0;
}
inline int32_t ConversationElem::_internal_recvmsgopt() const {
  return _impl_.recvmsgopt_;
}
inline int32_t ConversationElem::recvmsgopt() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationElem.recvMsgOpt)
  return _internal_recvmsgopt();
}
inline void ConversationElem::_internal_set_recvmsgopt(int32_t value) {
  
  _impl_.recvmsgopt_ = value;
}
inline void ConversationElem::set_recvmsgopt(int32_t value) {
  _internal_set_recvmsgopt(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationElem.recvMsgOpt)
}

// int64 unreadCount = 3;
inline void ConversationElem::clear_unreadcount() {
  _impl_.unreadcount_ = int64_t{0};
}
inline int64_t ConversationElem::_internal_unreadcount() const {
  return _impl_.unreadcount_;
}
inline int64_t ConversationElem::unreadcount() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationElem.unreadCount)
  return _internal_unreadcount();
}
inline void ConversationElem::_internal_set_unreadcount(int64_t value) {
  
  _impl_.unreadcount_ = value;
}
inline void ConversationElem::set_unreadcount(int64_t value) {
  _internal_set_unreadcount(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationElem.unreadCount)
}

// bool IsPinned = 4;
inline void ConversationElem::clear_ispinned() {
  _impl_.ispinned_ = false;
}
inline bool ConversationElem::_internal_ispinned() const {
  return _impl_.ispinned_;
}
inline bool ConversationElem::ispinned() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationElem.IsPinned)
  return _internal_ispinned();
}
inline void ConversationElem::_internal_set_ispinned(bool value) {
  
  _impl_.ispinned_ = value;
}
inline void ConversationElem::set_ispinned(bool value) {
  _internal_set_ispinned(value);
  // @@protoc_insertion_point(field_set:conversation.ConversationElem.IsPinned)
}

// .conversation.MsgInfo msgInfo = 5;
inline bool ConversationElem::_internal_has_msginfo() const {
  return this != internal_default_instance() && _impl_.msginfo_ != nullptr;
}
inline bool ConversationElem::has_msginfo() const {
  return _internal_has_msginfo();
}
inline void ConversationElem::clear_msginfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.msginfo_ != nullptr) {
    delete _impl_.msginfo_;
  }
  _impl_.msginfo_ = nullptr;
}
inline const ::conversation::MsgInfo& ConversationElem::_internal_msginfo() const {
  const ::conversation::MsgInfo* p = _impl_.msginfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::conversation::MsgInfo&>(
      ::conversation::_MsgInfo_default_instance_);
}
inline const ::conversation::MsgInfo& ConversationElem::msginfo() const {
  // @@protoc_insertion_point(field_get:conversation.ConversationElem.msgInfo)
  return _internal_msginfo();
}
inline void ConversationElem::unsafe_arena_set_allocated_msginfo(
    ::conversation::MsgInfo* msginfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msginfo_);
  }
  _impl_.msginfo_ = msginfo;
  if (msginfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:conversation.ConversationElem.msgInfo)
}
inline ::conversation::MsgInfo* ConversationElem::release_msginfo() {
  
  ::conversation::MsgInfo* temp = _impl_.msginfo_;
  _impl_.msginfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::conversation::MsgInfo* ConversationElem::unsafe_arena_release_msginfo() {
  // @@protoc_insertion_point(field_release:conversation.ConversationElem.msgInfo)
  
  ::conversation::MsgInfo* temp = _impl_.msginfo_;
  _impl_.msginfo_ = nullptr;
  return temp;
}
inline ::conversation::MsgInfo* ConversationElem::_internal_mutable_msginfo() {
  
  if (_impl_.msginfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::conversation::MsgInfo>(GetArenaForAllocation());
    _impl_.msginfo_ = p;
  }
  return _impl_.msginfo_;
}
inline ::conversation::MsgInfo* ConversationElem::mutable_msginfo() {
  ::conversation::MsgInfo* _msg = _internal_mutable_msginfo();
  // @@protoc_insertion_point(field_mutable:conversation.ConversationElem.msgInfo)
  return _msg;
}
inline void ConversationElem::set_allocated_msginfo(::conversation::MsgInfo* msginfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msginfo_;
  }
  if (msginfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msginfo);
    if (message_arena != submessage_arena) {
      msginfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msginfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msginfo_ = msginfo;
  // @@protoc_insertion_point(field_set_allocated:conversation.ConversationElem.msgInfo)
}

// -------------------------------------------------------------------

// MsgInfo

// string serverMsgID = 1;
inline void MsgInfo::clear_servermsgid() {
  _impl_.servermsgid_.ClearToEmpty();
}
inline const std::string& MsgInfo::servermsgid() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.serverMsgID)
  return _internal_servermsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_servermsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servermsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.serverMsgID)
}
inline std::string* MsgInfo::mutable_servermsgid() {
  std::string* _s = _internal_mutable_servermsgid();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.serverMsgID)
  return _s;
}
inline const std::string& MsgInfo::_internal_servermsgid() const {
  return _impl_.servermsgid_.Get();
}
inline void MsgInfo::_internal_set_servermsgid(const std::string& value) {
  
  _impl_.servermsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_servermsgid() {
  
  return _impl_.servermsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_servermsgid() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.serverMsgID)
  return _impl_.servermsgid_.Release();
}
inline void MsgInfo::set_allocated_servermsgid(std::string* servermsgid) {
  if (servermsgid != nullptr) {
    
  } else {
    
  }
  _impl_.servermsgid_.SetAllocated(servermsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servermsgid_.IsDefault()) {
    _impl_.servermsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.serverMsgID)
}

// string clientMsgID = 2;
inline void MsgInfo::clear_clientmsgid() {
  _impl_.clientmsgid_.ClearToEmpty();
}
inline const std::string& MsgInfo::clientmsgid() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.clientMsgID)
  return _internal_clientmsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_clientmsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientmsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.clientMsgID)
}
inline std::string* MsgInfo::mutable_clientmsgid() {
  std::string* _s = _internal_mutable_clientmsgid();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.clientMsgID)
  return _s;
}
inline const std::string& MsgInfo::_internal_clientmsgid() const {
  return _impl_.clientmsgid_.Get();
}
inline void MsgInfo::_internal_set_clientmsgid(const std::string& value) {
  
  _impl_.clientmsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_clientmsgid() {
  
  return _impl_.clientmsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_clientmsgid() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.clientMsgID)
  return _impl_.clientmsgid_.Release();
}
inline void MsgInfo::set_allocated_clientmsgid(std::string* clientmsgid) {
  if (clientmsgid != nullptr) {
    
  } else {
    
  }
  _impl_.clientmsgid_.SetAllocated(clientmsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientmsgid_.IsDefault()) {
    _impl_.clientmsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.clientMsgID)
}

// int32 sessionType = 3;
inline void MsgInfo::clear_sessiontype() {
  _impl_.sessiontype_ = 0;
}
inline int32_t MsgInfo::_internal_sessiontype() const {
  return _impl_.sessiontype_;
}
inline int32_t MsgInfo::sessiontype() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.sessionType)
  return _internal_sessiontype();
}
inline void MsgInfo::_internal_set_sessiontype(int32_t value) {
  
  _impl_.sessiontype_ = value;
}
inline void MsgInfo::set_sessiontype(int32_t value) {
  _internal_set_sessiontype(value);
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.sessionType)
}

// string sendID = 4;
inline void MsgInfo::clear_sendid() {
  _impl_.sendid_.ClearToEmpty();
}
inline const std::string& MsgInfo::sendid() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.sendID)
  return _internal_sendid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_sendid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.sendID)
}
inline std::string* MsgInfo::mutable_sendid() {
  std::string* _s = _internal_mutable_sendid();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.sendID)
  return _s;
}
inline const std::string& MsgInfo::_internal_sendid() const {
  return _impl_.sendid_.Get();
}
inline void MsgInfo::_internal_set_sendid(const std::string& value) {
  
  _impl_.sendid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_sendid() {
  
  return _impl_.sendid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_sendid() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.sendID)
  return _impl_.sendid_.Release();
}
inline void MsgInfo::set_allocated_sendid(std::string* sendid) {
  if (sendid != nullptr) {
    
  } else {
    
  }
  _impl_.sendid_.SetAllocated(sendid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendid_.IsDefault()) {
    _impl_.sendid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.sendID)
}

// string recvID = 5;
inline void MsgInfo::clear_recvid() {
  _impl_.recvid_.ClearToEmpty();
}
inline const std::string& MsgInfo::recvid() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.recvID)
  return _internal_recvid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_recvid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recvid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.recvID)
}
inline std::string* MsgInfo::mutable_recvid() {
  std::string* _s = _internal_mutable_recvid();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.recvID)
  return _s;
}
inline const std::string& MsgInfo::_internal_recvid() const {
  return _impl_.recvid_.Get();
}
inline void MsgInfo::_internal_set_recvid(const std::string& value) {
  
  _impl_.recvid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_recvid() {
  
  return _impl_.recvid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_recvid() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.recvID)
  return _impl_.recvid_.Release();
}
inline void MsgInfo::set_allocated_recvid(std::string* recvid) {
  if (recvid != nullptr) {
    
  } else {
    
  }
  _impl_.recvid_.SetAllocated(recvid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recvid_.IsDefault()) {
    _impl_.recvid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.recvID)
}

// string senderName = 6;
inline void MsgInfo::clear_sendername() {
  _impl_.sendername_.ClearToEmpty();
}
inline const std::string& MsgInfo::sendername() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.senderName)
  return _internal_sendername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_sendername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.senderName)
}
inline std::string* MsgInfo::mutable_sendername() {
  std::string* _s = _internal_mutable_sendername();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.senderName)
  return _s;
}
inline const std::string& MsgInfo::_internal_sendername() const {
  return _impl_.sendername_.Get();
}
inline void MsgInfo::_internal_set_sendername(const std::string& value) {
  
  _impl_.sendername_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_sendername() {
  
  return _impl_.sendername_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_sendername() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.senderName)
  return _impl_.sendername_.Release();
}
inline void MsgInfo::set_allocated_sendername(std::string* sendername) {
  if (sendername != nullptr) {
    
  } else {
    
  }
  _impl_.sendername_.SetAllocated(sendername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendername_.IsDefault()) {
    _impl_.sendername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.senderName)
}

// string faceURL = 7;
inline void MsgInfo::clear_faceurl() {
  _impl_.faceurl_.ClearToEmpty();
}
inline const std::string& MsgInfo::faceurl() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.faceURL)
  return _internal_faceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_faceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.faceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.faceURL)
}
inline std::string* MsgInfo::mutable_faceurl() {
  std::string* _s = _internal_mutable_faceurl();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.faceURL)
  return _s;
}
inline const std::string& MsgInfo::_internal_faceurl() const {
  return _impl_.faceurl_.Get();
}
inline void MsgInfo::_internal_set_faceurl(const std::string& value) {
  
  _impl_.faceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_faceurl() {
  
  return _impl_.faceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_faceurl() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.faceURL)
  return _impl_.faceurl_.Release();
}
inline void MsgInfo::set_allocated_faceurl(std::string* faceurl) {
  if (faceurl != nullptr) {
    
  } else {
    
  }
  _impl_.faceurl_.SetAllocated(faceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.faceurl_.IsDefault()) {
    _impl_.faceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.faceURL)
}

// string groupID = 8;
inline void MsgInfo::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& MsgInfo::groupid() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.groupID)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.groupID)
}
inline std::string* MsgInfo::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.groupID)
  return _s;
}
inline const std::string& MsgInfo::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void MsgInfo::_internal_set_groupid(const std::string& value) {
  
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_groupid() {
  
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_groupid() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.groupID)
  return _impl_.groupid_.Release();
}
inline void MsgInfo::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.groupID)
}

// string groupName = 9;
inline void MsgInfo::clear_groupname() {
  _impl_.groupname_.ClearToEmpty();
}
inline const std::string& MsgInfo::groupname() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.groupName)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_groupname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.groupName)
}
inline std::string* MsgInfo::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.groupName)
  return _s;
}
inline const std::string& MsgInfo::_internal_groupname() const {
  return _impl_.groupname_.Get();
}
inline void MsgInfo::_internal_set_groupname(const std::string& value) {
  
  _impl_.groupname_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_groupname() {
  
  return _impl_.groupname_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_groupname() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.groupName)
  return _impl_.groupname_.Release();
}
inline void MsgInfo::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    
  } else {
    
  }
  _impl_.groupname_.SetAllocated(groupname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupname_.IsDefault()) {
    _impl_.groupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.groupName)
}

// string groupFaceURL = 10;
inline void MsgInfo::clear_groupfaceurl() {
  _impl_.groupfaceurl_.ClearToEmpty();
}
inline const std::string& MsgInfo::groupfaceurl() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.groupFaceURL)
  return _internal_groupfaceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_groupfaceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupfaceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.groupFaceURL)
}
inline std::string* MsgInfo::mutable_groupfaceurl() {
  std::string* _s = _internal_mutable_groupfaceurl();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.groupFaceURL)
  return _s;
}
inline const std::string& MsgInfo::_internal_groupfaceurl() const {
  return _impl_.groupfaceurl_.Get();
}
inline void MsgInfo::_internal_set_groupfaceurl(const std::string& value) {
  
  _impl_.groupfaceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_groupfaceurl() {
  
  return _impl_.groupfaceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_groupfaceurl() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.groupFaceURL)
  return _impl_.groupfaceurl_.Release();
}
inline void MsgInfo::set_allocated_groupfaceurl(std::string* groupfaceurl) {
  if (groupfaceurl != nullptr) {
    
  } else {
    
  }
  _impl_.groupfaceurl_.SetAllocated(groupfaceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupfaceurl_.IsDefault()) {
    _impl_.groupfaceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.groupFaceURL)
}

// int32 groupType = 11;
inline void MsgInfo::clear_grouptype() {
  _impl_.grouptype_ = 0;
}
inline int32_t MsgInfo::_internal_grouptype() const {
  return _impl_.grouptype_;
}
inline int32_t MsgInfo::grouptype() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.groupType)
  return _internal_grouptype();
}
inline void MsgInfo::_internal_set_grouptype(int32_t value) {
  
  _impl_.grouptype_ = value;
}
inline void MsgInfo::set_grouptype(int32_t value) {
  _internal_set_grouptype(value);
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.groupType)
}

// uint32 groupMemberCount = 12;
inline void MsgInfo::clear_groupmembercount() {
  _impl_.groupmembercount_ = 0u;
}
inline uint32_t MsgInfo::_internal_groupmembercount() const {
  return _impl_.groupmembercount_;
}
inline uint32_t MsgInfo::groupmembercount() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.groupMemberCount)
  return _internal_groupmembercount();
}
inline void MsgInfo::_internal_set_groupmembercount(uint32_t value) {
  
  _impl_.groupmembercount_ = value;
}
inline void MsgInfo::set_groupmembercount(uint32_t value) {
  _internal_set_groupmembercount(value);
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.groupMemberCount)
}

// int64 LatestMsgRecvTime = 13;
inline void MsgInfo::clear_latestmsgrecvtime() {
  _impl_.latestmsgrecvtime_ = int64_t{0};
}
inline int64_t MsgInfo::_internal_latestmsgrecvtime() const {
  return _impl_.latestmsgrecvtime_;
}
inline int64_t MsgInfo::latestmsgrecvtime() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.LatestMsgRecvTime)
  return _internal_latestmsgrecvtime();
}
inline void MsgInfo::_internal_set_latestmsgrecvtime(int64_t value) {
  
  _impl_.latestmsgrecvtime_ = value;
}
inline void MsgInfo::set_latestmsgrecvtime(int64_t value) {
  _internal_set_latestmsgrecvtime(value);
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.LatestMsgRecvTime)
}

// int32 msgFrom = 14;
inline void MsgInfo::clear_msgfrom() {
  _impl_.msgfrom_ = 0;
}
inline int32_t MsgInfo::_internal_msgfrom() const {
  return _impl_.msgfrom_;
}
inline int32_t MsgInfo::msgfrom() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.msgFrom)
  return _internal_msgfrom();
}
inline void MsgInfo::_internal_set_msgfrom(int32_t value) {
  
  _impl_.msgfrom_ = value;
}
inline void MsgInfo::set_msgfrom(int32_t value) {
  _internal_set_msgfrom(value);
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.msgFrom)
}

// int32 contentType = 15;
inline void MsgInfo::clear_contenttype() {
  _impl_.contenttype_ = 0;
}
inline int32_t MsgInfo::_internal_contenttype() const {
  return _impl_.contenttype_;
}
inline int32_t MsgInfo::contenttype() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.contentType)
  return _internal_contenttype();
}
inline void MsgInfo::_internal_set_contenttype(int32_t value) {
  
  _impl_.contenttype_ = value;
}
inline void MsgInfo::set_contenttype(int32_t value) {
  _internal_set_contenttype(value);
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.contentType)
}

// string content = 16;
inline void MsgInfo::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& MsgInfo::content() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.content)
}
inline std::string* MsgInfo::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.content)
  return _s;
}
inline const std::string& MsgInfo::_internal_content() const {
  return _impl_.content_.Get();
}
inline void MsgInfo::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_content() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.content)
  return _impl_.content_.Release();
}
inline void MsgInfo::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.content)
}

// string ex = 17;
inline void MsgInfo::clear_ex() {
  _impl_.ex_.ClearToEmpty();
}
inline const std::string& MsgInfo::ex() const {
  // @@protoc_insertion_point(field_get:conversation.MsgInfo.ex)
  return _internal_ex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_ex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.MsgInfo.ex)
}
inline std::string* MsgInfo::mutable_ex() {
  std::string* _s = _internal_mutable_ex();
  // @@protoc_insertion_point(field_mutable:conversation.MsgInfo.ex)
  return _s;
}
inline const std::string& MsgInfo::_internal_ex() const {
  return _impl_.ex_.Get();
}
inline void MsgInfo::_internal_set_ex(const std::string& value) {
  
  _impl_.ex_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_ex() {
  
  return _impl_.ex_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_ex() {
  // @@protoc_insertion_point(field_release:conversation.MsgInfo.ex)
  return _impl_.ex_.Release();
}
inline void MsgInfo::set_allocated_ex(std::string* ex) {
  if (ex != nullptr) {
    
  } else {
    
  }
  _impl_.ex_.SetAllocated(ex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ex_.IsDefault()) {
    _impl_.ex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.MsgInfo.ex)
}

// -------------------------------------------------------------------

// GetConversationsReq

// string ownerUserID = 1;
inline void GetConversationsReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& GetConversationsReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationsReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationsReq::set_owneruserid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetConversationsReq.ownerUserID)
}
inline std::string* GetConversationsReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationsReq.ownerUserID)
  return _s;
}
inline const std::string& GetConversationsReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void GetConversationsReq::_internal_set_owneruserid(const std::string& value) {
  
  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationsReq::_internal_mutable_owneruserid() {
  
  return _impl_.owneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationsReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationsReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void GetConversationsReq::set_allocated_owneruserid(std::string* owneruserid) {
  if (owneruserid != nullptr) {
    
  } else {
    
  }
  _impl_.owneruserid_.SetAllocated(owneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owneruserid_.IsDefault()) {
    _impl_.owneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationsReq.ownerUserID)
}

// repeated string conversationIDs = 2;
inline int GetConversationsReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetConversationsReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetConversationsReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetConversationsReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetConversationsReq.conversationIDs)
  return _s;
}
inline const std::string& GetConversationsReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetConversationsReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationsReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetConversationsReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationsReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetConversationsReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetConversationsReq.conversationIDs)
}
inline void GetConversationsReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetConversationsReq.conversationIDs)
}
inline void GetConversationsReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetConversationsReq.conversationIDs)
}
inline void GetConversationsReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetConversationsReq.conversationIDs)
}
inline std::string* GetConversationsReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetConversationsReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetConversationsReq.conversationIDs)
}
inline void GetConversationsReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetConversationsReq.conversationIDs)
}
inline void GetConversationsReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetConversationsReq.conversationIDs)
}
inline void GetConversationsReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetConversationsReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationsReq::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationsReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationsReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationsReq.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// GetConversationsResp

// repeated .conversation.Conversation conversations = 2;
inline int GetConversationsResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetConversationsResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetConversationsResp::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::conversation::Conversation* GetConversationsResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationsResp.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetConversationsResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationsResp.conversations)
  return &_impl_.conversations_;
}
inline const ::conversation::Conversation& GetConversationsResp::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::conversation::Conversation& GetConversationsResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationsResp.conversations)
  return _internal_conversations(index);
}
inline ::conversation::Conversation* GetConversationsResp::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::conversation::Conversation* GetConversationsResp::add_conversations() {
  ::conversation::Conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:conversation.GetConversationsResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetConversationsResp::conversations() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationsResp.conversations)
  return _impl_.conversations_;
}

// -------------------------------------------------------------------

// GetAllConversationsReq

// string ownerUserID = 1;
inline void GetAllConversationsReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& GetAllConversationsReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:conversation.GetAllConversationsReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllConversationsReq::set_owneruserid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetAllConversationsReq.ownerUserID)
}
inline std::string* GetAllConversationsReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:conversation.GetAllConversationsReq.ownerUserID)
  return _s;
}
inline const std::string& GetAllConversationsReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void GetAllConversationsReq::_internal_set_owneruserid(const std::string& value) {
  
  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllConversationsReq::_internal_mutable_owneruserid() {
  
  return _impl_.owneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllConversationsReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:conversation.GetAllConversationsReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void GetAllConversationsReq::set_allocated_owneruserid(std::string* owneruserid) {
  if (owneruserid != nullptr) {
    
  } else {
    
  }
  _impl_.owneruserid_.SetAllocated(owneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owneruserid_.IsDefault()) {
    _impl_.owneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetAllConversationsReq.ownerUserID)
}

// -------------------------------------------------------------------

// GetAllConversationsResp

// repeated .conversation.Conversation conversations = 2;
inline int GetAllConversationsResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetAllConversationsResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetAllConversationsResp::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::conversation::Conversation* GetAllConversationsResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetAllConversationsResp.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetAllConversationsResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetAllConversationsResp.conversations)
  return &_impl_.conversations_;
}
inline const ::conversation::Conversation& GetAllConversationsResp::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::conversation::Conversation& GetAllConversationsResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetAllConversationsResp.conversations)
  return _internal_conversations(index);
}
inline ::conversation::Conversation* GetAllConversationsResp::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::conversation::Conversation* GetAllConversationsResp::add_conversations() {
  ::conversation::Conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:conversation.GetAllConversationsResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetAllConversationsResp::conversations() const {
  // @@protoc_insertion_point(field_list:conversation.GetAllConversationsResp.conversations)
  return _impl_.conversations_;
}

// -------------------------------------------------------------------

// GetRecvMsgNotNotifyUserIDsReq

// string groupID = 1;
inline void GetRecvMsgNotNotifyUserIDsReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& GetRecvMsgNotNotifyUserIDsReq::groupid() const {
  // @@protoc_insertion_point(field_get:conversation.GetRecvMsgNotNotifyUserIDsReq.groupID)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRecvMsgNotNotifyUserIDsReq::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetRecvMsgNotNotifyUserIDsReq.groupID)
}
inline std::string* GetRecvMsgNotNotifyUserIDsReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:conversation.GetRecvMsgNotNotifyUserIDsReq.groupID)
  return _s;
}
inline const std::string& GetRecvMsgNotNotifyUserIDsReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void GetRecvMsgNotNotifyUserIDsReq::_internal_set_groupid(const std::string& value) {
  
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRecvMsgNotNotifyUserIDsReq::_internal_mutable_groupid() {
  
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRecvMsgNotNotifyUserIDsReq::release_groupid() {
  // @@protoc_insertion_point(field_release:conversation.GetRecvMsgNotNotifyUserIDsReq.groupID)
  return _impl_.groupid_.Release();
}
inline void GetRecvMsgNotNotifyUserIDsReq::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetRecvMsgNotNotifyUserIDsReq.groupID)
}

// -------------------------------------------------------------------

// GetRecvMsgNotNotifyUserIDsResp

// repeated string userIDs = 1;
inline int GetRecvMsgNotNotifyUserIDsResp::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int GetRecvMsgNotNotifyUserIDsResp::userids_size() const {
  return _internal_userids_size();
}
inline void GetRecvMsgNotNotifyUserIDsResp::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* GetRecvMsgNotNotifyUserIDsResp::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
  return _s;
}
inline const std::string& GetRecvMsgNotNotifyUserIDsResp::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& GetRecvMsgNotNotifyUserIDsResp::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
  return _internal_userids(index);
}
inline std::string* GetRecvMsgNotNotifyUserIDsResp::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void GetRecvMsgNotNotifyUserIDsResp::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline void GetRecvMsgNotNotifyUserIDsResp::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline void GetRecvMsgNotNotifyUserIDsResp::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline void GetRecvMsgNotNotifyUserIDsResp::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline std::string* GetRecvMsgNotNotifyUserIDsResp::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void GetRecvMsgNotNotifyUserIDsResp::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline void GetRecvMsgNotNotifyUserIDsResp::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline void GetRecvMsgNotNotifyUserIDsResp::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline void GetRecvMsgNotNotifyUserIDsResp::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetRecvMsgNotNotifyUserIDsResp::userids() const {
  // @@protoc_insertion_point(field_list:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetRecvMsgNotNotifyUserIDsResp::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetRecvMsgNotNotifyUserIDsResp.userIDs)
  return &_impl_.userids_;
}

// -------------------------------------------------------------------

// CreateSingleChatConversationsReq

// string recvID = 1;
inline void CreateSingleChatConversationsReq::clear_recvid() {
  _impl_.recvid_.ClearToEmpty();
}
inline const std::string& CreateSingleChatConversationsReq::recvid() const {
  // @@protoc_insertion_point(field_get:conversation.CreateSingleChatConversationsReq.recvID)
  return _internal_recvid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSingleChatConversationsReq::set_recvid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recvid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.CreateSingleChatConversationsReq.recvID)
}
inline std::string* CreateSingleChatConversationsReq::mutable_recvid() {
  std::string* _s = _internal_mutable_recvid();
  // @@protoc_insertion_point(field_mutable:conversation.CreateSingleChatConversationsReq.recvID)
  return _s;
}
inline const std::string& CreateSingleChatConversationsReq::_internal_recvid() const {
  return _impl_.recvid_.Get();
}
inline void CreateSingleChatConversationsReq::_internal_set_recvid(const std::string& value) {
  
  _impl_.recvid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSingleChatConversationsReq::_internal_mutable_recvid() {
  
  return _impl_.recvid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSingleChatConversationsReq::release_recvid() {
  // @@protoc_insertion_point(field_release:conversation.CreateSingleChatConversationsReq.recvID)
  return _impl_.recvid_.Release();
}
inline void CreateSingleChatConversationsReq::set_allocated_recvid(std::string* recvid) {
  if (recvid != nullptr) {
    
  } else {
    
  }
  _impl_.recvid_.SetAllocated(recvid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recvid_.IsDefault()) {
    _impl_.recvid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.CreateSingleChatConversationsReq.recvID)
}

// string sendID = 2;
inline void CreateSingleChatConversationsReq::clear_sendid() {
  _impl_.sendid_.ClearToEmpty();
}
inline const std::string& CreateSingleChatConversationsReq::sendid() const {
  // @@protoc_insertion_point(field_get:conversation.CreateSingleChatConversationsReq.sendID)
  return _internal_sendid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSingleChatConversationsReq::set_sendid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.CreateSingleChatConversationsReq.sendID)
}
inline std::string* CreateSingleChatConversationsReq::mutable_sendid() {
  std::string* _s = _internal_mutable_sendid();
  // @@protoc_insertion_point(field_mutable:conversation.CreateSingleChatConversationsReq.sendID)
  return _s;
}
inline const std::string& CreateSingleChatConversationsReq::_internal_sendid() const {
  return _impl_.sendid_.Get();
}
inline void CreateSingleChatConversationsReq::_internal_set_sendid(const std::string& value) {
  
  _impl_.sendid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSingleChatConversationsReq::_internal_mutable_sendid() {
  
  return _impl_.sendid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSingleChatConversationsReq::release_sendid() {
  // @@protoc_insertion_point(field_release:conversation.CreateSingleChatConversationsReq.sendID)
  return _impl_.sendid_.Release();
}
inline void CreateSingleChatConversationsReq::set_allocated_sendid(std::string* sendid) {
  if (sendid != nullptr) {
    
  } else {
    
  }
  _impl_.sendid_.SetAllocated(sendid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendid_.IsDefault()) {
    _impl_.sendid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.CreateSingleChatConversationsReq.sendID)
}

// string conversationID = 3;
inline void CreateSingleChatConversationsReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& CreateSingleChatConversationsReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.CreateSingleChatConversationsReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSingleChatConversationsReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.CreateSingleChatConversationsReq.conversationID)
}
inline std::string* CreateSingleChatConversationsReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.CreateSingleChatConversationsReq.conversationID)
  return _s;
}
inline const std::string& CreateSingleChatConversationsReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void CreateSingleChatConversationsReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSingleChatConversationsReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSingleChatConversationsReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.CreateSingleChatConversationsReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void CreateSingleChatConversationsReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.CreateSingleChatConversationsReq.conversationID)
}

// int32 conversationType = 4;
inline void CreateSingleChatConversationsReq::clear_conversationtype() {
  _impl_.conversationtype_ = 0;
}
inline int32_t CreateSingleChatConversationsReq::_internal_conversationtype() const {
  return _impl_.conversationtype_;
}
inline int32_t CreateSingleChatConversationsReq::conversationtype() const {
  // @@protoc_insertion_point(field_get:conversation.CreateSingleChatConversationsReq.conversationType)
  return _internal_conversationtype();
}
inline void CreateSingleChatConversationsReq::_internal_set_conversationtype(int32_t value) {
  
  _impl_.conversationtype_ = value;
}
inline void CreateSingleChatConversationsReq::set_conversationtype(int32_t value) {
  _internal_set_conversationtype(value);
  // @@protoc_insertion_point(field_set:conversation.CreateSingleChatConversationsReq.conversationType)
}

// -------------------------------------------------------------------

// CreateSingleChatConversationsResp

// -------------------------------------------------------------------

// CreateGroupChatConversationsReq

// repeated string userIDs = 1;
inline int CreateGroupChatConversationsReq::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int CreateGroupChatConversationsReq::userids_size() const {
  return _internal_userids_size();
}
inline void CreateGroupChatConversationsReq::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* CreateGroupChatConversationsReq::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.CreateGroupChatConversationsReq.userIDs)
  return _s;
}
inline const std::string& CreateGroupChatConversationsReq::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& CreateGroupChatConversationsReq::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.CreateGroupChatConversationsReq.userIDs)
  return _internal_userids(index);
}
inline std::string* CreateGroupChatConversationsReq::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.CreateGroupChatConversationsReq.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void CreateGroupChatConversationsReq::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline void CreateGroupChatConversationsReq::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline void CreateGroupChatConversationsReq::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline void CreateGroupChatConversationsReq::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline std::string* CreateGroupChatConversationsReq::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void CreateGroupChatConversationsReq::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline void CreateGroupChatConversationsReq::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline void CreateGroupChatConversationsReq::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline void CreateGroupChatConversationsReq::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.CreateGroupChatConversationsReq.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateGroupChatConversationsReq::userids() const {
  // @@protoc_insertion_point(field_list:conversation.CreateGroupChatConversationsReq.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateGroupChatConversationsReq::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.CreateGroupChatConversationsReq.userIDs)
  return &_impl_.userids_;
}

// string groupID = 2;
inline void CreateGroupChatConversationsReq::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& CreateGroupChatConversationsReq::groupid() const {
  // @@protoc_insertion_point(field_get:conversation.CreateGroupChatConversationsReq.groupID)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupChatConversationsReq::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.CreateGroupChatConversationsReq.groupID)
}
inline std::string* CreateGroupChatConversationsReq::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:conversation.CreateGroupChatConversationsReq.groupID)
  return _s;
}
inline const std::string& CreateGroupChatConversationsReq::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void CreateGroupChatConversationsReq::_internal_set_groupid(const std::string& value) {
  
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGroupChatConversationsReq::_internal_mutable_groupid() {
  
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGroupChatConversationsReq::release_groupid() {
  // @@protoc_insertion_point(field_release:conversation.CreateGroupChatConversationsReq.groupID)
  return _impl_.groupid_.Release();
}
inline void CreateGroupChatConversationsReq::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.CreateGroupChatConversationsReq.groupID)
}

// -------------------------------------------------------------------

// CreateGroupChatConversationsResp

// -------------------------------------------------------------------

// SetConversationMaxSeqReq

// string conversationID = 1;
inline void SetConversationMaxSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& SetConversationMaxSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationMaxSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetConversationMaxSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.SetConversationMaxSeqReq.conversationID)
}
inline std::string* SetConversationMaxSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationMaxSeqReq.conversationID)
  return _s;
}
inline const std::string& SetConversationMaxSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void SetConversationMaxSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetConversationMaxSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetConversationMaxSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.SetConversationMaxSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void SetConversationMaxSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.SetConversationMaxSeqReq.conversationID)
}

// repeated string ownerUserID = 2;
inline int SetConversationMaxSeqReq::_internal_owneruserid_size() const {
  return _impl_.owneruserid_.size();
}
inline int SetConversationMaxSeqReq::owneruserid_size() const {
  return _internal_owneruserid_size();
}
inline void SetConversationMaxSeqReq::clear_owneruserid() {
  _impl_.owneruserid_.Clear();
}
inline std::string* SetConversationMaxSeqReq::add_owneruserid() {
  std::string* _s = _internal_add_owneruserid();
  // @@protoc_insertion_point(field_add_mutable:conversation.SetConversationMaxSeqReq.ownerUserID)
  return _s;
}
inline const std::string& SetConversationMaxSeqReq::_internal_owneruserid(int index) const {
  return _impl_.owneruserid_.Get(index);
}
inline const std::string& SetConversationMaxSeqReq::owneruserid(int index) const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationMaxSeqReq.ownerUserID)
  return _internal_owneruserid(index);
}
inline std::string* SetConversationMaxSeqReq::mutable_owneruserid(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationMaxSeqReq.ownerUserID)
  return _impl_.owneruserid_.Mutable(index);
}
inline void SetConversationMaxSeqReq::set_owneruserid(int index, const std::string& value) {
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline void SetConversationMaxSeqReq::set_owneruserid(int index, std::string&& value) {
  _impl_.owneruserid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline void SetConversationMaxSeqReq::set_owneruserid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline void SetConversationMaxSeqReq::set_owneruserid(int index, const char* value, size_t size) {
  _impl_.owneruserid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline std::string* SetConversationMaxSeqReq::_internal_add_owneruserid() {
  return _impl_.owneruserid_.Add();
}
inline void SetConversationMaxSeqReq::add_owneruserid(const std::string& value) {
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline void SetConversationMaxSeqReq::add_owneruserid(std::string&& value) {
  _impl_.owneruserid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline void SetConversationMaxSeqReq::add_owneruserid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline void SetConversationMaxSeqReq::add_owneruserid(const char* value, size_t size) {
  _impl_.owneruserid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.SetConversationMaxSeqReq.ownerUserID)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetConversationMaxSeqReq::owneruserid() const {
  // @@protoc_insertion_point(field_list:conversation.SetConversationMaxSeqReq.ownerUserID)
  return _impl_.owneruserid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetConversationMaxSeqReq::mutable_owneruserid() {
  // @@protoc_insertion_point(field_mutable_list:conversation.SetConversationMaxSeqReq.ownerUserID)
  return &_impl_.owneruserid_;
}

// int64 maxSeq = 3;
inline void SetConversationMaxSeqReq::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t SetConversationMaxSeqReq::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t SetConversationMaxSeqReq::maxseq() const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationMaxSeqReq.maxSeq)
  return _internal_maxseq();
}
inline void SetConversationMaxSeqReq::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void SetConversationMaxSeqReq::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:conversation.SetConversationMaxSeqReq.maxSeq)
}

// -------------------------------------------------------------------

// SetConversationMaxSeqResp

// -------------------------------------------------------------------

// SetConversationMinSeqReq

// string conversationID = 1;
inline void SetConversationMinSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& SetConversationMinSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationMinSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetConversationMinSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.SetConversationMinSeqReq.conversationID)
}
inline std::string* SetConversationMinSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationMinSeqReq.conversationID)
  return _s;
}
inline const std::string& SetConversationMinSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void SetConversationMinSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetConversationMinSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetConversationMinSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.SetConversationMinSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void SetConversationMinSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.SetConversationMinSeqReq.conversationID)
}

// repeated string ownerUserID = 2;
inline int SetConversationMinSeqReq::_internal_owneruserid_size() const {
  return _impl_.owneruserid_.size();
}
inline int SetConversationMinSeqReq::owneruserid_size() const {
  return _internal_owneruserid_size();
}
inline void SetConversationMinSeqReq::clear_owneruserid() {
  _impl_.owneruserid_.Clear();
}
inline std::string* SetConversationMinSeqReq::add_owneruserid() {
  std::string* _s = _internal_add_owneruserid();
  // @@protoc_insertion_point(field_add_mutable:conversation.SetConversationMinSeqReq.ownerUserID)
  return _s;
}
inline const std::string& SetConversationMinSeqReq::_internal_owneruserid(int index) const {
  return _impl_.owneruserid_.Get(index);
}
inline const std::string& SetConversationMinSeqReq::owneruserid(int index) const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationMinSeqReq.ownerUserID)
  return _internal_owneruserid(index);
}
inline std::string* SetConversationMinSeqReq::mutable_owneruserid(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationMinSeqReq.ownerUserID)
  return _impl_.owneruserid_.Mutable(index);
}
inline void SetConversationMinSeqReq::set_owneruserid(int index, const std::string& value) {
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline void SetConversationMinSeqReq::set_owneruserid(int index, std::string&& value) {
  _impl_.owneruserid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline void SetConversationMinSeqReq::set_owneruserid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline void SetConversationMinSeqReq::set_owneruserid(int index, const char* value, size_t size) {
  _impl_.owneruserid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline std::string* SetConversationMinSeqReq::_internal_add_owneruserid() {
  return _impl_.owneruserid_.Add();
}
inline void SetConversationMinSeqReq::add_owneruserid(const std::string& value) {
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline void SetConversationMinSeqReq::add_owneruserid(std::string&& value) {
  _impl_.owneruserid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline void SetConversationMinSeqReq::add_owneruserid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline void SetConversationMinSeqReq::add_owneruserid(const char* value, size_t size) {
  _impl_.owneruserid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.SetConversationMinSeqReq.ownerUserID)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetConversationMinSeqReq::owneruserid() const {
  // @@protoc_insertion_point(field_list:conversation.SetConversationMinSeqReq.ownerUserID)
  return _impl_.owneruserid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetConversationMinSeqReq::mutable_owneruserid() {
  // @@protoc_insertion_point(field_mutable_list:conversation.SetConversationMinSeqReq.ownerUserID)
  return &_impl_.owneruserid_;
}

// int64 minSeq = 3;
inline void SetConversationMinSeqReq::clear_minseq() {
  _impl_.minseq_ = int64_t{0};
}
inline int64_t SetConversationMinSeqReq::_internal_minseq() const {
  return _impl_.minseq_;
}
inline int64_t SetConversationMinSeqReq::minseq() const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationMinSeqReq.minSeq)
  return _internal_minseq();
}
inline void SetConversationMinSeqReq::_internal_set_minseq(int64_t value) {
  
  _impl_.minseq_ = value;
}
inline void SetConversationMinSeqReq::set_minseq(int64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:conversation.SetConversationMinSeqReq.minSeq)
}

// -------------------------------------------------------------------

// SetConversationMinSeqResp

// -------------------------------------------------------------------

// GetConversationIDsReq

// string userID = 1;
inline void GetConversationIDsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetConversationIDsReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationIDsReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationIDsReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetConversationIDsReq.userID)
}
inline std::string* GetConversationIDsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationIDsReq.userID)
  return _s;
}
inline const std::string& GetConversationIDsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetConversationIDsReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationIDsReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationIDsReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationIDsReq.userID)
  return _impl_.userid_.Release();
}
inline void GetConversationIDsReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationIDsReq.userID)
}

// -------------------------------------------------------------------

// GetConversationIDsResp

// repeated string conversationIDs = 1;
inline int GetConversationIDsResp::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetConversationIDsResp::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetConversationIDsResp::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetConversationIDsResp::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetConversationIDsResp.conversationIDs)
  return _s;
}
inline const std::string& GetConversationIDsResp::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetConversationIDsResp::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationIDsResp.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetConversationIDsResp::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationIDsResp.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetConversationIDsResp::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetConversationIDsResp.conversationIDs)
}
inline void GetConversationIDsResp::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetConversationIDsResp.conversationIDs)
}
inline void GetConversationIDsResp::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetConversationIDsResp.conversationIDs)
}
inline void GetConversationIDsResp::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetConversationIDsResp.conversationIDs)
}
inline std::string* GetConversationIDsResp::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetConversationIDsResp::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetConversationIDsResp.conversationIDs)
}
inline void GetConversationIDsResp::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetConversationIDsResp.conversationIDs)
}
inline void GetConversationIDsResp::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetConversationIDsResp.conversationIDs)
}
inline void GetConversationIDsResp::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetConversationIDsResp.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationIDsResp::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationIDsResp.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationIDsResp::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationIDsResp.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// SetConversationsReq

// repeated string userIDs = 1;
inline int SetConversationsReq::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int SetConversationsReq::userids_size() const {
  return _internal_userids_size();
}
inline void SetConversationsReq::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* SetConversationsReq::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.SetConversationsReq.userIDs)
  return _s;
}
inline const std::string& SetConversationsReq::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& SetConversationsReq::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationsReq.userIDs)
  return _internal_userids(index);
}
inline std::string* SetConversationsReq::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationsReq.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void SetConversationsReq::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.SetConversationsReq.userIDs)
}
inline void SetConversationsReq::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.SetConversationsReq.userIDs)
}
inline void SetConversationsReq::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.SetConversationsReq.userIDs)
}
inline void SetConversationsReq::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.SetConversationsReq.userIDs)
}
inline std::string* SetConversationsReq::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void SetConversationsReq::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.SetConversationsReq.userIDs)
}
inline void SetConversationsReq::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.SetConversationsReq.userIDs)
}
inline void SetConversationsReq::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.SetConversationsReq.userIDs)
}
inline void SetConversationsReq::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.SetConversationsReq.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetConversationsReq::userids() const {
  // @@protoc_insertion_point(field_list:conversation.SetConversationsReq.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetConversationsReq::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.SetConversationsReq.userIDs)
  return &_impl_.userids_;
}

// .conversation.ConversationReq conversation = 2;
inline bool SetConversationsReq::_internal_has_conversation() const {
  return this != internal_default_instance() && _impl_.conversation_ != nullptr;
}
inline bool SetConversationsReq::has_conversation() const {
  return _internal_has_conversation();
}
inline void SetConversationsReq::clear_conversation() {
  if (GetArenaForAllocation() == nullptr && _impl_.conversation_ != nullptr) {
    delete _impl_.conversation_;
  }
  _impl_.conversation_ = nullptr;
}
inline const ::conversation::ConversationReq& SetConversationsReq::_internal_conversation() const {
  const ::conversation::ConversationReq* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::conversation::ConversationReq&>(
      ::conversation::_ConversationReq_default_instance_);
}
inline const ::conversation::ConversationReq& SetConversationsReq::conversation() const {
  // @@protoc_insertion_point(field_get:conversation.SetConversationsReq.conversation)
  return _internal_conversation();
}
inline void SetConversationsReq::unsafe_arena_set_allocated_conversation(
    ::conversation::ConversationReq* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:conversation.SetConversationsReq.conversation)
}
inline ::conversation::ConversationReq* SetConversationsReq::release_conversation() {
  
  ::conversation::ConversationReq* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::conversation::ConversationReq* SetConversationsReq::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:conversation.SetConversationsReq.conversation)
  
  ::conversation::ConversationReq* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::conversation::ConversationReq* SetConversationsReq::_internal_mutable_conversation() {
  
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::conversation::ConversationReq>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::conversation::ConversationReq* SetConversationsReq::mutable_conversation() {
  ::conversation::ConversationReq* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:conversation.SetConversationsReq.conversation)
  return _msg;
}
inline void SetConversationsReq::set_allocated_conversation(::conversation::ConversationReq* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:conversation.SetConversationsReq.conversation)
}

// -------------------------------------------------------------------

// SetConversationsResp

// -------------------------------------------------------------------

// GetUserConversationIDsHashReq

// string ownerUserID = 1;
inline void GetUserConversationIDsHashReq::clear_owneruserid() {
  _impl_.owneruserid_.ClearToEmpty();
}
inline const std::string& GetUserConversationIDsHashReq::owneruserid() const {
  // @@protoc_insertion_point(field_get:conversation.GetUserConversationIDsHashReq.ownerUserID)
  return _internal_owneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserConversationIDsHashReq::set_owneruserid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetUserConversationIDsHashReq.ownerUserID)
}
inline std::string* GetUserConversationIDsHashReq::mutable_owneruserid() {
  std::string* _s = _internal_mutable_owneruserid();
  // @@protoc_insertion_point(field_mutable:conversation.GetUserConversationIDsHashReq.ownerUserID)
  return _s;
}
inline const std::string& GetUserConversationIDsHashReq::_internal_owneruserid() const {
  return _impl_.owneruserid_.Get();
}
inline void GetUserConversationIDsHashReq::_internal_set_owneruserid(const std::string& value) {
  
  _impl_.owneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserConversationIDsHashReq::_internal_mutable_owneruserid() {
  
  return _impl_.owneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserConversationIDsHashReq::release_owneruserid() {
  // @@protoc_insertion_point(field_release:conversation.GetUserConversationIDsHashReq.ownerUserID)
  return _impl_.owneruserid_.Release();
}
inline void GetUserConversationIDsHashReq::set_allocated_owneruserid(std::string* owneruserid) {
  if (owneruserid != nullptr) {
    
  } else {
    
  }
  _impl_.owneruserid_.SetAllocated(owneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owneruserid_.IsDefault()) {
    _impl_.owneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetUserConversationIDsHashReq.ownerUserID)
}

// -------------------------------------------------------------------

// GetUserConversationIDsHashResp

// uint64 hash = 1;
inline void GetUserConversationIDsHashResp::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t GetUserConversationIDsHashResp::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t GetUserConversationIDsHashResp::hash() const {
  // @@protoc_insertion_point(field_get:conversation.GetUserConversationIDsHashResp.hash)
  return _internal_hash();
}
inline void GetUserConversationIDsHashResp::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void GetUserConversationIDsHashResp::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:conversation.GetUserConversationIDsHashResp.hash)
}

// -------------------------------------------------------------------

// GetConversationsByConversationIDReq

// repeated string conversationIDs = 1;
inline int GetConversationsByConversationIDReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetConversationsByConversationIDReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetConversationsByConversationIDReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetConversationsByConversationIDReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetConversationsByConversationIDReq.conversationIDs)
  return _s;
}
inline const std::string& GetConversationsByConversationIDReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetConversationsByConversationIDReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationsByConversationIDReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetConversationsByConversationIDReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationsByConversationIDReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetConversationsByConversationIDReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline void GetConversationsByConversationIDReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline void GetConversationsByConversationIDReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline void GetConversationsByConversationIDReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline std::string* GetConversationsByConversationIDReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetConversationsByConversationIDReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline void GetConversationsByConversationIDReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline void GetConversationsByConversationIDReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline void GetConversationsByConversationIDReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetConversationsByConversationIDReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationsByConversationIDReq::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationsByConversationIDReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationsByConversationIDReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationsByConversationIDReq.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// GetConversationsByConversationIDResp

// repeated .conversation.Conversation conversations = 1;
inline int GetConversationsByConversationIDResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetConversationsByConversationIDResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetConversationsByConversationIDResp::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::conversation::Conversation* GetConversationsByConversationIDResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationsByConversationIDResp.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetConversationsByConversationIDResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationsByConversationIDResp.conversations)
  return &_impl_.conversations_;
}
inline const ::conversation::Conversation& GetConversationsByConversationIDResp::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::conversation::Conversation& GetConversationsByConversationIDResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationsByConversationIDResp.conversations)
  return _internal_conversations(index);
}
inline ::conversation::Conversation* GetConversationsByConversationIDResp::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::conversation::Conversation* GetConversationsByConversationIDResp::add_conversations() {
  ::conversation::Conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:conversation.GetConversationsByConversationIDResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetConversationsByConversationIDResp::conversations() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationsByConversationIDResp.conversations)
  return _impl_.conversations_;
}

// -------------------------------------------------------------------

// GetConversationOfflinePushUserIDsReq

// string conversationID = 1;
inline void GetConversationOfflinePushUserIDsReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& GetConversationOfflinePushUserIDsReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationOfflinePushUserIDsReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationOfflinePushUserIDsReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetConversationOfflinePushUserIDsReq.conversationID)
}
inline std::string* GetConversationOfflinePushUserIDsReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationOfflinePushUserIDsReq.conversationID)
  return _s;
}
inline const std::string& GetConversationOfflinePushUserIDsReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void GetConversationOfflinePushUserIDsReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationOfflinePushUserIDsReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationOfflinePushUserIDsReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationOfflinePushUserIDsReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void GetConversationOfflinePushUserIDsReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationOfflinePushUserIDsReq.conversationID)
}

// repeated string userIDs = 2;
inline int GetConversationOfflinePushUserIDsReq::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int GetConversationOfflinePushUserIDsReq::userids_size() const {
  return _internal_userids_size();
}
inline void GetConversationOfflinePushUserIDsReq::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* GetConversationOfflinePushUserIDsReq::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
  return _s;
}
inline const std::string& GetConversationOfflinePushUserIDsReq::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& GetConversationOfflinePushUserIDsReq::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
  return _internal_userids(index);
}
inline std::string* GetConversationOfflinePushUserIDsReq::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void GetConversationOfflinePushUserIDsReq::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline void GetConversationOfflinePushUserIDsReq::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline void GetConversationOfflinePushUserIDsReq::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline void GetConversationOfflinePushUserIDsReq::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline std::string* GetConversationOfflinePushUserIDsReq::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void GetConversationOfflinePushUserIDsReq::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline void GetConversationOfflinePushUserIDsReq::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline void GetConversationOfflinePushUserIDsReq::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline void GetConversationOfflinePushUserIDsReq::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationOfflinePushUserIDsReq::userids() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationOfflinePushUserIDsReq::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationOfflinePushUserIDsReq.userIDs)
  return &_impl_.userids_;
}

// -------------------------------------------------------------------

// GetConversationOfflinePushUserIDsResp

// repeated string userIDs = 1;
inline int GetConversationOfflinePushUserIDsResp::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int GetConversationOfflinePushUserIDsResp::userids_size() const {
  return _internal_userids_size();
}
inline void GetConversationOfflinePushUserIDsResp::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* GetConversationOfflinePushUserIDsResp::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
  return _s;
}
inline const std::string& GetConversationOfflinePushUserIDsResp::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& GetConversationOfflinePushUserIDsResp::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
  return _internal_userids(index);
}
inline std::string* GetConversationOfflinePushUserIDsResp::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void GetConversationOfflinePushUserIDsResp::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline void GetConversationOfflinePushUserIDsResp::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline void GetConversationOfflinePushUserIDsResp::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline void GetConversationOfflinePushUserIDsResp::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline std::string* GetConversationOfflinePushUserIDsResp::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void GetConversationOfflinePushUserIDsResp::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline void GetConversationOfflinePushUserIDsResp::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline void GetConversationOfflinePushUserIDsResp::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline void GetConversationOfflinePushUserIDsResp::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationOfflinePushUserIDsResp::userids() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationOfflinePushUserIDsResp::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationOfflinePushUserIDsResp.userIDs)
  return &_impl_.userids_;
}

// -------------------------------------------------------------------

// GetConversationNotReceiveMessageUserIDsReq

// string conversationID = 1;
inline void GetConversationNotReceiveMessageUserIDsReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& GetConversationNotReceiveMessageUserIDsReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationNotReceiveMessageUserIDsReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationNotReceiveMessageUserIDsReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetConversationNotReceiveMessageUserIDsReq.conversationID)
}
inline std::string* GetConversationNotReceiveMessageUserIDsReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationNotReceiveMessageUserIDsReq.conversationID)
  return _s;
}
inline const std::string& GetConversationNotReceiveMessageUserIDsReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void GetConversationNotReceiveMessageUserIDsReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationNotReceiveMessageUserIDsReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationNotReceiveMessageUserIDsReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.GetConversationNotReceiveMessageUserIDsReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void GetConversationNotReceiveMessageUserIDsReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetConversationNotReceiveMessageUserIDsReq.conversationID)
}

// -------------------------------------------------------------------

// GetConversationNotReceiveMessageUserIDsResp

// repeated string userIDs = 1;
inline int GetConversationNotReceiveMessageUserIDsResp::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int GetConversationNotReceiveMessageUserIDsResp::userids_size() const {
  return _internal_userids_size();
}
inline void GetConversationNotReceiveMessageUserIDsResp::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* GetConversationNotReceiveMessageUserIDsResp::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
  return _s;
}
inline const std::string& GetConversationNotReceiveMessageUserIDsResp::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& GetConversationNotReceiveMessageUserIDsResp::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
  return _internal_userids(index);
}
inline std::string* GetConversationNotReceiveMessageUserIDsResp::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void GetConversationNotReceiveMessageUserIDsResp::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline void GetConversationNotReceiveMessageUserIDsResp::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline void GetConversationNotReceiveMessageUserIDsResp::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline void GetConversationNotReceiveMessageUserIDsResp::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline std::string* GetConversationNotReceiveMessageUserIDsResp::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void GetConversationNotReceiveMessageUserIDsResp::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline void GetConversationNotReceiveMessageUserIDsResp::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline void GetConversationNotReceiveMessageUserIDsResp::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline void GetConversationNotReceiveMessageUserIDsResp::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationNotReceiveMessageUserIDsResp::userids() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationNotReceiveMessageUserIDsResp::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationNotReceiveMessageUserIDsResp.userIDs)
  return &_impl_.userids_;
}

// -------------------------------------------------------------------

// UpdateConversationReq

// string conversationID = 1;
inline void UpdateConversationReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& UpdateConversationReq::conversationid() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.conversationID)
}
inline std::string* UpdateConversationReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:conversation.UpdateConversationReq.conversationID)
  return _s;
}
inline const std::string& UpdateConversationReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void UpdateConversationReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:conversation.UpdateConversationReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void UpdateConversationReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.UpdateConversationReq.conversationID)
}

// repeated string userIDs = 2;
inline int UpdateConversationReq::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int UpdateConversationReq::userids_size() const {
  return _internal_userids_size();
}
inline void UpdateConversationReq::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* UpdateConversationReq::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:conversation.UpdateConversationReq.userIDs)
  return _s;
}
inline const std::string& UpdateConversationReq::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& UpdateConversationReq::userids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.userIDs)
  return _internal_userids(index);
}
inline std::string* UpdateConversationReq::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.UpdateConversationReq.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void UpdateConversationReq::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.userIDs)
}
inline void UpdateConversationReq::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.userIDs)
}
inline void UpdateConversationReq::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.UpdateConversationReq.userIDs)
}
inline void UpdateConversationReq::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.UpdateConversationReq.userIDs)
}
inline std::string* UpdateConversationReq::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void UpdateConversationReq::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.UpdateConversationReq.userIDs)
}
inline void UpdateConversationReq::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.UpdateConversationReq.userIDs)
}
inline void UpdateConversationReq::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.UpdateConversationReq.userIDs)
}
inline void UpdateConversationReq::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.UpdateConversationReq.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateConversationReq::userids() const {
  // @@protoc_insertion_point(field_list:conversation.UpdateConversationReq.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateConversationReq::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.UpdateConversationReq.userIDs)
  return &_impl_.userids_;
}

// int32 recvMsgOpt = 3;
inline void UpdateConversationReq::clear_recvmsgopt() {
  _impl_.recvmsgopt_ = 0;
}
inline int32_t UpdateConversationReq::_internal_recvmsgopt() const {
  return _impl_.recvmsgopt_;
}
inline int32_t UpdateConversationReq::recvmsgopt() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.recvMsgOpt)
  return _internal_recvmsgopt();
}
inline void UpdateConversationReq::_internal_set_recvmsgopt(int32_t value) {
  
  _impl_.recvmsgopt_ = value;
}
inline void UpdateConversationReq::set_recvmsgopt(int32_t value) {
  _internal_set_recvmsgopt(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.recvMsgOpt)
}

// bool isPinned = 4;
inline void UpdateConversationReq::clear_ispinned() {
  _impl_.ispinned_ = false;
}
inline bool UpdateConversationReq::_internal_ispinned() const {
  return _impl_.ispinned_;
}
inline bool UpdateConversationReq::ispinned() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.isPinned)
  return _internal_ispinned();
}
inline void UpdateConversationReq::_internal_set_ispinned(bool value) {
  
  _impl_.ispinned_ = value;
}
inline void UpdateConversationReq::set_ispinned(bool value) {
  _internal_set_ispinned(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.isPinned)
}

// string attachedInfo = 5;
inline void UpdateConversationReq::clear_attachedinfo() {
  _impl_.attachedinfo_.ClearToEmpty();
}
inline const std::string& UpdateConversationReq::attachedinfo() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.attachedInfo)
  return _internal_attachedinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationReq::set_attachedinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachedinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.attachedInfo)
}
inline std::string* UpdateConversationReq::mutable_attachedinfo() {
  std::string* _s = _internal_mutable_attachedinfo();
  // @@protoc_insertion_point(field_mutable:conversation.UpdateConversationReq.attachedInfo)
  return _s;
}
inline const std::string& UpdateConversationReq::_internal_attachedinfo() const {
  return _impl_.attachedinfo_.Get();
}
inline void UpdateConversationReq::_internal_set_attachedinfo(const std::string& value) {
  
  _impl_.attachedinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationReq::_internal_mutable_attachedinfo() {
  
  return _impl_.attachedinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationReq::release_attachedinfo() {
  // @@protoc_insertion_point(field_release:conversation.UpdateConversationReq.attachedInfo)
  return _impl_.attachedinfo_.Release();
}
inline void UpdateConversationReq::set_allocated_attachedinfo(std::string* attachedinfo) {
  if (attachedinfo != nullptr) {
    
  } else {
    
  }
  _impl_.attachedinfo_.SetAllocated(attachedinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachedinfo_.IsDefault()) {
    _impl_.attachedinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.UpdateConversationReq.attachedInfo)
}

// bool isPrivateChat = 6;
inline void UpdateConversationReq::clear_isprivatechat() {
  _impl_.isprivatechat_ = false;
}
inline bool UpdateConversationReq::_internal_isprivatechat() const {
  return _impl_.isprivatechat_;
}
inline bool UpdateConversationReq::isprivatechat() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.isPrivateChat)
  return _internal_isprivatechat();
}
inline void UpdateConversationReq::_internal_set_isprivatechat(bool value) {
  
  _impl_.isprivatechat_ = value;
}
inline void UpdateConversationReq::set_isprivatechat(bool value) {
  _internal_set_isprivatechat(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.isPrivateChat)
}

// string ex = 7;
inline void UpdateConversationReq::clear_ex() {
  _impl_.ex_.ClearToEmpty();
}
inline const std::string& UpdateConversationReq::ex() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.ex)
  return _internal_ex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationReq::set_ex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.ex)
}
inline std::string* UpdateConversationReq::mutable_ex() {
  std::string* _s = _internal_mutable_ex();
  // @@protoc_insertion_point(field_mutable:conversation.UpdateConversationReq.ex)
  return _s;
}
inline const std::string& UpdateConversationReq::_internal_ex() const {
  return _impl_.ex_.Get();
}
inline void UpdateConversationReq::_internal_set_ex(const std::string& value) {
  
  _impl_.ex_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationReq::_internal_mutable_ex() {
  
  return _impl_.ex_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationReq::release_ex() {
  // @@protoc_insertion_point(field_release:conversation.UpdateConversationReq.ex)
  return _impl_.ex_.Release();
}
inline void UpdateConversationReq::set_allocated_ex(std::string* ex) {
  if (ex != nullptr) {
    
  } else {
    
  }
  _impl_.ex_.SetAllocated(ex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ex_.IsDefault()) {
    _impl_.ex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.UpdateConversationReq.ex)
}

// int32 burnDuration = 8;
inline void UpdateConversationReq::clear_burnduration() {
  _impl_.burnduration_ = 0;
}
inline int32_t UpdateConversationReq::_internal_burnduration() const {
  return _impl_.burnduration_;
}
inline int32_t UpdateConversationReq::burnduration() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.burnDuration)
  return _internal_burnduration();
}
inline void UpdateConversationReq::_internal_set_burnduration(int32_t value) {
  
  _impl_.burnduration_ = value;
}
inline void UpdateConversationReq::set_burnduration(int32_t value) {
  _internal_set_burnduration(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.burnDuration)
}

// int64 minSeq = 9;
inline void UpdateConversationReq::clear_minseq() {
  _impl_.minseq_ = int64_t{0};
}
inline int64_t UpdateConversationReq::_internal_minseq() const {
  return _impl_.minseq_;
}
inline int64_t UpdateConversationReq::minseq() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.minSeq)
  return _internal_minseq();
}
inline void UpdateConversationReq::_internal_set_minseq(int64_t value) {
  
  _impl_.minseq_ = value;
}
inline void UpdateConversationReq::set_minseq(int64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.minSeq)
}

// int64 maxSeq = 10;
inline void UpdateConversationReq::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t UpdateConversationReq::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t UpdateConversationReq::maxseq() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.maxSeq)
  return _internal_maxseq();
}
inline void UpdateConversationReq::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void UpdateConversationReq::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.maxSeq)
}

// int32 groupAtType = 11;
inline void UpdateConversationReq::clear_groupattype() {
  _impl_.groupattype_ = 0;
}
inline int32_t UpdateConversationReq::_internal_groupattype() const {
  return _impl_.groupattype_;
}
inline int32_t UpdateConversationReq::groupattype() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.groupAtType)
  return _internal_groupattype();
}
inline void UpdateConversationReq::_internal_set_groupattype(int32_t value) {
  
  _impl_.groupattype_ = value;
}
inline void UpdateConversationReq::set_groupattype(int32_t value) {
  _internal_set_groupattype(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.groupAtType)
}

// int64 msgDestructTime = 12;
inline void UpdateConversationReq::clear_msgdestructtime() {
  _impl_.msgdestructtime_ = int64_t{0};
}
inline int64_t UpdateConversationReq::_internal_msgdestructtime() const {
  return _impl_.msgdestructtime_;
}
inline int64_t UpdateConversationReq::msgdestructtime() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.msgDestructTime)
  return _internal_msgdestructtime();
}
inline void UpdateConversationReq::_internal_set_msgdestructtime(int64_t value) {
  
  _impl_.msgdestructtime_ = value;
}
inline void UpdateConversationReq::set_msgdestructtime(int64_t value) {
  _internal_set_msgdestructtime(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.msgDestructTime)
}

// bool isMsgDestruct = 13;
inline void UpdateConversationReq::clear_ismsgdestruct() {
  _impl_.ismsgdestruct_ = false;
}
inline bool UpdateConversationReq::_internal_ismsgdestruct() const {
  return _impl_.ismsgdestruct_;
}
inline bool UpdateConversationReq::ismsgdestruct() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.isMsgDestruct)
  return _internal_ismsgdestruct();
}
inline void UpdateConversationReq::_internal_set_ismsgdestruct(bool value) {
  
  _impl_.ismsgdestruct_ = value;
}
inline void UpdateConversationReq::set_ismsgdestruct(bool value) {
  _internal_set_ismsgdestruct(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.isMsgDestruct)
}

// int64 latestMsgDestructTime = 14;
inline void UpdateConversationReq::clear_latestmsgdestructtime() {
  _impl_.latestmsgdestructtime_ = int64_t{0};
}
inline int64_t UpdateConversationReq::_internal_latestmsgdestructtime() const {
  return _impl_.latestmsgdestructtime_;
}
inline int64_t UpdateConversationReq::latestmsgdestructtime() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationReq.latestMsgDestructTime)
  return _internal_latestmsgdestructtime();
}
inline void UpdateConversationReq::_internal_set_latestmsgdestructtime(int64_t value) {
  
  _impl_.latestmsgdestructtime_ = value;
}
inline void UpdateConversationReq::set_latestmsgdestructtime(int64_t value) {
  _internal_set_latestmsgdestructtime(value);
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationReq.latestMsgDestructTime)
}

// -------------------------------------------------------------------

// UpdateConversationResp

// -------------------------------------------------------------------

// GetFullOwnerConversationIDsReq

// uint64 idHash = 1;
inline void GetFullOwnerConversationIDsReq::clear_idhash() {
  _impl_.idhash_ = uint64_t{0u};
}
inline uint64_t GetFullOwnerConversationIDsReq::_internal_idhash() const {
  return _impl_.idhash_;
}
inline uint64_t GetFullOwnerConversationIDsReq::idhash() const {
  // @@protoc_insertion_point(field_get:conversation.GetFullOwnerConversationIDsReq.idHash)
  return _internal_idhash();
}
inline void GetFullOwnerConversationIDsReq::_internal_set_idhash(uint64_t value) {
  
  _impl_.idhash_ = value;
}
inline void GetFullOwnerConversationIDsReq::set_idhash(uint64_t value) {
  _internal_set_idhash(value);
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsReq.idHash)
}

// string userID = 2;
inline void GetFullOwnerConversationIDsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetFullOwnerConversationIDsReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetFullOwnerConversationIDsReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFullOwnerConversationIDsReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsReq.userID)
}
inline std::string* GetFullOwnerConversationIDsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetFullOwnerConversationIDsReq.userID)
  return _s;
}
inline const std::string& GetFullOwnerConversationIDsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetFullOwnerConversationIDsReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFullOwnerConversationIDsReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFullOwnerConversationIDsReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetFullOwnerConversationIDsReq.userID)
  return _impl_.userid_.Release();
}
inline void GetFullOwnerConversationIDsReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetFullOwnerConversationIDsReq.userID)
}

// -------------------------------------------------------------------

// GetFullOwnerConversationIDsResp

// uint64 version = 1;
inline void GetFullOwnerConversationIDsResp::clear_version() {
  _impl_.version_ = uint64_t{0u};
}
inline uint64_t GetFullOwnerConversationIDsResp::_internal_version() const {
  return _impl_.version_;
}
inline uint64_t GetFullOwnerConversationIDsResp::version() const {
  // @@protoc_insertion_point(field_get:conversation.GetFullOwnerConversationIDsResp.version)
  return _internal_version();
}
inline void GetFullOwnerConversationIDsResp::_internal_set_version(uint64_t value) {
  
  _impl_.version_ = value;
}
inline void GetFullOwnerConversationIDsResp::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsResp.version)
}

// string versionID = 2;
inline void GetFullOwnerConversationIDsResp::clear_versionid() {
  _impl_.versionid_.ClearToEmpty();
}
inline const std::string& GetFullOwnerConversationIDsResp::versionid() const {
  // @@protoc_insertion_point(field_get:conversation.GetFullOwnerConversationIDsResp.versionID)
  return _internal_versionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFullOwnerConversationIDsResp::set_versionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.versionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsResp.versionID)
}
inline std::string* GetFullOwnerConversationIDsResp::mutable_versionid() {
  std::string* _s = _internal_mutable_versionid();
  // @@protoc_insertion_point(field_mutable:conversation.GetFullOwnerConversationIDsResp.versionID)
  return _s;
}
inline const std::string& GetFullOwnerConversationIDsResp::_internal_versionid() const {
  return _impl_.versionid_.Get();
}
inline void GetFullOwnerConversationIDsResp::_internal_set_versionid(const std::string& value) {
  
  _impl_.versionid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFullOwnerConversationIDsResp::_internal_mutable_versionid() {
  
  return _impl_.versionid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFullOwnerConversationIDsResp::release_versionid() {
  // @@protoc_insertion_point(field_release:conversation.GetFullOwnerConversationIDsResp.versionID)
  return _impl_.versionid_.Release();
}
inline void GetFullOwnerConversationIDsResp::set_allocated_versionid(std::string* versionid) {
  if (versionid != nullptr) {
    
  } else {
    
  }
  _impl_.versionid_.SetAllocated(versionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionid_.IsDefault()) {
    _impl_.versionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetFullOwnerConversationIDsResp.versionID)
}

// bool equal = 3;
inline void GetFullOwnerConversationIDsResp::clear_equal() {
  _impl_.equal_ = false;
}
inline bool GetFullOwnerConversationIDsResp::_internal_equal() const {
  return _impl_.equal_;
}
inline bool GetFullOwnerConversationIDsResp::equal() const {
  // @@protoc_insertion_point(field_get:conversation.GetFullOwnerConversationIDsResp.equal)
  return _internal_equal();
}
inline void GetFullOwnerConversationIDsResp::_internal_set_equal(bool value) {
  
  _impl_.equal_ = value;
}
inline void GetFullOwnerConversationIDsResp::set_equal(bool value) {
  _internal_set_equal(value);
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsResp.equal)
}

// repeated string conversationIDs = 4;
inline int GetFullOwnerConversationIDsResp::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetFullOwnerConversationIDsResp::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetFullOwnerConversationIDsResp::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetFullOwnerConversationIDsResp::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
  return _s;
}
inline const std::string& GetFullOwnerConversationIDsResp::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetFullOwnerConversationIDsResp::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetFullOwnerConversationIDsResp::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetFullOwnerConversationIDsResp::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline void GetFullOwnerConversationIDsResp::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline void GetFullOwnerConversationIDsResp::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline void GetFullOwnerConversationIDsResp::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline std::string* GetFullOwnerConversationIDsResp::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetFullOwnerConversationIDsResp::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline void GetFullOwnerConversationIDsResp::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline void GetFullOwnerConversationIDsResp::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline void GetFullOwnerConversationIDsResp::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetFullOwnerConversationIDsResp::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetFullOwnerConversationIDsResp::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetFullOwnerConversationIDsResp.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// GetIncrementalConversationReq

// string userID = 1;
inline void GetIncrementalConversationReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetIncrementalConversationReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIncrementalConversationReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationReq.userID)
}
inline std::string* GetIncrementalConversationReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetIncrementalConversationReq.userID)
  return _s;
}
inline const std::string& GetIncrementalConversationReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetIncrementalConversationReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIncrementalConversationReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetIncrementalConversationReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetIncrementalConversationReq.userID)
  return _impl_.userid_.Release();
}
inline void GetIncrementalConversationReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetIncrementalConversationReq.userID)
}

// string versionID = 2;
inline void GetIncrementalConversationReq::clear_versionid() {
  _impl_.versionid_.ClearToEmpty();
}
inline const std::string& GetIncrementalConversationReq::versionid() const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationReq.versionID)
  return _internal_versionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIncrementalConversationReq::set_versionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.versionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationReq.versionID)
}
inline std::string* GetIncrementalConversationReq::mutable_versionid() {
  std::string* _s = _internal_mutable_versionid();
  // @@protoc_insertion_point(field_mutable:conversation.GetIncrementalConversationReq.versionID)
  return _s;
}
inline const std::string& GetIncrementalConversationReq::_internal_versionid() const {
  return _impl_.versionid_.Get();
}
inline void GetIncrementalConversationReq::_internal_set_versionid(const std::string& value) {
  
  _impl_.versionid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIncrementalConversationReq::_internal_mutable_versionid() {
  
  return _impl_.versionid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetIncrementalConversationReq::release_versionid() {
  // @@protoc_insertion_point(field_release:conversation.GetIncrementalConversationReq.versionID)
  return _impl_.versionid_.Release();
}
inline void GetIncrementalConversationReq::set_allocated_versionid(std::string* versionid) {
  if (versionid != nullptr) {
    
  } else {
    
  }
  _impl_.versionid_.SetAllocated(versionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionid_.IsDefault()) {
    _impl_.versionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetIncrementalConversationReq.versionID)
}

// uint64 version = 3;
inline void GetIncrementalConversationReq::clear_version() {
  _impl_.version_ = uint64_t{0u};
}
inline uint64_t GetIncrementalConversationReq::_internal_version() const {
  return _impl_.version_;
}
inline uint64_t GetIncrementalConversationReq::version() const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationReq.version)
  return _internal_version();
}
inline void GetIncrementalConversationReq::_internal_set_version(uint64_t value) {
  
  _impl_.version_ = value;
}
inline void GetIncrementalConversationReq::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationReq.version)
}

// -------------------------------------------------------------------

// GetIncrementalConversationResp

// uint64 version = 1;
inline void GetIncrementalConversationResp::clear_version() {
  _impl_.version_ = uint64_t{0u};
}
inline uint64_t GetIncrementalConversationResp::_internal_version() const {
  return _impl_.version_;
}
inline uint64_t GetIncrementalConversationResp::version() const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationResp.version)
  return _internal_version();
}
inline void GetIncrementalConversationResp::_internal_set_version(uint64_t value) {
  
  _impl_.version_ = value;
}
inline void GetIncrementalConversationResp::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationResp.version)
}

// string versionID = 2;
inline void GetIncrementalConversationResp::clear_versionid() {
  _impl_.versionid_.ClearToEmpty();
}
inline const std::string& GetIncrementalConversationResp::versionid() const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationResp.versionID)
  return _internal_versionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIncrementalConversationResp::set_versionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.versionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationResp.versionID)
}
inline std::string* GetIncrementalConversationResp::mutable_versionid() {
  std::string* _s = _internal_mutable_versionid();
  // @@protoc_insertion_point(field_mutable:conversation.GetIncrementalConversationResp.versionID)
  return _s;
}
inline const std::string& GetIncrementalConversationResp::_internal_versionid() const {
  return _impl_.versionid_.Get();
}
inline void GetIncrementalConversationResp::_internal_set_versionid(const std::string& value) {
  
  _impl_.versionid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIncrementalConversationResp::_internal_mutable_versionid() {
  
  return _impl_.versionid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetIncrementalConversationResp::release_versionid() {
  // @@protoc_insertion_point(field_release:conversation.GetIncrementalConversationResp.versionID)
  return _impl_.versionid_.Release();
}
inline void GetIncrementalConversationResp::set_allocated_versionid(std::string* versionid) {
  if (versionid != nullptr) {
    
  } else {
    
  }
  _impl_.versionid_.SetAllocated(versionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionid_.IsDefault()) {
    _impl_.versionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetIncrementalConversationResp.versionID)
}

// bool full = 3;
inline void GetIncrementalConversationResp::clear_full() {
  _impl_.full_ = false;
}
inline bool GetIncrementalConversationResp::_internal_full() const {
  return _impl_.full_;
}
inline bool GetIncrementalConversationResp::full() const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationResp.full)
  return _internal_full();
}
inline void GetIncrementalConversationResp::_internal_set_full(bool value) {
  
  _impl_.full_ = value;
}
inline void GetIncrementalConversationResp::set_full(bool value) {
  _internal_set_full(value);
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationResp.full)
}

// repeated string delete = 4;
inline int GetIncrementalConversationResp::_internal_delete__size() const {
  return _impl_.delete__.size();
}
inline int GetIncrementalConversationResp::delete__size() const {
  return _internal_delete__size();
}
inline void GetIncrementalConversationResp::clear_delete_() {
  _impl_.delete__.Clear();
}
inline std::string* GetIncrementalConversationResp::add_delete_() {
  std::string* _s = _internal_add_delete_();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetIncrementalConversationResp.delete)
  return _s;
}
inline const std::string& GetIncrementalConversationResp::_internal_delete_(int index) const {
  return _impl_.delete__.Get(index);
}
inline const std::string& GetIncrementalConversationResp::delete_(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationResp.delete)
  return _internal_delete_(index);
}
inline std::string* GetIncrementalConversationResp::mutable_delete_(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetIncrementalConversationResp.delete)
  return _impl_.delete__.Mutable(index);
}
inline void GetIncrementalConversationResp::set_delete_(int index, const std::string& value) {
  _impl_.delete__.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationResp.delete)
}
inline void GetIncrementalConversationResp::set_delete_(int index, std::string&& value) {
  _impl_.delete__.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetIncrementalConversationResp.delete)
}
inline void GetIncrementalConversationResp::set_delete_(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delete__.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetIncrementalConversationResp.delete)
}
inline void GetIncrementalConversationResp::set_delete_(int index, const char* value, size_t size) {
  _impl_.delete__.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetIncrementalConversationResp.delete)
}
inline std::string* GetIncrementalConversationResp::_internal_add_delete_() {
  return _impl_.delete__.Add();
}
inline void GetIncrementalConversationResp::add_delete_(const std::string& value) {
  _impl_.delete__.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetIncrementalConversationResp.delete)
}
inline void GetIncrementalConversationResp::add_delete_(std::string&& value) {
  _impl_.delete__.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetIncrementalConversationResp.delete)
}
inline void GetIncrementalConversationResp::add_delete_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delete__.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetIncrementalConversationResp.delete)
}
inline void GetIncrementalConversationResp::add_delete_(const char* value, size_t size) {
  _impl_.delete__.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetIncrementalConversationResp.delete)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetIncrementalConversationResp::delete_() const {
  // @@protoc_insertion_point(field_list:conversation.GetIncrementalConversationResp.delete)
  return _impl_.delete__;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetIncrementalConversationResp::mutable_delete_() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetIncrementalConversationResp.delete)
  return &_impl_.delete__;
}

// repeated .conversation.Conversation insert = 5;
inline int GetIncrementalConversationResp::_internal_insert_size() const {
  return _impl_.insert_.size();
}
inline int GetIncrementalConversationResp::insert_size() const {
  return _internal_insert_size();
}
inline void GetIncrementalConversationResp::clear_insert() {
  _impl_.insert_.Clear();
}
inline ::conversation::Conversation* GetIncrementalConversationResp::mutable_insert(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetIncrementalConversationResp.insert)
  return _impl_.insert_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetIncrementalConversationResp::mutable_insert() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetIncrementalConversationResp.insert)
  return &_impl_.insert_;
}
inline const ::conversation::Conversation& GetIncrementalConversationResp::_internal_insert(int index) const {
  return _impl_.insert_.Get(index);
}
inline const ::conversation::Conversation& GetIncrementalConversationResp::insert(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationResp.insert)
  return _internal_insert(index);
}
inline ::conversation::Conversation* GetIncrementalConversationResp::_internal_add_insert() {
  return _impl_.insert_.Add();
}
inline ::conversation::Conversation* GetIncrementalConversationResp::add_insert() {
  ::conversation::Conversation* _add = _internal_add_insert();
  // @@protoc_insertion_point(field_add:conversation.GetIncrementalConversationResp.insert)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetIncrementalConversationResp::insert() const {
  // @@protoc_insertion_point(field_list:conversation.GetIncrementalConversationResp.insert)
  return _impl_.insert_;
}

// repeated .conversation.Conversation update = 6;
inline int GetIncrementalConversationResp::_internal_update_size() const {
  return _impl_.update_.size();
}
inline int GetIncrementalConversationResp::update_size() const {
  return _internal_update_size();
}
inline void GetIncrementalConversationResp::clear_update() {
  _impl_.update_.Clear();
}
inline ::conversation::Conversation* GetIncrementalConversationResp::mutable_update(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetIncrementalConversationResp.update)
  return _impl_.update_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetIncrementalConversationResp::mutable_update() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetIncrementalConversationResp.update)
  return &_impl_.update_;
}
inline const ::conversation::Conversation& GetIncrementalConversationResp::_internal_update(int index) const {
  return _impl_.update_.Get(index);
}
inline const ::conversation::Conversation& GetIncrementalConversationResp::update(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetIncrementalConversationResp.update)
  return _internal_update(index);
}
inline ::conversation::Conversation* GetIncrementalConversationResp::_internal_add_update() {
  return _impl_.update_.Add();
}
inline ::conversation::Conversation* GetIncrementalConversationResp::add_update() {
  ::conversation::Conversation* _add = _internal_add_update();
  // @@protoc_insertion_point(field_add:conversation.GetIncrementalConversationResp.update)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetIncrementalConversationResp::update() const {
  // @@protoc_insertion_point(field_list:conversation.GetIncrementalConversationResp.update)
  return _impl_.update_;
}

// -------------------------------------------------------------------

// GetOwnerConversationReq

// string userID = 1;
inline void GetOwnerConversationReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetOwnerConversationReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetOwnerConversationReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOwnerConversationReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetOwnerConversationReq.userID)
}
inline std::string* GetOwnerConversationReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetOwnerConversationReq.userID)
  return _s;
}
inline const std::string& GetOwnerConversationReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetOwnerConversationReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOwnerConversationReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOwnerConversationReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetOwnerConversationReq.userID)
  return _impl_.userid_.Release();
}
inline void GetOwnerConversationReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetOwnerConversationReq.userID)
}

// .sdkws.RequestPagination pagination = 2;
inline bool GetOwnerConversationReq::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetOwnerConversationReq::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sdkws::RequestPagination& GetOwnerConversationReq::_internal_pagination() const {
  const ::sdkws::RequestPagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::RequestPagination&>(
      ::sdkws::_RequestPagination_default_instance_);
}
inline const ::sdkws::RequestPagination& GetOwnerConversationReq::pagination() const {
  // @@protoc_insertion_point(field_get:conversation.GetOwnerConversationReq.pagination)
  return _internal_pagination();
}
inline void GetOwnerConversationReq::unsafe_arena_set_allocated_pagination(
    ::sdkws::RequestPagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:conversation.GetOwnerConversationReq.pagination)
}
inline ::sdkws::RequestPagination* GetOwnerConversationReq::release_pagination() {
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::RequestPagination* GetOwnerConversationReq::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:conversation.GetOwnerConversationReq.pagination)
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sdkws::RequestPagination* GetOwnerConversationReq::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::RequestPagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sdkws::RequestPagination* GetOwnerConversationReq::mutable_pagination() {
  ::sdkws::RequestPagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:conversation.GetOwnerConversationReq.pagination)
  return _msg;
}
inline void GetOwnerConversationReq::set_allocated_pagination(::sdkws::RequestPagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:conversation.GetOwnerConversationReq.pagination)
}

// -------------------------------------------------------------------

// GetOwnerConversationResp

// int64 total = 1;
inline void GetOwnerConversationResp::clear_total() {
  _impl_.total_ = int64_t{0};
}
inline int64_t GetOwnerConversationResp::_internal_total() const {
  return _impl_.total_;
}
inline int64_t GetOwnerConversationResp::total() const {
  // @@protoc_insertion_point(field_get:conversation.GetOwnerConversationResp.total)
  return _internal_total();
}
inline void GetOwnerConversationResp::_internal_set_total(int64_t value) {
  
  _impl_.total_ = value;
}
inline void GetOwnerConversationResp::set_total(int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:conversation.GetOwnerConversationResp.total)
}

// repeated .conversation.Conversation conversations = 2;
inline int GetOwnerConversationResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetOwnerConversationResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetOwnerConversationResp::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::conversation::Conversation* GetOwnerConversationResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetOwnerConversationResp.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetOwnerConversationResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetOwnerConversationResp.conversations)
  return &_impl_.conversations_;
}
inline const ::conversation::Conversation& GetOwnerConversationResp::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::conversation::Conversation& GetOwnerConversationResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetOwnerConversationResp.conversations)
  return _internal_conversations(index);
}
inline ::conversation::Conversation* GetOwnerConversationResp::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::conversation::Conversation* GetOwnerConversationResp::add_conversations() {
  ::conversation::Conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:conversation.GetOwnerConversationResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetOwnerConversationResp::conversations() const {
  // @@protoc_insertion_point(field_list:conversation.GetOwnerConversationResp.conversations)
  return _impl_.conversations_;
}

// -------------------------------------------------------------------

// GetConversationsNeedClearMsgReq

// -------------------------------------------------------------------

// GetConversationsNeedClearMsgResp

// repeated .conversation.Conversation conversations = 1;
inline int GetConversationsNeedClearMsgResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetConversationsNeedClearMsgResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetConversationsNeedClearMsgResp::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::conversation::Conversation* GetConversationsNeedClearMsgResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetConversationsNeedClearMsgResp.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >*
GetConversationsNeedClearMsgResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetConversationsNeedClearMsgResp.conversations)
  return &_impl_.conversations_;
}
inline const ::conversation::Conversation& GetConversationsNeedClearMsgResp::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::conversation::Conversation& GetConversationsNeedClearMsgResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetConversationsNeedClearMsgResp.conversations)
  return _internal_conversations(index);
}
inline ::conversation::Conversation* GetConversationsNeedClearMsgResp::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::conversation::Conversation* GetConversationsNeedClearMsgResp::add_conversations() {
  ::conversation::Conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:conversation.GetConversationsNeedClearMsgResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::conversation::Conversation >&
GetConversationsNeedClearMsgResp::conversations() const {
  // @@protoc_insertion_point(field_list:conversation.GetConversationsNeedClearMsgResp.conversations)
  return _impl_.conversations_;
}

// -------------------------------------------------------------------

// GetNotNotifyConversationIDsReq

// string userID = 1;
inline void GetNotNotifyConversationIDsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetNotNotifyConversationIDsReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetNotNotifyConversationIDsReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNotNotifyConversationIDsReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetNotNotifyConversationIDsReq.userID)
}
inline std::string* GetNotNotifyConversationIDsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetNotNotifyConversationIDsReq.userID)
  return _s;
}
inline const std::string& GetNotNotifyConversationIDsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetNotNotifyConversationIDsReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNotNotifyConversationIDsReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNotNotifyConversationIDsReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetNotNotifyConversationIDsReq.userID)
  return _impl_.userid_.Release();
}
inline void GetNotNotifyConversationIDsReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetNotNotifyConversationIDsReq.userID)
}

// -------------------------------------------------------------------

// GetNotNotifyConversationIDsResp

// repeated string conversationIDs = 1;
inline int GetNotNotifyConversationIDsResp::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetNotNotifyConversationIDsResp::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetNotNotifyConversationIDsResp::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetNotNotifyConversationIDsResp::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
  return _s;
}
inline const std::string& GetNotNotifyConversationIDsResp::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetNotNotifyConversationIDsResp::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetNotNotifyConversationIDsResp::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetNotNotifyConversationIDsResp::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline void GetNotNotifyConversationIDsResp::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline void GetNotNotifyConversationIDsResp::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline void GetNotNotifyConversationIDsResp::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline std::string* GetNotNotifyConversationIDsResp::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetNotNotifyConversationIDsResp::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline void GetNotNotifyConversationIDsResp::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline void GetNotNotifyConversationIDsResp::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline void GetNotNotifyConversationIDsResp::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetNotNotifyConversationIDsResp::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetNotNotifyConversationIDsResp::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetNotNotifyConversationIDsResp.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// GetPinnedConversationIDsReq

// string userID = 1;
inline void GetPinnedConversationIDsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetPinnedConversationIDsReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.GetPinnedConversationIDsReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPinnedConversationIDsReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.GetPinnedConversationIDsReq.userID)
}
inline std::string* GetPinnedConversationIDsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.GetPinnedConversationIDsReq.userID)
  return _s;
}
inline const std::string& GetPinnedConversationIDsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetPinnedConversationIDsReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPinnedConversationIDsReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPinnedConversationIDsReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.GetPinnedConversationIDsReq.userID)
  return _impl_.userid_.Release();
}
inline void GetPinnedConversationIDsReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.GetPinnedConversationIDsReq.userID)
}

// -------------------------------------------------------------------

// GetPinnedConversationIDsResp

// repeated string conversationIDs = 1;
inline int GetPinnedConversationIDsResp::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetPinnedConversationIDsResp::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetPinnedConversationIDsResp::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetPinnedConversationIDsResp::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:conversation.GetPinnedConversationIDsResp.conversationIDs)
  return _s;
}
inline const std::string& GetPinnedConversationIDsResp::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetPinnedConversationIDsResp::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:conversation.GetPinnedConversationIDsResp.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetPinnedConversationIDsResp::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:conversation.GetPinnedConversationIDsResp.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetPinnedConversationIDsResp::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline void GetPinnedConversationIDsResp::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline void GetPinnedConversationIDsResp::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline void GetPinnedConversationIDsResp::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline std::string* GetPinnedConversationIDsResp::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetPinnedConversationIDsResp::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline void GetPinnedConversationIDsResp::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline void GetPinnedConversationIDsResp::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline void GetPinnedConversationIDsResp::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:conversation.GetPinnedConversationIDsResp.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetPinnedConversationIDsResp::conversationids() const {
  // @@protoc_insertion_point(field_list:conversation.GetPinnedConversationIDsResp.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetPinnedConversationIDsResp::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:conversation.GetPinnedConversationIDsResp.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// ClearUserConversationMsgReq

// int64 timestamp = 1;
inline void ClearUserConversationMsgReq::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t ClearUserConversationMsgReq::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t ClearUserConversationMsgReq::timestamp() const {
  // @@protoc_insertion_point(field_get:conversation.ClearUserConversationMsgReq.timestamp)
  return _internal_timestamp();
}
inline void ClearUserConversationMsgReq::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ClearUserConversationMsgReq::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:conversation.ClearUserConversationMsgReq.timestamp)
}

// int32 limit = 2;
inline void ClearUserConversationMsgReq::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t ClearUserConversationMsgReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t ClearUserConversationMsgReq::limit() const {
  // @@protoc_insertion_point(field_get:conversation.ClearUserConversationMsgReq.limit)
  return _internal_limit();
}
inline void ClearUserConversationMsgReq::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void ClearUserConversationMsgReq::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:conversation.ClearUserConversationMsgReq.limit)
}

// -------------------------------------------------------------------

// ClearUserConversationMsgResp

// int32 count = 1;
inline void ClearUserConversationMsgResp::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t ClearUserConversationMsgResp::_internal_count() const {
  return _impl_.count_;
}
inline int32_t ClearUserConversationMsgResp::count() const {
  // @@protoc_insertion_point(field_get:conversation.ClearUserConversationMsgResp.count)
  return _internal_count();
}
inline void ClearUserConversationMsgResp::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void ClearUserConversationMsgResp::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:conversation.ClearUserConversationMsgResp.count)
}

// -------------------------------------------------------------------

// UpdateConversationsByUserReq

// string userID = 1;
inline void UpdateConversationsByUserReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UpdateConversationsByUserReq::userid() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationsByUserReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationsByUserReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationsByUserReq.userID)
}
inline std::string* UpdateConversationsByUserReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:conversation.UpdateConversationsByUserReq.userID)
  return _s;
}
inline const std::string& UpdateConversationsByUserReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UpdateConversationsByUserReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationsByUserReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationsByUserReq::release_userid() {
  // @@protoc_insertion_point(field_release:conversation.UpdateConversationsByUserReq.userID)
  return _impl_.userid_.Release();
}
inline void UpdateConversationsByUserReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.UpdateConversationsByUserReq.userID)
}

// string ex = 2;
inline void UpdateConversationsByUserReq::clear_ex() {
  _impl_.ex_.ClearToEmpty();
}
inline const std::string& UpdateConversationsByUserReq::ex() const {
  // @@protoc_insertion_point(field_get:conversation.UpdateConversationsByUserReq.ex)
  return _internal_ex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationsByUserReq::set_ex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:conversation.UpdateConversationsByUserReq.ex)
}
inline std::string* UpdateConversationsByUserReq::mutable_ex() {
  std::string* _s = _internal_mutable_ex();
  // @@protoc_insertion_point(field_mutable:conversation.UpdateConversationsByUserReq.ex)
  return _s;
}
inline const std::string& UpdateConversationsByUserReq::_internal_ex() const {
  return _impl_.ex_.Get();
}
inline void UpdateConversationsByUserReq::_internal_set_ex(const std::string& value) {
  
  _impl_.ex_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationsByUserReq::_internal_mutable_ex() {
  
  return _impl_.ex_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationsByUserReq::release_ex() {
  // @@protoc_insertion_point(field_release:conversation.UpdateConversationsByUserReq.ex)
  return _impl_.ex_.Release();
}
inline void UpdateConversationsByUserReq::set_allocated_ex(std::string* ex) {
  if (ex != nullptr) {
    
  } else {
    
  }
  _impl_.ex_.SetAllocated(ex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ex_.IsDefault()) {
    _impl_.ex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:conversation.UpdateConversationsByUserReq.ex)
}

// -------------------------------------------------------------------

// UpdateConversationsByUserResp

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace conversation

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_conversation_2eproto
