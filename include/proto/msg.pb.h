// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "sdkws.pb.h"
#include "conversation.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_2eproto;
namespace msg {
class ActiveConversation;
struct ActiveConversationDefaultTypeInternal;
extern ActiveConversationDefaultTypeInternal _ActiveConversation_default_instance_;
class ActiveGroup;
struct ActiveGroupDefaultTypeInternal;
extern ActiveGroupDefaultTypeInternal _ActiveGroup_default_instance_;
class ActiveUser;
struct ActiveUserDefaultTypeInternal;
extern ActiveUserDefaultTypeInternal _ActiveUser_default_instance_;
class ChatLog;
struct ChatLogDefaultTypeInternal;
extern ChatLogDefaultTypeInternal _ChatLog_default_instance_;
class ClearConversationsMsgReq;
struct ClearConversationsMsgReqDefaultTypeInternal;
extern ClearConversationsMsgReqDefaultTypeInternal _ClearConversationsMsgReq_default_instance_;
class ClearConversationsMsgResp;
struct ClearConversationsMsgRespDefaultTypeInternal;
extern ClearConversationsMsgRespDefaultTypeInternal _ClearConversationsMsgResp_default_instance_;
class ClearMsgReq;
struct ClearMsgReqDefaultTypeInternal;
extern ClearMsgReqDefaultTypeInternal _ClearMsgReq_default_instance_;
class ClearMsgResp;
struct ClearMsgRespDefaultTypeInternal;
extern ClearMsgRespDefaultTypeInternal _ClearMsgResp_default_instance_;
class ConversationSeqs;
struct ConversationSeqsDefaultTypeInternal;
extern ConversationSeqsDefaultTypeInternal _ConversationSeqs_default_instance_;
class DelMsgsReq;
struct DelMsgsReqDefaultTypeInternal;
extern DelMsgsReqDefaultTypeInternal _DelMsgsReq_default_instance_;
class DelMsgsResp;
struct DelMsgsRespDefaultTypeInternal;
extern DelMsgsRespDefaultTypeInternal _DelMsgsResp_default_instance_;
class DeleteMsgPhysicalBySeqReq;
struct DeleteMsgPhysicalBySeqReqDefaultTypeInternal;
extern DeleteMsgPhysicalBySeqReqDefaultTypeInternal _DeleteMsgPhysicalBySeqReq_default_instance_;
class DeleteMsgPhysicalBySeqResp;
struct DeleteMsgPhysicalBySeqRespDefaultTypeInternal;
extern DeleteMsgPhysicalBySeqRespDefaultTypeInternal _DeleteMsgPhysicalBySeqResp_default_instance_;
class DeleteMsgPhysicalReq;
struct DeleteMsgPhysicalReqDefaultTypeInternal;
extern DeleteMsgPhysicalReqDefaultTypeInternal _DeleteMsgPhysicalReq_default_instance_;
class DeleteMsgPhysicalResp;
struct DeleteMsgPhysicalRespDefaultTypeInternal;
extern DeleteMsgPhysicalRespDefaultTypeInternal _DeleteMsgPhysicalResp_default_instance_;
class DeleteMsgsReq;
struct DeleteMsgsReqDefaultTypeInternal;
extern DeleteMsgsReqDefaultTypeInternal _DeleteMsgsReq_default_instance_;
class DeleteMsgsResp;
struct DeleteMsgsRespDefaultTypeInternal;
extern DeleteMsgsRespDefaultTypeInternal _DeleteMsgsResp_default_instance_;
class DeleteSyncOpt;
struct DeleteSyncOptDefaultTypeInternal;
extern DeleteSyncOptDefaultTypeInternal _DeleteSyncOpt_default_instance_;
class DestructMsgsReq;
struct DestructMsgsReqDefaultTypeInternal;
extern DestructMsgsReqDefaultTypeInternal _DestructMsgsReq_default_instance_;
class DestructMsgsResp;
struct DestructMsgsRespDefaultTypeInternal;
extern DestructMsgsRespDefaultTypeInternal _DestructMsgsResp_default_instance_;
class GetActiveConversationReq;
struct GetActiveConversationReqDefaultTypeInternal;
extern GetActiveConversationReqDefaultTypeInternal _GetActiveConversationReq_default_instance_;
class GetActiveConversationResp;
struct GetActiveConversationRespDefaultTypeInternal;
extern GetActiveConversationRespDefaultTypeInternal _GetActiveConversationResp_default_instance_;
class GetActiveGroupReq;
struct GetActiveGroupReqDefaultTypeInternal;
extern GetActiveGroupReqDefaultTypeInternal _GetActiveGroupReq_default_instance_;
class GetActiveGroupResp;
struct GetActiveGroupRespDefaultTypeInternal;
extern GetActiveGroupRespDefaultTypeInternal _GetActiveGroupResp_default_instance_;
class GetActiveGroupResp_DateCountEntry_DoNotUse;
struct GetActiveGroupResp_DateCountEntry_DoNotUseDefaultTypeInternal;
extern GetActiveGroupResp_DateCountEntry_DoNotUseDefaultTypeInternal _GetActiveGroupResp_DateCountEntry_DoNotUse_default_instance_;
class GetActiveUserReq;
struct GetActiveUserReqDefaultTypeInternal;
extern GetActiveUserReqDefaultTypeInternal _GetActiveUserReq_default_instance_;
class GetActiveUserResp;
struct GetActiveUserRespDefaultTypeInternal;
extern GetActiveUserRespDefaultTypeInternal _GetActiveUserResp_default_instance_;
class GetActiveUserResp_DateCountEntry_DoNotUse;
struct GetActiveUserResp_DateCountEntry_DoNotUseDefaultTypeInternal;
extern GetActiveUserResp_DateCountEntry_DoNotUseDefaultTypeInternal _GetActiveUserResp_DateCountEntry_DoNotUse_default_instance_;
class GetConversationMaxSeqReq;
struct GetConversationMaxSeqReqDefaultTypeInternal;
extern GetConversationMaxSeqReqDefaultTypeInternal _GetConversationMaxSeqReq_default_instance_;
class GetConversationMaxSeqResp;
struct GetConversationMaxSeqRespDefaultTypeInternal;
extern GetConversationMaxSeqRespDefaultTypeInternal _GetConversationMaxSeqResp_default_instance_;
class GetConversationsHasReadAndMaxSeqReq;
struct GetConversationsHasReadAndMaxSeqReqDefaultTypeInternal;
extern GetConversationsHasReadAndMaxSeqReqDefaultTypeInternal _GetConversationsHasReadAndMaxSeqReq_default_instance_;
class GetConversationsHasReadAndMaxSeqResp;
struct GetConversationsHasReadAndMaxSeqRespDefaultTypeInternal;
extern GetConversationsHasReadAndMaxSeqRespDefaultTypeInternal _GetConversationsHasReadAndMaxSeqResp_default_instance_;
class GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse;
struct GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUseDefaultTypeInternal;
extern GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUseDefaultTypeInternal _GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse_default_instance_;
class GetHasReadSeqsReq;
struct GetHasReadSeqsReqDefaultTypeInternal;
extern GetHasReadSeqsReqDefaultTypeInternal _GetHasReadSeqsReq_default_instance_;
class GetLastMessageReq;
struct GetLastMessageReqDefaultTypeInternal;
extern GetLastMessageReqDefaultTypeInternal _GetLastMessageReq_default_instance_;
class GetLastMessageResp;
struct GetLastMessageRespDefaultTypeInternal;
extern GetLastMessageRespDefaultTypeInternal _GetLastMessageResp_default_instance_;
class GetLastMessageResp_MsgsEntry_DoNotUse;
struct GetLastMessageResp_MsgsEntry_DoNotUseDefaultTypeInternal;
extern GetLastMessageResp_MsgsEntry_DoNotUseDefaultTypeInternal _GetLastMessageResp_MsgsEntry_DoNotUse_default_instance_;
class GetLastMessageSeqByTimeReq;
struct GetLastMessageSeqByTimeReqDefaultTypeInternal;
extern GetLastMessageSeqByTimeReqDefaultTypeInternal _GetLastMessageSeqByTimeReq_default_instance_;
class GetLastMessageSeqByTimeResp;
struct GetLastMessageSeqByTimeRespDefaultTypeInternal;
extern GetLastMessageSeqByTimeRespDefaultTypeInternal _GetLastMessageSeqByTimeResp_default_instance_;
class GetMaxAndMinSeqReq;
struct GetMaxAndMinSeqReqDefaultTypeInternal;
extern GetMaxAndMinSeqReqDefaultTypeInternal _GetMaxAndMinSeqReq_default_instance_;
class GetMaxAndMinSeqResp;
struct GetMaxAndMinSeqRespDefaultTypeInternal;
extern GetMaxAndMinSeqRespDefaultTypeInternal _GetMaxAndMinSeqResp_default_instance_;
class GetMaxSeqsReq;
struct GetMaxSeqsReqDefaultTypeInternal;
extern GetMaxSeqsReqDefaultTypeInternal _GetMaxSeqsReq_default_instance_;
class GetMsgByConversationIDsReq;
struct GetMsgByConversationIDsReqDefaultTypeInternal;
extern GetMsgByConversationIDsReqDefaultTypeInternal _GetMsgByConversationIDsReq_default_instance_;
class GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse;
struct GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUseDefaultTypeInternal;
extern GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUseDefaultTypeInternal _GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse_default_instance_;
class GetMsgByConversationIDsResp;
struct GetMsgByConversationIDsRespDefaultTypeInternal;
extern GetMsgByConversationIDsRespDefaultTypeInternal _GetMsgByConversationIDsResp_default_instance_;
class GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse;
struct GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUseDefaultTypeInternal;
extern GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUseDefaultTypeInternal _GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse_default_instance_;
class GetSendMsgStatusReq;
struct GetSendMsgStatusReqDefaultTypeInternal;
extern GetSendMsgStatusReqDefaultTypeInternal _GetSendMsgStatusReq_default_instance_;
class GetSendMsgStatusResp;
struct GetSendMsgStatusRespDefaultTypeInternal;
extern GetSendMsgStatusRespDefaultTypeInternal _GetSendMsgStatusResp_default_instance_;
class GetSeqMessageReq;
struct GetSeqMessageReqDefaultTypeInternal;
extern GetSeqMessageReqDefaultTypeInternal _GetSeqMessageReq_default_instance_;
class GetSeqMessageResp;
struct GetSeqMessageRespDefaultTypeInternal;
extern GetSeqMessageRespDefaultTypeInternal _GetSeqMessageResp_default_instance_;
class GetSeqMessageResp_MsgsEntry_DoNotUse;
struct GetSeqMessageResp_MsgsEntry_DoNotUseDefaultTypeInternal;
extern GetSeqMessageResp_MsgsEntry_DoNotUseDefaultTypeInternal _GetSeqMessageResp_MsgsEntry_DoNotUse_default_instance_;
class GetSeqMessageResp_NotificationMsgsEntry_DoNotUse;
struct GetSeqMessageResp_NotificationMsgsEntry_DoNotUseDefaultTypeInternal;
extern GetSeqMessageResp_NotificationMsgsEntry_DoNotUseDefaultTypeInternal _GetSeqMessageResp_NotificationMsgsEntry_DoNotUse_default_instance_;
class GetServerTimeReq;
struct GetServerTimeReqDefaultTypeInternal;
extern GetServerTimeReqDefaultTypeInternal _GetServerTimeReq_default_instance_;
class GetServerTimeResp;
struct GetServerTimeRespDefaultTypeInternal;
extern GetServerTimeRespDefaultTypeInternal _GetServerTimeResp_default_instance_;
class MarkConversationAsReadReq;
struct MarkConversationAsReadReqDefaultTypeInternal;
extern MarkConversationAsReadReqDefaultTypeInternal _MarkConversationAsReadReq_default_instance_;
class MarkConversationAsReadResp;
struct MarkConversationAsReadRespDefaultTypeInternal;
extern MarkConversationAsReadRespDefaultTypeInternal _MarkConversationAsReadResp_default_instance_;
class MarkMsgsAsReadReq;
struct MarkMsgsAsReadReqDefaultTypeInternal;
extern MarkMsgsAsReadReqDefaultTypeInternal _MarkMsgsAsReadReq_default_instance_;
class MarkMsgsAsReadResp;
struct MarkMsgsAsReadRespDefaultTypeInternal;
extern MarkMsgsAsReadRespDefaultTypeInternal _MarkMsgsAsReadResp_default_instance_;
class MsgDataToDB;
struct MsgDataToDBDefaultTypeInternal;
extern MsgDataToDBDefaultTypeInternal _MsgDataToDB_default_instance_;
class MsgDataToMQ;
struct MsgDataToMQDefaultTypeInternal;
extern MsgDataToMQDefaultTypeInternal _MsgDataToMQ_default_instance_;
class MsgDataToModifyByMQ;
struct MsgDataToModifyByMQDefaultTypeInternal;
extern MsgDataToModifyByMQDefaultTypeInternal _MsgDataToModifyByMQ_default_instance_;
class MsgDataToMongoByMQ;
struct MsgDataToMongoByMQDefaultTypeInternal;
extern MsgDataToMongoByMQDefaultTypeInternal _MsgDataToMongoByMQ_default_instance_;
class PushMsgDataToMQ;
struct PushMsgDataToMQDefaultTypeInternal;
extern PushMsgDataToMQDefaultTypeInternal _PushMsgDataToMQ_default_instance_;
class RevokeMsgReq;
struct RevokeMsgReqDefaultTypeInternal;
extern RevokeMsgReqDefaultTypeInternal _RevokeMsgReq_default_instance_;
class RevokeMsgResp;
struct RevokeMsgRespDefaultTypeInternal;
extern RevokeMsgRespDefaultTypeInternal _RevokeMsgResp_default_instance_;
class SearchChatLog;
struct SearchChatLogDefaultTypeInternal;
extern SearchChatLogDefaultTypeInternal _SearchChatLog_default_instance_;
class SearchMessageReq;
struct SearchMessageReqDefaultTypeInternal;
extern SearchMessageReqDefaultTypeInternal _SearchMessageReq_default_instance_;
class SearchMessageResp;
struct SearchMessageRespDefaultTypeInternal;
extern SearchMessageRespDefaultTypeInternal _SearchMessageResp_default_instance_;
class SearchedMsgData;
struct SearchedMsgDataDefaultTypeInternal;
extern SearchedMsgDataDefaultTypeInternal _SearchedMsgData_default_instance_;
class SendMsgReq;
struct SendMsgReqDefaultTypeInternal;
extern SendMsgReqDefaultTypeInternal _SendMsgReq_default_instance_;
class SendMsgResp;
struct SendMsgRespDefaultTypeInternal;
extern SendMsgRespDefaultTypeInternal _SendMsgResp_default_instance_;
class SendSimpleMsgReq;
struct SendSimpleMsgReqDefaultTypeInternal;
extern SendSimpleMsgReqDefaultTypeInternal _SendSimpleMsgReq_default_instance_;
class SendSimpleMsgResp;
struct SendSimpleMsgRespDefaultTypeInternal;
extern SendSimpleMsgRespDefaultTypeInternal _SendSimpleMsgResp_default_instance_;
class Seqs;
struct SeqsDefaultTypeInternal;
extern SeqsDefaultTypeInternal _Seqs_default_instance_;
class SeqsInfoResp;
struct SeqsInfoRespDefaultTypeInternal;
extern SeqsInfoRespDefaultTypeInternal _SeqsInfoResp_default_instance_;
class SeqsInfoResp_MaxSeqsEntry_DoNotUse;
struct SeqsInfoResp_MaxSeqsEntry_DoNotUseDefaultTypeInternal;
extern SeqsInfoResp_MaxSeqsEntry_DoNotUseDefaultTypeInternal _SeqsInfoResp_MaxSeqsEntry_DoNotUse_default_instance_;
class SetConversationHasReadSeqReq;
struct SetConversationHasReadSeqReqDefaultTypeInternal;
extern SetConversationHasReadSeqReqDefaultTypeInternal _SetConversationHasReadSeqReq_default_instance_;
class SetConversationHasReadSeqResp;
struct SetConversationHasReadSeqRespDefaultTypeInternal;
extern SetConversationHasReadSeqRespDefaultTypeInternal _SetConversationHasReadSeqResp_default_instance_;
class SetSendMsgStatusReq;
struct SetSendMsgStatusReqDefaultTypeInternal;
extern SetSendMsgStatusReqDefaultTypeInternal _SetSendMsgStatusReq_default_instance_;
class SetSendMsgStatusResp;
struct SetSendMsgStatusRespDefaultTypeInternal;
extern SetSendMsgStatusRespDefaultTypeInternal _SetSendMsgStatusResp_default_instance_;
class SetUserConversationMaxSeqReq;
struct SetUserConversationMaxSeqReqDefaultTypeInternal;
extern SetUserConversationMaxSeqReqDefaultTypeInternal _SetUserConversationMaxSeqReq_default_instance_;
class SetUserConversationMaxSeqResp;
struct SetUserConversationMaxSeqRespDefaultTypeInternal;
extern SetUserConversationMaxSeqRespDefaultTypeInternal _SetUserConversationMaxSeqResp_default_instance_;
class SetUserConversationMinSeqReq;
struct SetUserConversationMinSeqReqDefaultTypeInternal;
extern SetUserConversationMinSeqReqDefaultTypeInternal _SetUserConversationMinSeqReq_default_instance_;
class SetUserConversationMinSeqResp;
struct SetUserConversationMinSeqRespDefaultTypeInternal;
extern SetUserConversationMinSeqRespDefaultTypeInternal _SetUserConversationMinSeqResp_default_instance_;
class SetUserConversationsMinSeqReq;
struct SetUserConversationsMinSeqReqDefaultTypeInternal;
extern SetUserConversationsMinSeqReqDefaultTypeInternal _SetUserConversationsMinSeqReq_default_instance_;
class SetUserConversationsMinSeqResp;
struct SetUserConversationsMinSeqRespDefaultTypeInternal;
extern SetUserConversationsMinSeqRespDefaultTypeInternal _SetUserConversationsMinSeqResp_default_instance_;
class UserClearAllMsgReq;
struct UserClearAllMsgReqDefaultTypeInternal;
extern UserClearAllMsgReqDefaultTypeInternal _UserClearAllMsgReq_default_instance_;
class UserClearAllMsgResp;
struct UserClearAllMsgRespDefaultTypeInternal;
extern UserClearAllMsgRespDefaultTypeInternal _UserClearAllMsgResp_default_instance_;
class batchSendMessageReq;
struct batchSendMessageReqDefaultTypeInternal;
extern batchSendMessageReqDefaultTypeInternal _batchSendMessageReq_default_instance_;
class batchSendMessageResp;
struct batchSendMessageRespDefaultTypeInternal;
extern batchSendMessageRespDefaultTypeInternal _batchSendMessageResp_default_instance_;
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template<> ::msg::ActiveConversation* Arena::CreateMaybeMessage<::msg::ActiveConversation>(Arena*);
template<> ::msg::ActiveGroup* Arena::CreateMaybeMessage<::msg::ActiveGroup>(Arena*);
template<> ::msg::ActiveUser* Arena::CreateMaybeMessage<::msg::ActiveUser>(Arena*);
template<> ::msg::ChatLog* Arena::CreateMaybeMessage<::msg::ChatLog>(Arena*);
template<> ::msg::ClearConversationsMsgReq* Arena::CreateMaybeMessage<::msg::ClearConversationsMsgReq>(Arena*);
template<> ::msg::ClearConversationsMsgResp* Arena::CreateMaybeMessage<::msg::ClearConversationsMsgResp>(Arena*);
template<> ::msg::ClearMsgReq* Arena::CreateMaybeMessage<::msg::ClearMsgReq>(Arena*);
template<> ::msg::ClearMsgResp* Arena::CreateMaybeMessage<::msg::ClearMsgResp>(Arena*);
template<> ::msg::ConversationSeqs* Arena::CreateMaybeMessage<::msg::ConversationSeqs>(Arena*);
template<> ::msg::DelMsgsReq* Arena::CreateMaybeMessage<::msg::DelMsgsReq>(Arena*);
template<> ::msg::DelMsgsResp* Arena::CreateMaybeMessage<::msg::DelMsgsResp>(Arena*);
template<> ::msg::DeleteMsgPhysicalBySeqReq* Arena::CreateMaybeMessage<::msg::DeleteMsgPhysicalBySeqReq>(Arena*);
template<> ::msg::DeleteMsgPhysicalBySeqResp* Arena::CreateMaybeMessage<::msg::DeleteMsgPhysicalBySeqResp>(Arena*);
template<> ::msg::DeleteMsgPhysicalReq* Arena::CreateMaybeMessage<::msg::DeleteMsgPhysicalReq>(Arena*);
template<> ::msg::DeleteMsgPhysicalResp* Arena::CreateMaybeMessage<::msg::DeleteMsgPhysicalResp>(Arena*);
template<> ::msg::DeleteMsgsReq* Arena::CreateMaybeMessage<::msg::DeleteMsgsReq>(Arena*);
template<> ::msg::DeleteMsgsResp* Arena::CreateMaybeMessage<::msg::DeleteMsgsResp>(Arena*);
template<> ::msg::DeleteSyncOpt* Arena::CreateMaybeMessage<::msg::DeleteSyncOpt>(Arena*);
template<> ::msg::DestructMsgsReq* Arena::CreateMaybeMessage<::msg::DestructMsgsReq>(Arena*);
template<> ::msg::DestructMsgsResp* Arena::CreateMaybeMessage<::msg::DestructMsgsResp>(Arena*);
template<> ::msg::GetActiveConversationReq* Arena::CreateMaybeMessage<::msg::GetActiveConversationReq>(Arena*);
template<> ::msg::GetActiveConversationResp* Arena::CreateMaybeMessage<::msg::GetActiveConversationResp>(Arena*);
template<> ::msg::GetActiveGroupReq* Arena::CreateMaybeMessage<::msg::GetActiveGroupReq>(Arena*);
template<> ::msg::GetActiveGroupResp* Arena::CreateMaybeMessage<::msg::GetActiveGroupResp>(Arena*);
template<> ::msg::GetActiveGroupResp_DateCountEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetActiveGroupResp_DateCountEntry_DoNotUse>(Arena*);
template<> ::msg::GetActiveUserReq* Arena::CreateMaybeMessage<::msg::GetActiveUserReq>(Arena*);
template<> ::msg::GetActiveUserResp* Arena::CreateMaybeMessage<::msg::GetActiveUserResp>(Arena*);
template<> ::msg::GetActiveUserResp_DateCountEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetActiveUserResp_DateCountEntry_DoNotUse>(Arena*);
template<> ::msg::GetConversationMaxSeqReq* Arena::CreateMaybeMessage<::msg::GetConversationMaxSeqReq>(Arena*);
template<> ::msg::GetConversationMaxSeqResp* Arena::CreateMaybeMessage<::msg::GetConversationMaxSeqResp>(Arena*);
template<> ::msg::GetConversationsHasReadAndMaxSeqReq* Arena::CreateMaybeMessage<::msg::GetConversationsHasReadAndMaxSeqReq>(Arena*);
template<> ::msg::GetConversationsHasReadAndMaxSeqResp* Arena::CreateMaybeMessage<::msg::GetConversationsHasReadAndMaxSeqResp>(Arena*);
template<> ::msg::GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse>(Arena*);
template<> ::msg::GetHasReadSeqsReq* Arena::CreateMaybeMessage<::msg::GetHasReadSeqsReq>(Arena*);
template<> ::msg::GetLastMessageReq* Arena::CreateMaybeMessage<::msg::GetLastMessageReq>(Arena*);
template<> ::msg::GetLastMessageResp* Arena::CreateMaybeMessage<::msg::GetLastMessageResp>(Arena*);
template<> ::msg::GetLastMessageResp_MsgsEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetLastMessageResp_MsgsEntry_DoNotUse>(Arena*);
template<> ::msg::GetLastMessageSeqByTimeReq* Arena::CreateMaybeMessage<::msg::GetLastMessageSeqByTimeReq>(Arena*);
template<> ::msg::GetLastMessageSeqByTimeResp* Arena::CreateMaybeMessage<::msg::GetLastMessageSeqByTimeResp>(Arena*);
template<> ::msg::GetMaxAndMinSeqReq* Arena::CreateMaybeMessage<::msg::GetMaxAndMinSeqReq>(Arena*);
template<> ::msg::GetMaxAndMinSeqResp* Arena::CreateMaybeMessage<::msg::GetMaxAndMinSeqResp>(Arena*);
template<> ::msg::GetMaxSeqsReq* Arena::CreateMaybeMessage<::msg::GetMaxSeqsReq>(Arena*);
template<> ::msg::GetMsgByConversationIDsReq* Arena::CreateMaybeMessage<::msg::GetMsgByConversationIDsReq>(Arena*);
template<> ::msg::GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse>(Arena*);
template<> ::msg::GetMsgByConversationIDsResp* Arena::CreateMaybeMessage<::msg::GetMsgByConversationIDsResp>(Arena*);
template<> ::msg::GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse>(Arena*);
template<> ::msg::GetSendMsgStatusReq* Arena::CreateMaybeMessage<::msg::GetSendMsgStatusReq>(Arena*);
template<> ::msg::GetSendMsgStatusResp* Arena::CreateMaybeMessage<::msg::GetSendMsgStatusResp>(Arena*);
template<> ::msg::GetSeqMessageReq* Arena::CreateMaybeMessage<::msg::GetSeqMessageReq>(Arena*);
template<> ::msg::GetSeqMessageResp* Arena::CreateMaybeMessage<::msg::GetSeqMessageResp>(Arena*);
template<> ::msg::GetSeqMessageResp_MsgsEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetSeqMessageResp_MsgsEntry_DoNotUse>(Arena*);
template<> ::msg::GetSeqMessageResp_NotificationMsgsEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::GetSeqMessageResp_NotificationMsgsEntry_DoNotUse>(Arena*);
template<> ::msg::GetServerTimeReq* Arena::CreateMaybeMessage<::msg::GetServerTimeReq>(Arena*);
template<> ::msg::GetServerTimeResp* Arena::CreateMaybeMessage<::msg::GetServerTimeResp>(Arena*);
template<> ::msg::MarkConversationAsReadReq* Arena::CreateMaybeMessage<::msg::MarkConversationAsReadReq>(Arena*);
template<> ::msg::MarkConversationAsReadResp* Arena::CreateMaybeMessage<::msg::MarkConversationAsReadResp>(Arena*);
template<> ::msg::MarkMsgsAsReadReq* Arena::CreateMaybeMessage<::msg::MarkMsgsAsReadReq>(Arena*);
template<> ::msg::MarkMsgsAsReadResp* Arena::CreateMaybeMessage<::msg::MarkMsgsAsReadResp>(Arena*);
template<> ::msg::MsgDataToDB* Arena::CreateMaybeMessage<::msg::MsgDataToDB>(Arena*);
template<> ::msg::MsgDataToMQ* Arena::CreateMaybeMessage<::msg::MsgDataToMQ>(Arena*);
template<> ::msg::MsgDataToModifyByMQ* Arena::CreateMaybeMessage<::msg::MsgDataToModifyByMQ>(Arena*);
template<> ::msg::MsgDataToMongoByMQ* Arena::CreateMaybeMessage<::msg::MsgDataToMongoByMQ>(Arena*);
template<> ::msg::PushMsgDataToMQ* Arena::CreateMaybeMessage<::msg::PushMsgDataToMQ>(Arena*);
template<> ::msg::RevokeMsgReq* Arena::CreateMaybeMessage<::msg::RevokeMsgReq>(Arena*);
template<> ::msg::RevokeMsgResp* Arena::CreateMaybeMessage<::msg::RevokeMsgResp>(Arena*);
template<> ::msg::SearchChatLog* Arena::CreateMaybeMessage<::msg::SearchChatLog>(Arena*);
template<> ::msg::SearchMessageReq* Arena::CreateMaybeMessage<::msg::SearchMessageReq>(Arena*);
template<> ::msg::SearchMessageResp* Arena::CreateMaybeMessage<::msg::SearchMessageResp>(Arena*);
template<> ::msg::SearchedMsgData* Arena::CreateMaybeMessage<::msg::SearchedMsgData>(Arena*);
template<> ::msg::SendMsgReq* Arena::CreateMaybeMessage<::msg::SendMsgReq>(Arena*);
template<> ::msg::SendMsgResp* Arena::CreateMaybeMessage<::msg::SendMsgResp>(Arena*);
template<> ::msg::SendSimpleMsgReq* Arena::CreateMaybeMessage<::msg::SendSimpleMsgReq>(Arena*);
template<> ::msg::SendSimpleMsgResp* Arena::CreateMaybeMessage<::msg::SendSimpleMsgResp>(Arena*);
template<> ::msg::Seqs* Arena::CreateMaybeMessage<::msg::Seqs>(Arena*);
template<> ::msg::SeqsInfoResp* Arena::CreateMaybeMessage<::msg::SeqsInfoResp>(Arena*);
template<> ::msg::SeqsInfoResp_MaxSeqsEntry_DoNotUse* Arena::CreateMaybeMessage<::msg::SeqsInfoResp_MaxSeqsEntry_DoNotUse>(Arena*);
template<> ::msg::SetConversationHasReadSeqReq* Arena::CreateMaybeMessage<::msg::SetConversationHasReadSeqReq>(Arena*);
template<> ::msg::SetConversationHasReadSeqResp* Arena::CreateMaybeMessage<::msg::SetConversationHasReadSeqResp>(Arena*);
template<> ::msg::SetSendMsgStatusReq* Arena::CreateMaybeMessage<::msg::SetSendMsgStatusReq>(Arena*);
template<> ::msg::SetSendMsgStatusResp* Arena::CreateMaybeMessage<::msg::SetSendMsgStatusResp>(Arena*);
template<> ::msg::SetUserConversationMaxSeqReq* Arena::CreateMaybeMessage<::msg::SetUserConversationMaxSeqReq>(Arena*);
template<> ::msg::SetUserConversationMaxSeqResp* Arena::CreateMaybeMessage<::msg::SetUserConversationMaxSeqResp>(Arena*);
template<> ::msg::SetUserConversationMinSeqReq* Arena::CreateMaybeMessage<::msg::SetUserConversationMinSeqReq>(Arena*);
template<> ::msg::SetUserConversationMinSeqResp* Arena::CreateMaybeMessage<::msg::SetUserConversationMinSeqResp>(Arena*);
template<> ::msg::SetUserConversationsMinSeqReq* Arena::CreateMaybeMessage<::msg::SetUserConversationsMinSeqReq>(Arena*);
template<> ::msg::SetUserConversationsMinSeqResp* Arena::CreateMaybeMessage<::msg::SetUserConversationsMinSeqResp>(Arena*);
template<> ::msg::UserClearAllMsgReq* Arena::CreateMaybeMessage<::msg::UserClearAllMsgReq>(Arena*);
template<> ::msg::UserClearAllMsgResp* Arena::CreateMaybeMessage<::msg::UserClearAllMsgResp>(Arena*);
template<> ::msg::batchSendMessageReq* Arena::CreateMaybeMessage<::msg::batchSendMessageReq>(Arena*);
template<> ::msg::batchSendMessageResp* Arena::CreateMaybeMessage<::msg::batchSendMessageResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace msg {

// ===================================================================

class MsgDataToMQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MsgDataToMQ) */ {
 public:
  inline MsgDataToMQ() : MsgDataToMQ(nullptr) {}
  ~MsgDataToMQ() override;
  explicit PROTOBUF_CONSTEXPR MsgDataToMQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataToMQ(const MsgDataToMQ& from);
  MsgDataToMQ(MsgDataToMQ&& from) noexcept
    : MsgDataToMQ() {
    *this = ::std::move(from);
  }

  inline MsgDataToMQ& operator=(const MsgDataToMQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataToMQ& operator=(MsgDataToMQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDataToMQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataToMQ* internal_default_instance() {
    return reinterpret_cast<const MsgDataToMQ*>(
               &_MsgDataToMQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgDataToMQ& a, MsgDataToMQ& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataToMQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataToMQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataToMQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataToMQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgDataToMQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgDataToMQ& from) {
    MsgDataToMQ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgDataToMQ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MsgDataToMQ";
  }
  protected:
  explicit MsgDataToMQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kMsgDataFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .sdkws.MsgData msgData = 2;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // @@protoc_insertion_point(class_scope:msg.MsgDataToMQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::sdkws::MsgData* msgdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MsgDataToDB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MsgDataToDB) */ {
 public:
  inline MsgDataToDB() : MsgDataToDB(nullptr) {}
  ~MsgDataToDB() override;
  explicit PROTOBUF_CONSTEXPR MsgDataToDB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataToDB(const MsgDataToDB& from);
  MsgDataToDB(MsgDataToDB&& from) noexcept
    : MsgDataToDB() {
    *this = ::std::move(from);
  }

  inline MsgDataToDB& operator=(const MsgDataToDB& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataToDB& operator=(MsgDataToDB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDataToDB& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataToDB* internal_default_instance() {
    return reinterpret_cast<const MsgDataToDB*>(
               &_MsgDataToDB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgDataToDB& a, MsgDataToDB& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataToDB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataToDB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataToDB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataToDB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgDataToDB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgDataToDB& from) {
    MsgDataToDB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgDataToDB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MsgDataToDB";
  }
  protected:
  explicit MsgDataToDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 1,
  };
  // .sdkws.MsgData msgData = 1;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // @@protoc_insertion_point(class_scope:msg.MsgDataToDB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::MsgData* msgdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PushMsgDataToMQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.PushMsgDataToMQ) */ {
 public:
  inline PushMsgDataToMQ() : PushMsgDataToMQ(nullptr) {}
  ~PushMsgDataToMQ() override;
  explicit PROTOBUF_CONSTEXPR PushMsgDataToMQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushMsgDataToMQ(const PushMsgDataToMQ& from);
  PushMsgDataToMQ(PushMsgDataToMQ&& from) noexcept
    : PushMsgDataToMQ() {
    *this = ::std::move(from);
  }

  inline PushMsgDataToMQ& operator=(const PushMsgDataToMQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushMsgDataToMQ& operator=(PushMsgDataToMQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushMsgDataToMQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushMsgDataToMQ* internal_default_instance() {
    return reinterpret_cast<const PushMsgDataToMQ*>(
               &_PushMsgDataToMQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PushMsgDataToMQ& a, PushMsgDataToMQ& b) {
    a.Swap(&b);
  }
  inline void Swap(PushMsgDataToMQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushMsgDataToMQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushMsgDataToMQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushMsgDataToMQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushMsgDataToMQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushMsgDataToMQ& from) {
    PushMsgDataToMQ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushMsgDataToMQ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushMsgDataToMQ";
  }
  protected:
  explicit PushMsgDataToMQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 2,
    kMsgDataFieldNumber = 1,
  };
  // string conversationID = 2;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // .sdkws.MsgData msgData = 1;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // @@protoc_insertion_point(class_scope:msg.PushMsgDataToMQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::sdkws::MsgData* msgdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MsgDataToMongoByMQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MsgDataToMongoByMQ) */ {
 public:
  inline MsgDataToMongoByMQ() : MsgDataToMongoByMQ(nullptr) {}
  ~MsgDataToMongoByMQ() override;
  explicit PROTOBUF_CONSTEXPR MsgDataToMongoByMQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataToMongoByMQ(const MsgDataToMongoByMQ& from);
  MsgDataToMongoByMQ(MsgDataToMongoByMQ&& from) noexcept
    : MsgDataToMongoByMQ() {
    *this = ::std::move(from);
  }

  inline MsgDataToMongoByMQ& operator=(const MsgDataToMongoByMQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataToMongoByMQ& operator=(MsgDataToMongoByMQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDataToMongoByMQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataToMongoByMQ* internal_default_instance() {
    return reinterpret_cast<const MsgDataToMongoByMQ*>(
               &_MsgDataToMongoByMQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgDataToMongoByMQ& a, MsgDataToMongoByMQ& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataToMongoByMQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataToMongoByMQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataToMongoByMQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataToMongoByMQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgDataToMongoByMQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgDataToMongoByMQ& from) {
    MsgDataToMongoByMQ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgDataToMongoByMQ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MsgDataToMongoByMQ";
  }
  protected:
  explicit MsgDataToMongoByMQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 3,
    kConversationIDFieldNumber = 2,
    kLastSeqFieldNumber = 1,
  };
  // repeated .sdkws.MsgData msgData = 3;
  int msgdata_size() const;
  private:
  int _internal_msgdata_size() const;
  public:
  void clear_msgdata();
  ::sdkws::MsgData* mutable_msgdata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >*
      mutable_msgdata();
  private:
  const ::sdkws::MsgData& _internal_msgdata(int index) const;
  ::sdkws::MsgData* _internal_add_msgdata();
  public:
  const ::sdkws::MsgData& msgdata(int index) const;
  ::sdkws::MsgData* add_msgdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >&
      msgdata() const;

  // string conversationID = 2;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 lastSeq = 1;
  void clear_lastseq();
  int64_t lastseq() const;
  void set_lastseq(int64_t value);
  private:
  int64_t _internal_lastseq() const;
  void _internal_set_lastseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.MsgDataToMongoByMQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData > msgdata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t lastseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetMaxAndMinSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetMaxAndMinSeqReq) */ {
 public:
  inline GetMaxAndMinSeqReq() : GetMaxAndMinSeqReq(nullptr) {}
  ~GetMaxAndMinSeqReq() override;
  explicit PROTOBUF_CONSTEXPR GetMaxAndMinSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMaxAndMinSeqReq(const GetMaxAndMinSeqReq& from);
  GetMaxAndMinSeqReq(GetMaxAndMinSeqReq&& from) noexcept
    : GetMaxAndMinSeqReq() {
    *this = ::std::move(from);
  }

  inline GetMaxAndMinSeqReq& operator=(const GetMaxAndMinSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMaxAndMinSeqReq& operator=(GetMaxAndMinSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMaxAndMinSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMaxAndMinSeqReq* internal_default_instance() {
    return reinterpret_cast<const GetMaxAndMinSeqReq*>(
               &_GetMaxAndMinSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetMaxAndMinSeqReq& a, GetMaxAndMinSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMaxAndMinSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMaxAndMinSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMaxAndMinSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMaxAndMinSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMaxAndMinSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMaxAndMinSeqReq& from) {
    GetMaxAndMinSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMaxAndMinSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetMaxAndMinSeqReq";
  }
  protected:
  explicit GetMaxAndMinSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string UserID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:msg.GetMaxAndMinSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetMaxAndMinSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetMaxAndMinSeqResp) */ {
 public:
  inline GetMaxAndMinSeqResp() : GetMaxAndMinSeqResp(nullptr) {}
  ~GetMaxAndMinSeqResp() override;
  explicit PROTOBUF_CONSTEXPR GetMaxAndMinSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMaxAndMinSeqResp(const GetMaxAndMinSeqResp& from);
  GetMaxAndMinSeqResp(GetMaxAndMinSeqResp&& from) noexcept
    : GetMaxAndMinSeqResp() {
    *this = ::std::move(from);
  }

  inline GetMaxAndMinSeqResp& operator=(const GetMaxAndMinSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMaxAndMinSeqResp& operator=(GetMaxAndMinSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMaxAndMinSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMaxAndMinSeqResp* internal_default_instance() {
    return reinterpret_cast<const GetMaxAndMinSeqResp*>(
               &_GetMaxAndMinSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetMaxAndMinSeqResp& a, GetMaxAndMinSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMaxAndMinSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMaxAndMinSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMaxAndMinSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMaxAndMinSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMaxAndMinSeqResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMaxAndMinSeqResp& from) {
    GetMaxAndMinSeqResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMaxAndMinSeqResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetMaxAndMinSeqResp";
  }
  protected:
  explicit GetMaxAndMinSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxSeqFieldNumber = 1,
    kMinSeqFieldNumber = 2,
  };
  // int64 MaxSeq = 1;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // int64 MinSeq = 2;
  void clear_minseq();
  int64_t minseq() const;
  void set_minseq(int64_t value);
  private:
  int64_t _internal_minseq() const;
  void _internal_set_minseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetMaxAndMinSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t maxseq_;
    int64_t minseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SendMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SendMsgReq) */ {
 public:
  inline SendMsgReq() : SendMsgReq(nullptr) {}
  ~SendMsgReq() override;
  explicit PROTOBUF_CONSTEXPR SendMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMsgReq(const SendMsgReq& from);
  SendMsgReq(SendMsgReq&& from) noexcept
    : SendMsgReq() {
    *this = ::std::move(from);
  }

  inline SendMsgReq& operator=(const SendMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMsgReq& operator=(SendMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMsgReq* internal_default_instance() {
    return reinterpret_cast<const SendMsgReq*>(
               &_SendMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SendMsgReq& a, SendMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMsgReq& from) {
    SendMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SendMsgReq";
  }
  protected:
  explicit SendMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 3,
  };
  // .sdkws.MsgData msgData = 3;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // @@protoc_insertion_point(class_scope:msg.SendMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::MsgData* msgdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SendMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SendMsgResp) */ {
 public:
  inline SendMsgResp() : SendMsgResp(nullptr) {}
  ~SendMsgResp() override;
  explicit PROTOBUF_CONSTEXPR SendMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMsgResp(const SendMsgResp& from);
  SendMsgResp(SendMsgResp&& from) noexcept
    : SendMsgResp() {
    *this = ::std::move(from);
  }

  inline SendMsgResp& operator=(const SendMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMsgResp& operator=(SendMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMsgResp* internal_default_instance() {
    return reinterpret_cast<const SendMsgResp*>(
               &_SendMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SendMsgResp& a, SendMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMsgResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMsgResp& from) {
    SendMsgResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMsgResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SendMsgResp";
  }
  protected:
  explicit SendMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerMsgIDFieldNumber = 1,
    kClientMsgIDFieldNumber = 2,
    kModifyFieldNumber = 4,
    kSendTimeFieldNumber = 3,
  };
  // string serverMsgID = 1;
  void clear_servermsgid();
  const std::string& servermsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servermsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servermsgid();
  PROTOBUF_NODISCARD std::string* release_servermsgid();
  void set_allocated_servermsgid(std::string* servermsgid);
  private:
  const std::string& _internal_servermsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servermsgid(const std::string& value);
  std::string* _internal_mutable_servermsgid();
  public:

  // string clientMsgID = 2;
  void clear_clientmsgid();
  const std::string& clientmsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientmsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientmsgid();
  PROTOBUF_NODISCARD std::string* release_clientmsgid();
  void set_allocated_clientmsgid(std::string* clientmsgid);
  private:
  const std::string& _internal_clientmsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientmsgid(const std::string& value);
  std::string* _internal_mutable_clientmsgid();
  public:

  // .sdkws.MsgData modify = 4;
  bool has_modify() const;
  private:
  bool _internal_has_modify() const;
  public:
  void clear_modify();
  const ::sdkws::MsgData& modify() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_modify();
  ::sdkws::MsgData* mutable_modify();
  void set_allocated_modify(::sdkws::MsgData* modify);
  private:
  const ::sdkws::MsgData& _internal_modify() const;
  ::sdkws::MsgData* _internal_mutable_modify();
  public:
  void unsafe_arena_set_allocated_modify(
      ::sdkws::MsgData* modify);
  ::sdkws::MsgData* unsafe_arena_release_modify();

  // int64 sendTime = 3;
  void clear_sendtime();
  int64_t sendtime() const;
  void set_sendtime(int64_t value);
  private:
  int64_t _internal_sendtime() const;
  void _internal_set_sendtime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SendMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servermsgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientmsgid_;
    ::sdkws::MsgData* modify_;
    int64_t sendtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SendSimpleMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SendSimpleMsgReq) */ {
 public:
  inline SendSimpleMsgReq() : SendSimpleMsgReq(nullptr) {}
  ~SendSimpleMsgReq() override;
  explicit PROTOBUF_CONSTEXPR SendSimpleMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendSimpleMsgReq(const SendSimpleMsgReq& from);
  SendSimpleMsgReq(SendSimpleMsgReq&& from) noexcept
    : SendSimpleMsgReq() {
    *this = ::std::move(from);
  }

  inline SendSimpleMsgReq& operator=(const SendSimpleMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendSimpleMsgReq& operator=(SendSimpleMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendSimpleMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendSimpleMsgReq* internal_default_instance() {
    return reinterpret_cast<const SendSimpleMsgReq*>(
               &_SendSimpleMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SendSimpleMsgReq& a, SendSimpleMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SendSimpleMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendSimpleMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendSimpleMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendSimpleMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendSimpleMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendSimpleMsgReq& from) {
    SendSimpleMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendSimpleMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SendSimpleMsgReq";
  }
  protected:
  explicit SendSimpleMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 3,
  };
  // .sdkws.MsgData msgData = 3;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // @@protoc_insertion_point(class_scope:msg.SendSimpleMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::MsgData* msgdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SendSimpleMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SendSimpleMsgResp) */ {
 public:
  inline SendSimpleMsgResp() : SendSimpleMsgResp(nullptr) {}
  ~SendSimpleMsgResp() override;
  explicit PROTOBUF_CONSTEXPR SendSimpleMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendSimpleMsgResp(const SendSimpleMsgResp& from);
  SendSimpleMsgResp(SendSimpleMsgResp&& from) noexcept
    : SendSimpleMsgResp() {
    *this = ::std::move(from);
  }

  inline SendSimpleMsgResp& operator=(const SendSimpleMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendSimpleMsgResp& operator=(SendSimpleMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendSimpleMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendSimpleMsgResp* internal_default_instance() {
    return reinterpret_cast<const SendSimpleMsgResp*>(
               &_SendSimpleMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SendSimpleMsgResp& a, SendSimpleMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SendSimpleMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendSimpleMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendSimpleMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendSimpleMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendSimpleMsgResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendSimpleMsgResp& from) {
    SendSimpleMsgResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendSimpleMsgResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SendSimpleMsgResp";
  }
  protected:
  explicit SendSimpleMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerMsgIDFieldNumber = 1,
    kClientMsgIDFieldNumber = 2,
    kModifyFieldNumber = 4,
    kSendTimeFieldNumber = 3,
  };
  // string serverMsgID = 1;
  void clear_servermsgid();
  const std::string& servermsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servermsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servermsgid();
  PROTOBUF_NODISCARD std::string* release_servermsgid();
  void set_allocated_servermsgid(std::string* servermsgid);
  private:
  const std::string& _internal_servermsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servermsgid(const std::string& value);
  std::string* _internal_mutable_servermsgid();
  public:

  // string clientMsgID = 2;
  void clear_clientmsgid();
  const std::string& clientmsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientmsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientmsgid();
  PROTOBUF_NODISCARD std::string* release_clientmsgid();
  void set_allocated_clientmsgid(std::string* clientmsgid);
  private:
  const std::string& _internal_clientmsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientmsgid(const std::string& value);
  std::string* _internal_mutable_clientmsgid();
  public:

  // .sdkws.MsgData modify = 4;
  bool has_modify() const;
  private:
  bool _internal_has_modify() const;
  public:
  void clear_modify();
  const ::sdkws::MsgData& modify() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_modify();
  ::sdkws::MsgData* mutable_modify();
  void set_allocated_modify(::sdkws::MsgData* modify);
  private:
  const ::sdkws::MsgData& _internal_modify() const;
  ::sdkws::MsgData* _internal_mutable_modify();
  public:
  void unsafe_arena_set_allocated_modify(
      ::sdkws::MsgData* modify);
  ::sdkws::MsgData* unsafe_arena_release_modify();

  // int64 sendTime = 3;
  void clear_sendtime();
  int64_t sendtime() const;
  void set_sendtime(int64_t value);
  private:
  int64_t _internal_sendtime() const;
  void _internal_set_sendtime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SendSimpleMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servermsgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientmsgid_;
    ::sdkws::MsgData* modify_;
    int64_t sendtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetSendMsgStatusReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SetSendMsgStatusReq) */ {
 public:
  inline SetSendMsgStatusReq() : SetSendMsgStatusReq(nullptr) {}
  ~SetSendMsgStatusReq() override;
  explicit PROTOBUF_CONSTEXPR SetSendMsgStatusReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSendMsgStatusReq(const SetSendMsgStatusReq& from);
  SetSendMsgStatusReq(SetSendMsgStatusReq&& from) noexcept
    : SetSendMsgStatusReq() {
    *this = ::std::move(from);
  }

  inline SetSendMsgStatusReq& operator=(const SetSendMsgStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSendMsgStatusReq& operator=(SetSendMsgStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSendMsgStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSendMsgStatusReq* internal_default_instance() {
    return reinterpret_cast<const SetSendMsgStatusReq*>(
               &_SetSendMsgStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetSendMsgStatusReq& a, SetSendMsgStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSendMsgStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSendMsgStatusReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSendMsgStatusReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSendMsgStatusReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSendMsgStatusReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSendMsgStatusReq& from) {
    SetSendMsgStatusReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSendMsgStatusReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetSendMsgStatusReq";
  }
  protected:
  explicit SetSendMsgStatusReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SetSendMsgStatusReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetSendMsgStatusResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.SetSendMsgStatusResp) */ {
 public:
  inline SetSendMsgStatusResp() : SetSendMsgStatusResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetSendMsgStatusResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSendMsgStatusResp(const SetSendMsgStatusResp& from);
  SetSendMsgStatusResp(SetSendMsgStatusResp&& from) noexcept
    : SetSendMsgStatusResp() {
    *this = ::std::move(from);
  }

  inline SetSendMsgStatusResp& operator=(const SetSendMsgStatusResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSendMsgStatusResp& operator=(SetSendMsgStatusResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSendMsgStatusResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSendMsgStatusResp* internal_default_instance() {
    return reinterpret_cast<const SetSendMsgStatusResp*>(
               &_SetSendMsgStatusResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetSendMsgStatusResp& a, SetSendMsgStatusResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSendMsgStatusResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSendMsgStatusResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSendMsgStatusResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSendMsgStatusResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetSendMsgStatusResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetSendMsgStatusResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetSendMsgStatusResp";
  }
  protected:
  explicit SetSendMsgStatusResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.SetSendMsgStatusResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetSendMsgStatusReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.GetSendMsgStatusReq) */ {
 public:
  inline GetSendMsgStatusReq() : GetSendMsgStatusReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSendMsgStatusReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSendMsgStatusReq(const GetSendMsgStatusReq& from);
  GetSendMsgStatusReq(GetSendMsgStatusReq&& from) noexcept
    : GetSendMsgStatusReq() {
    *this = ::std::move(from);
  }

  inline GetSendMsgStatusReq& operator=(const GetSendMsgStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSendMsgStatusReq& operator=(GetSendMsgStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSendMsgStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSendMsgStatusReq* internal_default_instance() {
    return reinterpret_cast<const GetSendMsgStatusReq*>(
               &_GetSendMsgStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetSendMsgStatusReq& a, GetSendMsgStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSendMsgStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSendMsgStatusReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSendMsgStatusReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSendMsgStatusReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSendMsgStatusReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSendMsgStatusReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetSendMsgStatusReq";
  }
  protected:
  explicit GetSendMsgStatusReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.GetSendMsgStatusReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetSendMsgStatusResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetSendMsgStatusResp) */ {
 public:
  inline GetSendMsgStatusResp() : GetSendMsgStatusResp(nullptr) {}
  ~GetSendMsgStatusResp() override;
  explicit PROTOBUF_CONSTEXPR GetSendMsgStatusResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSendMsgStatusResp(const GetSendMsgStatusResp& from);
  GetSendMsgStatusResp(GetSendMsgStatusResp&& from) noexcept
    : GetSendMsgStatusResp() {
    *this = ::std::move(from);
  }

  inline GetSendMsgStatusResp& operator=(const GetSendMsgStatusResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSendMsgStatusResp& operator=(GetSendMsgStatusResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSendMsgStatusResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSendMsgStatusResp* internal_default_instance() {
    return reinterpret_cast<const GetSendMsgStatusResp*>(
               &_GetSendMsgStatusResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetSendMsgStatusResp& a, GetSendMsgStatusResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSendMsgStatusResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSendMsgStatusResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSendMsgStatusResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSendMsgStatusResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSendMsgStatusResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSendMsgStatusResp& from) {
    GetSendMsgStatusResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSendMsgStatusResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetSendMsgStatusResp";
  }
  protected:
  explicit GetSendMsgStatusResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetSendMsgStatusResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MsgDataToModifyByMQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MsgDataToModifyByMQ) */ {
 public:
  inline MsgDataToModifyByMQ() : MsgDataToModifyByMQ(nullptr) {}
  ~MsgDataToModifyByMQ() override;
  explicit PROTOBUF_CONSTEXPR MsgDataToModifyByMQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataToModifyByMQ(const MsgDataToModifyByMQ& from);
  MsgDataToModifyByMQ(MsgDataToModifyByMQ&& from) noexcept
    : MsgDataToModifyByMQ() {
    *this = ::std::move(from);
  }

  inline MsgDataToModifyByMQ& operator=(const MsgDataToModifyByMQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataToModifyByMQ& operator=(MsgDataToModifyByMQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDataToModifyByMQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataToModifyByMQ* internal_default_instance() {
    return reinterpret_cast<const MsgDataToModifyByMQ*>(
               &_MsgDataToModifyByMQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MsgDataToModifyByMQ& a, MsgDataToModifyByMQ& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataToModifyByMQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataToModifyByMQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataToModifyByMQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataToModifyByMQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgDataToModifyByMQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgDataToModifyByMQ& from) {
    MsgDataToModifyByMQ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgDataToModifyByMQ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MsgDataToModifyByMQ";
  }
  protected:
  explicit MsgDataToModifyByMQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
    kConversationIDFieldNumber = 2,
  };
  // repeated .sdkws.MsgData messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::sdkws::MsgData* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >*
      mutable_messages();
  private:
  const ::sdkws::MsgData& _internal_messages(int index) const;
  ::sdkws::MsgData* _internal_add_messages();
  public:
  const ::sdkws::MsgData& messages(int index) const;
  ::sdkws::MsgData* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >&
      messages() const;

  // string conversationID = 2;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // @@protoc_insertion_point(class_scope:msg.MsgDataToModifyByMQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData > messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DelMsgsReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.DelMsgsReq) */ {
 public:
  inline DelMsgsReq() : DelMsgsReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DelMsgsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelMsgsReq(const DelMsgsReq& from);
  DelMsgsReq(DelMsgsReq&& from) noexcept
    : DelMsgsReq() {
    *this = ::std::move(from);
  }

  inline DelMsgsReq& operator=(const DelMsgsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelMsgsReq& operator=(DelMsgsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelMsgsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelMsgsReq* internal_default_instance() {
    return reinterpret_cast<const DelMsgsReq*>(
               &_DelMsgsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DelMsgsReq& a, DelMsgsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DelMsgsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelMsgsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelMsgsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelMsgsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DelMsgsReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DelMsgsReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DelMsgsReq";
  }
  protected:
  explicit DelMsgsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.DelMsgsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DelMsgsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.DelMsgsResp) */ {
 public:
  inline DelMsgsResp() : DelMsgsResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DelMsgsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelMsgsResp(const DelMsgsResp& from);
  DelMsgsResp(DelMsgsResp&& from) noexcept
    : DelMsgsResp() {
    *this = ::std::move(from);
  }

  inline DelMsgsResp& operator=(const DelMsgsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelMsgsResp& operator=(DelMsgsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelMsgsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelMsgsResp* internal_default_instance() {
    return reinterpret_cast<const DelMsgsResp*>(
               &_DelMsgsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DelMsgsResp& a, DelMsgsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DelMsgsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelMsgsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelMsgsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelMsgsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DelMsgsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DelMsgsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DelMsgsResp";
  }
  protected:
  explicit DelMsgsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.DelMsgsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class RevokeMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.RevokeMsgReq) */ {
 public:
  inline RevokeMsgReq() : RevokeMsgReq(nullptr) {}
  ~RevokeMsgReq() override;
  explicit PROTOBUF_CONSTEXPR RevokeMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevokeMsgReq(const RevokeMsgReq& from);
  RevokeMsgReq(RevokeMsgReq&& from) noexcept
    : RevokeMsgReq() {
    *this = ::std::move(from);
  }

  inline RevokeMsgReq& operator=(const RevokeMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeMsgReq& operator=(RevokeMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokeMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokeMsgReq* internal_default_instance() {
    return reinterpret_cast<const RevokeMsgReq*>(
               &_RevokeMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RevokeMsgReq& a, RevokeMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokeMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevokeMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevokeMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevokeMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevokeMsgReq& from) {
    RevokeMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevokeMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RevokeMsgReq";
  }
  protected:
  explicit RevokeMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kUserIDFieldNumber = 3,
    kSeqFieldNumber = 2,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 3;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // int64 seq = 2;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.RevokeMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int64_t seq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class RevokeMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.RevokeMsgResp) */ {
 public:
  inline RevokeMsgResp() : RevokeMsgResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RevokeMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevokeMsgResp(const RevokeMsgResp& from);
  RevokeMsgResp(RevokeMsgResp&& from) noexcept
    : RevokeMsgResp() {
    *this = ::std::move(from);
  }

  inline RevokeMsgResp& operator=(const RevokeMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeMsgResp& operator=(RevokeMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokeMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokeMsgResp* internal_default_instance() {
    return reinterpret_cast<const RevokeMsgResp*>(
               &_RevokeMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RevokeMsgResp& a, RevokeMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokeMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevokeMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevokeMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RevokeMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RevokeMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RevokeMsgResp";
  }
  protected:
  explicit RevokeMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.RevokeMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MarkMsgsAsReadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MarkMsgsAsReadReq) */ {
 public:
  inline MarkMsgsAsReadReq() : MarkMsgsAsReadReq(nullptr) {}
  ~MarkMsgsAsReadReq() override;
  explicit PROTOBUF_CONSTEXPR MarkMsgsAsReadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkMsgsAsReadReq(const MarkMsgsAsReadReq& from);
  MarkMsgsAsReadReq(MarkMsgsAsReadReq&& from) noexcept
    : MarkMsgsAsReadReq() {
    *this = ::std::move(from);
  }

  inline MarkMsgsAsReadReq& operator=(const MarkMsgsAsReadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkMsgsAsReadReq& operator=(MarkMsgsAsReadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkMsgsAsReadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkMsgsAsReadReq* internal_default_instance() {
    return reinterpret_cast<const MarkMsgsAsReadReq*>(
               &_MarkMsgsAsReadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MarkMsgsAsReadReq& a, MarkMsgsAsReadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkMsgsAsReadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkMsgsAsReadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkMsgsAsReadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkMsgsAsReadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkMsgsAsReadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkMsgsAsReadReq& from) {
    MarkMsgsAsReadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkMsgsAsReadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MarkMsgsAsReadReq";
  }
  protected:
  explicit MarkMsgsAsReadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kUserIDFieldNumber = 3,
  };
  // repeated int64 seqs = 2;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  int64_t _internal_seqs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_seqs() const;
  void _internal_add_seqs(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_seqs();
  public:
  int64_t seqs(int index) const;
  void set_seqs(int index, int64_t value);
  void add_seqs(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_seqs();

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 3;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:msg.MarkMsgsAsReadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > seqs_;
    mutable std::atomic<int> _seqs_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MarkMsgsAsReadResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.MarkMsgsAsReadResp) */ {
 public:
  inline MarkMsgsAsReadResp() : MarkMsgsAsReadResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkMsgsAsReadResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkMsgsAsReadResp(const MarkMsgsAsReadResp& from);
  MarkMsgsAsReadResp(MarkMsgsAsReadResp&& from) noexcept
    : MarkMsgsAsReadResp() {
    *this = ::std::move(from);
  }

  inline MarkMsgsAsReadResp& operator=(const MarkMsgsAsReadResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkMsgsAsReadResp& operator=(MarkMsgsAsReadResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkMsgsAsReadResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkMsgsAsReadResp* internal_default_instance() {
    return reinterpret_cast<const MarkMsgsAsReadResp*>(
               &_MarkMsgsAsReadResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MarkMsgsAsReadResp& a, MarkMsgsAsReadResp& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkMsgsAsReadResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkMsgsAsReadResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkMsgsAsReadResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkMsgsAsReadResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkMsgsAsReadResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkMsgsAsReadResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MarkMsgsAsReadResp";
  }
  protected:
  explicit MarkMsgsAsReadResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.MarkMsgsAsReadResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MarkConversationAsReadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MarkConversationAsReadReq) */ {
 public:
  inline MarkConversationAsReadReq() : MarkConversationAsReadReq(nullptr) {}
  ~MarkConversationAsReadReq() override;
  explicit PROTOBUF_CONSTEXPR MarkConversationAsReadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkConversationAsReadReq(const MarkConversationAsReadReq& from);
  MarkConversationAsReadReq(MarkConversationAsReadReq&& from) noexcept
    : MarkConversationAsReadReq() {
    *this = ::std::move(from);
  }

  inline MarkConversationAsReadReq& operator=(const MarkConversationAsReadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkConversationAsReadReq& operator=(MarkConversationAsReadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkConversationAsReadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkConversationAsReadReq* internal_default_instance() {
    return reinterpret_cast<const MarkConversationAsReadReq*>(
               &_MarkConversationAsReadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MarkConversationAsReadReq& a, MarkConversationAsReadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkConversationAsReadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkConversationAsReadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkConversationAsReadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkConversationAsReadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkConversationAsReadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkConversationAsReadReq& from) {
    MarkConversationAsReadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkConversationAsReadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MarkConversationAsReadReq";
  }
  protected:
  explicit MarkConversationAsReadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 4,
    kConversationIDFieldNumber = 1,
    kUserIDFieldNumber = 2,
    kHasReadSeqFieldNumber = 3,
  };
  // repeated int64 seqs = 4;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  int64_t _internal_seqs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_seqs() const;
  void _internal_add_seqs(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_seqs();
  public:
  int64_t seqs(int index) const;
  void set_seqs(int index, int64_t value);
  void add_seqs(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_seqs();

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // int64 hasReadSeq = 3;
  void clear_hasreadseq();
  int64_t hasreadseq() const;
  void set_hasreadseq(int64_t value);
  private:
  int64_t _internal_hasreadseq() const;
  void _internal_set_hasreadseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.MarkConversationAsReadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > seqs_;
    mutable std::atomic<int> _seqs_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int64_t hasreadseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MarkConversationAsReadResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.MarkConversationAsReadResp) */ {
 public:
  inline MarkConversationAsReadResp() : MarkConversationAsReadResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkConversationAsReadResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkConversationAsReadResp(const MarkConversationAsReadResp& from);
  MarkConversationAsReadResp(MarkConversationAsReadResp&& from) noexcept
    : MarkConversationAsReadResp() {
    *this = ::std::move(from);
  }

  inline MarkConversationAsReadResp& operator=(const MarkConversationAsReadResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkConversationAsReadResp& operator=(MarkConversationAsReadResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkConversationAsReadResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkConversationAsReadResp* internal_default_instance() {
    return reinterpret_cast<const MarkConversationAsReadResp*>(
               &_MarkConversationAsReadResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MarkConversationAsReadResp& a, MarkConversationAsReadResp& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkConversationAsReadResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkConversationAsReadResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkConversationAsReadResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkConversationAsReadResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkConversationAsReadResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkConversationAsReadResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MarkConversationAsReadResp";
  }
  protected:
  explicit MarkConversationAsReadResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.MarkConversationAsReadResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetConversationHasReadSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SetConversationHasReadSeqReq) */ {
 public:
  inline SetConversationHasReadSeqReq() : SetConversationHasReadSeqReq(nullptr) {}
  ~SetConversationHasReadSeqReq() override;
  explicit PROTOBUF_CONSTEXPR SetConversationHasReadSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationHasReadSeqReq(const SetConversationHasReadSeqReq& from);
  SetConversationHasReadSeqReq(SetConversationHasReadSeqReq&& from) noexcept
    : SetConversationHasReadSeqReq() {
    *this = ::std::move(from);
  }

  inline SetConversationHasReadSeqReq& operator=(const SetConversationHasReadSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationHasReadSeqReq& operator=(SetConversationHasReadSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationHasReadSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationHasReadSeqReq* internal_default_instance() {
    return reinterpret_cast<const SetConversationHasReadSeqReq*>(
               &_SetConversationHasReadSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SetConversationHasReadSeqReq& a, SetConversationHasReadSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationHasReadSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationHasReadSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationHasReadSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationHasReadSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetConversationHasReadSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetConversationHasReadSeqReq& from) {
    SetConversationHasReadSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetConversationHasReadSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetConversationHasReadSeqReq";
  }
  protected:
  explicit SetConversationHasReadSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kUserIDFieldNumber = 2,
    kHasReadSeqFieldNumber = 3,
    kNoNotificationFieldNumber = 4,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // int64 hasReadSeq = 3;
  void clear_hasreadseq();
  int64_t hasreadseq() const;
  void set_hasreadseq(int64_t value);
  private:
  int64_t _internal_hasreadseq() const;
  void _internal_set_hasreadseq(int64_t value);
  public:

  // bool noNotification = 4;
  void clear_nonotification();
  bool nonotification() const;
  void set_nonotification(bool value);
  private:
  bool _internal_nonotification() const;
  void _internal_set_nonotification(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SetConversationHasReadSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int64_t hasreadseq_;
    bool nonotification_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetConversationHasReadSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.SetConversationHasReadSeqResp) */ {
 public:
  inline SetConversationHasReadSeqResp() : SetConversationHasReadSeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetConversationHasReadSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetConversationHasReadSeqResp(const SetConversationHasReadSeqResp& from);
  SetConversationHasReadSeqResp(SetConversationHasReadSeqResp&& from) noexcept
    : SetConversationHasReadSeqResp() {
    *this = ::std::move(from);
  }

  inline SetConversationHasReadSeqResp& operator=(const SetConversationHasReadSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConversationHasReadSeqResp& operator=(SetConversationHasReadSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConversationHasReadSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConversationHasReadSeqResp* internal_default_instance() {
    return reinterpret_cast<const SetConversationHasReadSeqResp*>(
               &_SetConversationHasReadSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SetConversationHasReadSeqResp& a, SetConversationHasReadSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetConversationHasReadSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConversationHasReadSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConversationHasReadSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetConversationHasReadSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConversationHasReadSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConversationHasReadSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetConversationHasReadSeqResp";
  }
  protected:
  explicit SetConversationHasReadSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.SetConversationHasReadSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteSyncOpt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.DeleteSyncOpt) */ {
 public:
  inline DeleteSyncOpt() : DeleteSyncOpt(nullptr) {}
  ~DeleteSyncOpt() override;
  explicit PROTOBUF_CONSTEXPR DeleteSyncOpt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSyncOpt(const DeleteSyncOpt& from);
  DeleteSyncOpt(DeleteSyncOpt&& from) noexcept
    : DeleteSyncOpt() {
    *this = ::std::move(from);
  }

  inline DeleteSyncOpt& operator=(const DeleteSyncOpt& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSyncOpt& operator=(DeleteSyncOpt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSyncOpt& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSyncOpt* internal_default_instance() {
    return reinterpret_cast<const DeleteSyncOpt*>(
               &_DeleteSyncOpt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeleteSyncOpt& a, DeleteSyncOpt& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSyncOpt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSyncOpt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSyncOpt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSyncOpt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSyncOpt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSyncOpt& from) {
    DeleteSyncOpt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSyncOpt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteSyncOpt";
  }
  protected:
  explicit DeleteSyncOpt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSyncSelfFieldNumber = 3,
    kIsSyncOtherFieldNumber = 4,
  };
  // bool IsSyncSelf = 3;
  void clear_issyncself();
  bool issyncself() const;
  void set_issyncself(bool value);
  private:
  bool _internal_issyncself() const;
  void _internal_set_issyncself(bool value);
  public:

  // bool IsSyncOther = 4;
  void clear_issyncother();
  bool issyncother() const;
  void set_issyncother(bool value);
  private:
  bool _internal_issyncother() const;
  void _internal_set_issyncother(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.DeleteSyncOpt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool issyncself_;
    bool issyncother_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ClearConversationsMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ClearConversationsMsgReq) */ {
 public:
  inline ClearConversationsMsgReq() : ClearConversationsMsgReq(nullptr) {}
  ~ClearConversationsMsgReq() override;
  explicit PROTOBUF_CONSTEXPR ClearConversationsMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearConversationsMsgReq(const ClearConversationsMsgReq& from);
  ClearConversationsMsgReq(ClearConversationsMsgReq&& from) noexcept
    : ClearConversationsMsgReq() {
    *this = ::std::move(from);
  }

  inline ClearConversationsMsgReq& operator=(const ClearConversationsMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearConversationsMsgReq& operator=(ClearConversationsMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearConversationsMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearConversationsMsgReq* internal_default_instance() {
    return reinterpret_cast<const ClearConversationsMsgReq*>(
               &_ClearConversationsMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ClearConversationsMsgReq& a, ClearConversationsMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearConversationsMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearConversationsMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearConversationsMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearConversationsMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearConversationsMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearConversationsMsgReq& from) {
    ClearConversationsMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearConversationsMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ClearConversationsMsgReq";
  }
  protected:
  explicit ClearConversationsMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
    kUserIDFieldNumber = 2,
    kDeleteSyncOptFieldNumber = 3,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string userID = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .msg.DeleteSyncOpt deleteSyncOpt = 3;
  bool has_deletesyncopt() const;
  private:
  bool _internal_has_deletesyncopt() const;
  public:
  void clear_deletesyncopt();
  const ::msg::DeleteSyncOpt& deletesyncopt() const;
  PROTOBUF_NODISCARD ::msg::DeleteSyncOpt* release_deletesyncopt();
  ::msg::DeleteSyncOpt* mutable_deletesyncopt();
  void set_allocated_deletesyncopt(::msg::DeleteSyncOpt* deletesyncopt);
  private:
  const ::msg::DeleteSyncOpt& _internal_deletesyncopt() const;
  ::msg::DeleteSyncOpt* _internal_mutable_deletesyncopt();
  public:
  void unsafe_arena_set_allocated_deletesyncopt(
      ::msg::DeleteSyncOpt* deletesyncopt);
  ::msg::DeleteSyncOpt* unsafe_arena_release_deletesyncopt();

  // @@protoc_insertion_point(class_scope:msg.ClearConversationsMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::msg::DeleteSyncOpt* deletesyncopt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ClearConversationsMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.ClearConversationsMsgResp) */ {
 public:
  inline ClearConversationsMsgResp() : ClearConversationsMsgResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClearConversationsMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearConversationsMsgResp(const ClearConversationsMsgResp& from);
  ClearConversationsMsgResp(ClearConversationsMsgResp&& from) noexcept
    : ClearConversationsMsgResp() {
    *this = ::std::move(from);
  }

  inline ClearConversationsMsgResp& operator=(const ClearConversationsMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearConversationsMsgResp& operator=(ClearConversationsMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearConversationsMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearConversationsMsgResp* internal_default_instance() {
    return reinterpret_cast<const ClearConversationsMsgResp*>(
               &_ClearConversationsMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ClearConversationsMsgResp& a, ClearConversationsMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearConversationsMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearConversationsMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearConversationsMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearConversationsMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClearConversationsMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClearConversationsMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ClearConversationsMsgResp";
  }
  protected:
  explicit ClearConversationsMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.ClearConversationsMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class UserClearAllMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.UserClearAllMsgReq) */ {
 public:
  inline UserClearAllMsgReq() : UserClearAllMsgReq(nullptr) {}
  ~UserClearAllMsgReq() override;
  explicit PROTOBUF_CONSTEXPR UserClearAllMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserClearAllMsgReq(const UserClearAllMsgReq& from);
  UserClearAllMsgReq(UserClearAllMsgReq&& from) noexcept
    : UserClearAllMsgReq() {
    *this = ::std::move(from);
  }

  inline UserClearAllMsgReq& operator=(const UserClearAllMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserClearAllMsgReq& operator=(UserClearAllMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserClearAllMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserClearAllMsgReq* internal_default_instance() {
    return reinterpret_cast<const UserClearAllMsgReq*>(
               &_UserClearAllMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UserClearAllMsgReq& a, UserClearAllMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UserClearAllMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserClearAllMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserClearAllMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserClearAllMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserClearAllMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserClearAllMsgReq& from) {
    UserClearAllMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserClearAllMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.UserClearAllMsgReq";
  }
  protected:
  explicit UserClearAllMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDeleteSyncOptFieldNumber = 3,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .msg.DeleteSyncOpt deleteSyncOpt = 3;
  bool has_deletesyncopt() const;
  private:
  bool _internal_has_deletesyncopt() const;
  public:
  void clear_deletesyncopt();
  const ::msg::DeleteSyncOpt& deletesyncopt() const;
  PROTOBUF_NODISCARD ::msg::DeleteSyncOpt* release_deletesyncopt();
  ::msg::DeleteSyncOpt* mutable_deletesyncopt();
  void set_allocated_deletesyncopt(::msg::DeleteSyncOpt* deletesyncopt);
  private:
  const ::msg::DeleteSyncOpt& _internal_deletesyncopt() const;
  ::msg::DeleteSyncOpt* _internal_mutable_deletesyncopt();
  public:
  void unsafe_arena_set_allocated_deletesyncopt(
      ::msg::DeleteSyncOpt* deletesyncopt);
  ::msg::DeleteSyncOpt* unsafe_arena_release_deletesyncopt();

  // @@protoc_insertion_point(class_scope:msg.UserClearAllMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::msg::DeleteSyncOpt* deletesyncopt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class UserClearAllMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.UserClearAllMsgResp) */ {
 public:
  inline UserClearAllMsgResp() : UserClearAllMsgResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UserClearAllMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserClearAllMsgResp(const UserClearAllMsgResp& from);
  UserClearAllMsgResp(UserClearAllMsgResp&& from) noexcept
    : UserClearAllMsgResp() {
    *this = ::std::move(from);
  }

  inline UserClearAllMsgResp& operator=(const UserClearAllMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserClearAllMsgResp& operator=(UserClearAllMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserClearAllMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserClearAllMsgResp* internal_default_instance() {
    return reinterpret_cast<const UserClearAllMsgResp*>(
               &_UserClearAllMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UserClearAllMsgResp& a, UserClearAllMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UserClearAllMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserClearAllMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserClearAllMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserClearAllMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UserClearAllMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UserClearAllMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.UserClearAllMsgResp";
  }
  protected:
  explicit UserClearAllMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.UserClearAllMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsgsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.DeleteMsgsReq) */ {
 public:
  inline DeleteMsgsReq() : DeleteMsgsReq(nullptr) {}
  ~DeleteMsgsReq() override;
  explicit PROTOBUF_CONSTEXPR DeleteMsgsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMsgsReq(const DeleteMsgsReq& from);
  DeleteMsgsReq(DeleteMsgsReq&& from) noexcept
    : DeleteMsgsReq() {
    *this = ::std::move(from);
  }

  inline DeleteMsgsReq& operator=(const DeleteMsgsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsgsReq& operator=(DeleteMsgsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMsgsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMsgsReq* internal_default_instance() {
    return reinterpret_cast<const DeleteMsgsReq*>(
               &_DeleteMsgsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeleteMsgsReq& a, DeleteMsgsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsgsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMsgsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMsgsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMsgsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMsgsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMsgsReq& from) {
    DeleteMsgsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMsgsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteMsgsReq";
  }
  protected:
  explicit DeleteMsgsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kUserIDFieldNumber = 3,
    kDeleteSyncOptFieldNumber = 4,
  };
  // repeated int64 seqs = 2;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  int64_t _internal_seqs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_seqs() const;
  void _internal_add_seqs(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_seqs();
  public:
  int64_t seqs(int index) const;
  void set_seqs(int index, int64_t value);
  void add_seqs(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_seqs();

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // string userID = 3;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .msg.DeleteSyncOpt deleteSyncOpt = 4;
  bool has_deletesyncopt() const;
  private:
  bool _internal_has_deletesyncopt() const;
  public:
  void clear_deletesyncopt();
  const ::msg::DeleteSyncOpt& deletesyncopt() const;
  PROTOBUF_NODISCARD ::msg::DeleteSyncOpt* release_deletesyncopt();
  ::msg::DeleteSyncOpt* mutable_deletesyncopt();
  void set_allocated_deletesyncopt(::msg::DeleteSyncOpt* deletesyncopt);
  private:
  const ::msg::DeleteSyncOpt& _internal_deletesyncopt() const;
  ::msg::DeleteSyncOpt* _internal_mutable_deletesyncopt();
  public:
  void unsafe_arena_set_allocated_deletesyncopt(
      ::msg::DeleteSyncOpt* deletesyncopt);
  ::msg::DeleteSyncOpt* unsafe_arena_release_deletesyncopt();

  // @@protoc_insertion_point(class_scope:msg.DeleteMsgsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > seqs_;
    mutable std::atomic<int> _seqs_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::msg::DeleteSyncOpt* deletesyncopt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsgsResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.DeleteMsgsResp) */ {
 public:
  inline DeleteMsgsResp() : DeleteMsgsResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteMsgsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMsgsResp(const DeleteMsgsResp& from);
  DeleteMsgsResp(DeleteMsgsResp&& from) noexcept
    : DeleteMsgsResp() {
    *this = ::std::move(from);
  }

  inline DeleteMsgsResp& operator=(const DeleteMsgsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsgsResp& operator=(DeleteMsgsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMsgsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMsgsResp* internal_default_instance() {
    return reinterpret_cast<const DeleteMsgsResp*>(
               &_DeleteMsgsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeleteMsgsResp& a, DeleteMsgsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsgsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMsgsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMsgsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMsgsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteMsgsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteMsgsResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteMsgsResp";
  }
  protected:
  explicit DeleteMsgsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.DeleteMsgsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsgPhysicalReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.DeleteMsgPhysicalReq) */ {
 public:
  inline DeleteMsgPhysicalReq() : DeleteMsgPhysicalReq(nullptr) {}
  ~DeleteMsgPhysicalReq() override;
  explicit PROTOBUF_CONSTEXPR DeleteMsgPhysicalReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMsgPhysicalReq(const DeleteMsgPhysicalReq& from);
  DeleteMsgPhysicalReq(DeleteMsgPhysicalReq&& from) noexcept
    : DeleteMsgPhysicalReq() {
    *this = ::std::move(from);
  }

  inline DeleteMsgPhysicalReq& operator=(const DeleteMsgPhysicalReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsgPhysicalReq& operator=(DeleteMsgPhysicalReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMsgPhysicalReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMsgPhysicalReq* internal_default_instance() {
    return reinterpret_cast<const DeleteMsgPhysicalReq*>(
               &_DeleteMsgPhysicalReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DeleteMsgPhysicalReq& a, DeleteMsgPhysicalReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsgPhysicalReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMsgPhysicalReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMsgPhysicalReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMsgPhysicalReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMsgPhysicalReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMsgPhysicalReq& from) {
    DeleteMsgPhysicalReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMsgPhysicalReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteMsgPhysicalReq";
  }
  protected:
  explicit DeleteMsgPhysicalReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.DeleteMsgPhysicalReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsgPhysicalResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.DeleteMsgPhysicalResp) */ {
 public:
  inline DeleteMsgPhysicalResp() : DeleteMsgPhysicalResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteMsgPhysicalResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMsgPhysicalResp(const DeleteMsgPhysicalResp& from);
  DeleteMsgPhysicalResp(DeleteMsgPhysicalResp&& from) noexcept
    : DeleteMsgPhysicalResp() {
    *this = ::std::move(from);
  }

  inline DeleteMsgPhysicalResp& operator=(const DeleteMsgPhysicalResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsgPhysicalResp& operator=(DeleteMsgPhysicalResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMsgPhysicalResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMsgPhysicalResp* internal_default_instance() {
    return reinterpret_cast<const DeleteMsgPhysicalResp*>(
               &_DeleteMsgPhysicalResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DeleteMsgPhysicalResp& a, DeleteMsgPhysicalResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsgPhysicalResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMsgPhysicalResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMsgPhysicalResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMsgPhysicalResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteMsgPhysicalResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteMsgPhysicalResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteMsgPhysicalResp";
  }
  protected:
  explicit DeleteMsgPhysicalResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.DeleteMsgPhysicalResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsgPhysicalBySeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.DeleteMsgPhysicalBySeqReq) */ {
 public:
  inline DeleteMsgPhysicalBySeqReq() : DeleteMsgPhysicalBySeqReq(nullptr) {}
  ~DeleteMsgPhysicalBySeqReq() override;
  explicit PROTOBUF_CONSTEXPR DeleteMsgPhysicalBySeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMsgPhysicalBySeqReq(const DeleteMsgPhysicalBySeqReq& from);
  DeleteMsgPhysicalBySeqReq(DeleteMsgPhysicalBySeqReq&& from) noexcept
    : DeleteMsgPhysicalBySeqReq() {
    *this = ::std::move(from);
  }

  inline DeleteMsgPhysicalBySeqReq& operator=(const DeleteMsgPhysicalBySeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsgPhysicalBySeqReq& operator=(DeleteMsgPhysicalBySeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMsgPhysicalBySeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMsgPhysicalBySeqReq* internal_default_instance() {
    return reinterpret_cast<const DeleteMsgPhysicalBySeqReq*>(
               &_DeleteMsgPhysicalBySeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DeleteMsgPhysicalBySeqReq& a, DeleteMsgPhysicalBySeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsgPhysicalBySeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMsgPhysicalBySeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMsgPhysicalBySeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMsgPhysicalBySeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMsgPhysicalBySeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMsgPhysicalBySeqReq& from) {
    DeleteMsgPhysicalBySeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMsgPhysicalBySeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteMsgPhysicalBySeqReq";
  }
  protected:
  explicit DeleteMsgPhysicalBySeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 2,
    kConversationIDFieldNumber = 1,
  };
  // repeated int64 seqs = 2;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  int64_t _internal_seqs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_seqs() const;
  void _internal_add_seqs(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_seqs();
  public:
  int64_t seqs(int index) const;
  void set_seqs(int index, int64_t value);
  void add_seqs(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_seqs();

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // @@protoc_insertion_point(class_scope:msg.DeleteMsgPhysicalBySeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > seqs_;
    mutable std::atomic<int> _seqs_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsgPhysicalBySeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.DeleteMsgPhysicalBySeqResp) */ {
 public:
  inline DeleteMsgPhysicalBySeqResp() : DeleteMsgPhysicalBySeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteMsgPhysicalBySeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMsgPhysicalBySeqResp(const DeleteMsgPhysicalBySeqResp& from);
  DeleteMsgPhysicalBySeqResp(DeleteMsgPhysicalBySeqResp&& from) noexcept
    : DeleteMsgPhysicalBySeqResp() {
    *this = ::std::move(from);
  }

  inline DeleteMsgPhysicalBySeqResp& operator=(const DeleteMsgPhysicalBySeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsgPhysicalBySeqResp& operator=(DeleteMsgPhysicalBySeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMsgPhysicalBySeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMsgPhysicalBySeqResp* internal_default_instance() {
    return reinterpret_cast<const DeleteMsgPhysicalBySeqResp*>(
               &_DeleteMsgPhysicalBySeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DeleteMsgPhysicalBySeqResp& a, DeleteMsgPhysicalBySeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsgPhysicalBySeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMsgPhysicalBySeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMsgPhysicalBySeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMsgPhysicalBySeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteMsgPhysicalBySeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteMsgPhysicalBySeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DeleteMsgPhysicalBySeqResp";
  }
  protected:
  explicit DeleteMsgPhysicalBySeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.DeleteMsgPhysicalBySeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetMaxSeqsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetMaxSeqsReq) */ {
 public:
  inline GetMaxSeqsReq() : GetMaxSeqsReq(nullptr) {}
  ~GetMaxSeqsReq() override;
  explicit PROTOBUF_CONSTEXPR GetMaxSeqsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMaxSeqsReq(const GetMaxSeqsReq& from);
  GetMaxSeqsReq(GetMaxSeqsReq&& from) noexcept
    : GetMaxSeqsReq() {
    *this = ::std::move(from);
  }

  inline GetMaxSeqsReq& operator=(const GetMaxSeqsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMaxSeqsReq& operator=(GetMaxSeqsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMaxSeqsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMaxSeqsReq* internal_default_instance() {
    return reinterpret_cast<const GetMaxSeqsReq*>(
               &_GetMaxSeqsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetMaxSeqsReq& a, GetMaxSeqsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMaxSeqsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMaxSeqsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMaxSeqsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMaxSeqsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMaxSeqsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMaxSeqsReq& from) {
    GetMaxSeqsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMaxSeqsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetMaxSeqsReq";
  }
  protected:
  explicit GetMaxSeqsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // @@protoc_insertion_point(class_scope:msg.GetMaxSeqsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetHasReadSeqsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetHasReadSeqsReq) */ {
 public:
  inline GetHasReadSeqsReq() : GetHasReadSeqsReq(nullptr) {}
  ~GetHasReadSeqsReq() override;
  explicit PROTOBUF_CONSTEXPR GetHasReadSeqsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHasReadSeqsReq(const GetHasReadSeqsReq& from);
  GetHasReadSeqsReq(GetHasReadSeqsReq&& from) noexcept
    : GetHasReadSeqsReq() {
    *this = ::std::move(from);
  }

  inline GetHasReadSeqsReq& operator=(const GetHasReadSeqsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHasReadSeqsReq& operator=(GetHasReadSeqsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHasReadSeqsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHasReadSeqsReq* internal_default_instance() {
    return reinterpret_cast<const GetHasReadSeqsReq*>(
               &_GetHasReadSeqsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetHasReadSeqsReq& a, GetHasReadSeqsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHasReadSeqsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHasReadSeqsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHasReadSeqsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHasReadSeqsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHasReadSeqsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHasReadSeqsReq& from) {
    GetHasReadSeqsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHasReadSeqsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetHasReadSeqsReq";
  }
  protected:
  explicit GetHasReadSeqsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 2,
    kUserIDFieldNumber = 1,
  };
  // repeated string conversationIDs = 2;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:msg.GetHasReadSeqsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SeqsInfoResp_MaxSeqsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SeqsInfoResp_MaxSeqsEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SeqsInfoResp_MaxSeqsEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  SeqsInfoResp_MaxSeqsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SeqsInfoResp_MaxSeqsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SeqsInfoResp_MaxSeqsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SeqsInfoResp_MaxSeqsEntry_DoNotUse& other);
  static const SeqsInfoResp_MaxSeqsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SeqsInfoResp_MaxSeqsEntry_DoNotUse*>(&_SeqsInfoResp_MaxSeqsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.SeqsInfoResp.MaxSeqsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class SeqsInfoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SeqsInfoResp) */ {
 public:
  inline SeqsInfoResp() : SeqsInfoResp(nullptr) {}
  ~SeqsInfoResp() override;
  explicit PROTOBUF_CONSTEXPR SeqsInfoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeqsInfoResp(const SeqsInfoResp& from);
  SeqsInfoResp(SeqsInfoResp&& from) noexcept
    : SeqsInfoResp() {
    *this = ::std::move(from);
  }

  inline SeqsInfoResp& operator=(const SeqsInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeqsInfoResp& operator=(SeqsInfoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeqsInfoResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeqsInfoResp* internal_default_instance() {
    return reinterpret_cast<const SeqsInfoResp*>(
               &_SeqsInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SeqsInfoResp& a, SeqsInfoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SeqsInfoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeqsInfoResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeqsInfoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeqsInfoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeqsInfoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SeqsInfoResp& from) {
    SeqsInfoResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeqsInfoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SeqsInfoResp";
  }
  protected:
  explicit SeqsInfoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMaxSeqsFieldNumber = 1,
  };
  // map<string, int64> maxSeqs = 1;
  int maxseqs_size() const;
  private:
  int _internal_maxseqs_size() const;
  public:
  void clear_maxseqs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_maxseqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_maxseqs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      maxseqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_maxseqs();

  // @@protoc_insertion_point(class_scope:msg.SeqsInfoResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SeqsInfoResp_MaxSeqsEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> maxseqs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse& other);
  static const GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse*>(&_GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetMsgByConversationIDsReq.MaxSeqsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetMsgByConversationIDsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetMsgByConversationIDsReq) */ {
 public:
  inline GetMsgByConversationIDsReq() : GetMsgByConversationIDsReq(nullptr) {}
  ~GetMsgByConversationIDsReq() override;
  explicit PROTOBUF_CONSTEXPR GetMsgByConversationIDsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMsgByConversationIDsReq(const GetMsgByConversationIDsReq& from);
  GetMsgByConversationIDsReq(GetMsgByConversationIDsReq&& from) noexcept
    : GetMsgByConversationIDsReq() {
    *this = ::std::move(from);
  }

  inline GetMsgByConversationIDsReq& operator=(const GetMsgByConversationIDsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMsgByConversationIDsReq& operator=(GetMsgByConversationIDsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMsgByConversationIDsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMsgByConversationIDsReq* internal_default_instance() {
    return reinterpret_cast<const GetMsgByConversationIDsReq*>(
               &_GetMsgByConversationIDsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetMsgByConversationIDsReq& a, GetMsgByConversationIDsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMsgByConversationIDsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMsgByConversationIDsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMsgByConversationIDsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMsgByConversationIDsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMsgByConversationIDsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMsgByConversationIDsReq& from) {
    GetMsgByConversationIDsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMsgByConversationIDsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetMsgByConversationIDsReq";
  }
  protected:
  explicit GetMsgByConversationIDsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
    kMaxSeqsFieldNumber = 2,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // map<string, int64> maxSeqs = 2;
  int maxseqs_size() const;
  private:
  int _internal_maxseqs_size() const;
  public:
  void clear_maxseqs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_maxseqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_maxseqs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      maxseqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_maxseqs();

  // @@protoc_insertion_point(class_scope:msg.GetMsgByConversationIDsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetMsgByConversationIDsReq_MaxSeqsEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> maxseqs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse, 
    std::string, ::sdkws::MsgData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse, 
    std::string, ::sdkws::MsgData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse& other);
  static const GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse*>(&_GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetMsgByConversationIDsResp.MsgDatasEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetMsgByConversationIDsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetMsgByConversationIDsResp) */ {
 public:
  inline GetMsgByConversationIDsResp() : GetMsgByConversationIDsResp(nullptr) {}
  ~GetMsgByConversationIDsResp() override;
  explicit PROTOBUF_CONSTEXPR GetMsgByConversationIDsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMsgByConversationIDsResp(const GetMsgByConversationIDsResp& from);
  GetMsgByConversationIDsResp(GetMsgByConversationIDsResp&& from) noexcept
    : GetMsgByConversationIDsResp() {
    *this = ::std::move(from);
  }

  inline GetMsgByConversationIDsResp& operator=(const GetMsgByConversationIDsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMsgByConversationIDsResp& operator=(GetMsgByConversationIDsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMsgByConversationIDsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMsgByConversationIDsResp* internal_default_instance() {
    return reinterpret_cast<const GetMsgByConversationIDsResp*>(
               &_GetMsgByConversationIDsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetMsgByConversationIDsResp& a, GetMsgByConversationIDsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMsgByConversationIDsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMsgByConversationIDsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMsgByConversationIDsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMsgByConversationIDsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMsgByConversationIDsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMsgByConversationIDsResp& from) {
    GetMsgByConversationIDsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMsgByConversationIDsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetMsgByConversationIDsResp";
  }
  protected:
  explicit GetMsgByConversationIDsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMsgDatasFieldNumber = 1,
  };
  // map<string, .sdkws.MsgData> msgDatas = 1;
  int msgdatas_size() const;
  private:
  int _internal_msgdatas_size() const;
  public:
  void clear_msgdatas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
      _internal_msgdatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
      _internal_mutable_msgdatas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
      msgdatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
      mutable_msgdatas();

  // @@protoc_insertion_point(class_scope:msg.GetMsgByConversationIDsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetMsgByConversationIDsResp_MsgDatasEntry_DoNotUse,
        std::string, ::sdkws::MsgData,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> msgdatas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetConversationMaxSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetConversationMaxSeqReq) */ {
 public:
  inline GetConversationMaxSeqReq() : GetConversationMaxSeqReq(nullptr) {}
  ~GetConversationMaxSeqReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationMaxSeqReq(const GetConversationMaxSeqReq& from);
  GetConversationMaxSeqReq(GetConversationMaxSeqReq&& from) noexcept
    : GetConversationMaxSeqReq() {
    *this = ::std::move(from);
  }

  inline GetConversationMaxSeqReq& operator=(const GetConversationMaxSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationMaxSeqReq& operator=(GetConversationMaxSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationMaxSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationMaxSeqReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationMaxSeqReq*>(
               &_GetConversationMaxSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(GetConversationMaxSeqReq& a, GetConversationMaxSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationMaxSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationMaxSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationMaxSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationMaxSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationMaxSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationMaxSeqReq& from) {
    GetConversationMaxSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationMaxSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetConversationMaxSeqReq";
  }
  protected:
  explicit GetConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // @@protoc_insertion_point(class_scope:msg.GetConversationMaxSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetConversationMaxSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetConversationMaxSeqResp) */ {
 public:
  inline GetConversationMaxSeqResp() : GetConversationMaxSeqResp(nullptr) {}
  ~GetConversationMaxSeqResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationMaxSeqResp(const GetConversationMaxSeqResp& from);
  GetConversationMaxSeqResp(GetConversationMaxSeqResp&& from) noexcept
    : GetConversationMaxSeqResp() {
    *this = ::std::move(from);
  }

  inline GetConversationMaxSeqResp& operator=(const GetConversationMaxSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationMaxSeqResp& operator=(GetConversationMaxSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationMaxSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationMaxSeqResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationMaxSeqResp*>(
               &_GetConversationMaxSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(GetConversationMaxSeqResp& a, GetConversationMaxSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationMaxSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationMaxSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationMaxSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationMaxSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationMaxSeqResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationMaxSeqResp& from) {
    GetConversationMaxSeqResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationMaxSeqResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetConversationMaxSeqResp";
  }
  protected:
  explicit GetConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxSeqFieldNumber = 1,
  };
  // int64 maxSeq = 1;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetConversationMaxSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t maxseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsHasReadAndMaxSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetConversationsHasReadAndMaxSeqReq) */ {
 public:
  inline GetConversationsHasReadAndMaxSeqReq() : GetConversationsHasReadAndMaxSeqReq(nullptr) {}
  ~GetConversationsHasReadAndMaxSeqReq() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsHasReadAndMaxSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsHasReadAndMaxSeqReq(const GetConversationsHasReadAndMaxSeqReq& from);
  GetConversationsHasReadAndMaxSeqReq(GetConversationsHasReadAndMaxSeqReq&& from) noexcept
    : GetConversationsHasReadAndMaxSeqReq() {
    *this = ::std::move(from);
  }

  inline GetConversationsHasReadAndMaxSeqReq& operator=(const GetConversationsHasReadAndMaxSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsHasReadAndMaxSeqReq& operator=(GetConversationsHasReadAndMaxSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsHasReadAndMaxSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsHasReadAndMaxSeqReq* internal_default_instance() {
    return reinterpret_cast<const GetConversationsHasReadAndMaxSeqReq*>(
               &_GetConversationsHasReadAndMaxSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(GetConversationsHasReadAndMaxSeqReq& a, GetConversationsHasReadAndMaxSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsHasReadAndMaxSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsHasReadAndMaxSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsHasReadAndMaxSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsHasReadAndMaxSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsHasReadAndMaxSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsHasReadAndMaxSeqReq& from) {
    GetConversationsHasReadAndMaxSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsHasReadAndMaxSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetConversationsHasReadAndMaxSeqReq";
  }
  protected:
  explicit GetConversationsHasReadAndMaxSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 2,
    kUserIDFieldNumber = 1,
    kReturnPinnedFieldNumber = 3,
  };
  // repeated string conversationIDs = 2;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bool returnPinned = 3;
  void clear_returnpinned();
  bool returnpinned() const;
  void set_returnpinned(bool value);
  private:
  bool _internal_returnpinned() const;
  void _internal_set_returnpinned(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetConversationsHasReadAndMaxSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    bool returnpinned_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class Seqs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.Seqs) */ {
 public:
  inline Seqs() : Seqs(nullptr) {}
  ~Seqs() override;
  explicit PROTOBUF_CONSTEXPR Seqs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Seqs(const Seqs& from);
  Seqs(Seqs&& from) noexcept
    : Seqs() {
    *this = ::std::move(from);
  }

  inline Seqs& operator=(const Seqs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Seqs& operator=(Seqs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Seqs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Seqs* internal_default_instance() {
    return reinterpret_cast<const Seqs*>(
               &_Seqs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Seqs& a, Seqs& b) {
    a.Swap(&b);
  }
  inline void Swap(Seqs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Seqs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Seqs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Seqs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Seqs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Seqs& from) {
    Seqs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Seqs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.Seqs";
  }
  protected:
  explicit Seqs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxSeqFieldNumber = 1,
    kHasReadSeqFieldNumber = 2,
    kMaxSeqTimeFieldNumber = 3,
  };
  // int64 maxSeq = 1;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // int64 hasReadSeq = 2;
  void clear_hasreadseq();
  int64_t hasreadseq() const;
  void set_hasreadseq(int64_t value);
  private:
  int64_t _internal_hasreadseq() const;
  void _internal_set_hasreadseq(int64_t value);
  public:

  // int64 maxSeqTime = 3;
  void clear_maxseqtime();
  int64_t maxseqtime() const;
  void set_maxseqtime(int64_t value);
  private:
  int64_t _internal_maxseqtime() const;
  void _internal_set_maxseqtime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.Seqs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t maxseq_;
    int64_t hasreadseq_;
    int64_t maxseqtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse, 
    std::string, ::msg::Seqs,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse, 
    std::string, ::msg::Seqs,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse& other);
  static const GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse*>(&_GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetConversationsHasReadAndMaxSeqResp.SeqsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetConversationsHasReadAndMaxSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetConversationsHasReadAndMaxSeqResp) */ {
 public:
  inline GetConversationsHasReadAndMaxSeqResp() : GetConversationsHasReadAndMaxSeqResp(nullptr) {}
  ~GetConversationsHasReadAndMaxSeqResp() override;
  explicit PROTOBUF_CONSTEXPR GetConversationsHasReadAndMaxSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationsHasReadAndMaxSeqResp(const GetConversationsHasReadAndMaxSeqResp& from);
  GetConversationsHasReadAndMaxSeqResp(GetConversationsHasReadAndMaxSeqResp&& from) noexcept
    : GetConversationsHasReadAndMaxSeqResp() {
    *this = ::std::move(from);
  }

  inline GetConversationsHasReadAndMaxSeqResp& operator=(const GetConversationsHasReadAndMaxSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationsHasReadAndMaxSeqResp& operator=(GetConversationsHasReadAndMaxSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationsHasReadAndMaxSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationsHasReadAndMaxSeqResp* internal_default_instance() {
    return reinterpret_cast<const GetConversationsHasReadAndMaxSeqResp*>(
               &_GetConversationsHasReadAndMaxSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetConversationsHasReadAndMaxSeqResp& a, GetConversationsHasReadAndMaxSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationsHasReadAndMaxSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationsHasReadAndMaxSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationsHasReadAndMaxSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationsHasReadAndMaxSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationsHasReadAndMaxSeqResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationsHasReadAndMaxSeqResp& from) {
    GetConversationsHasReadAndMaxSeqResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationsHasReadAndMaxSeqResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetConversationsHasReadAndMaxSeqResp";
  }
  protected:
  explicit GetConversationsHasReadAndMaxSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 1,
    kPinnedConversationIDsFieldNumber = 2,
  };
  // map<string, .msg.Seqs> seqs = 1;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >&
      _internal_seqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >*
      _internal_mutable_seqs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >*
      mutable_seqs();

  // repeated string pinnedConversationIDs = 2;
  int pinnedconversationids_size() const;
  private:
  int _internal_pinnedconversationids_size() const;
  public:
  void clear_pinnedconversationids();
  const std::string& pinnedconversationids(int index) const;
  std::string* mutable_pinnedconversationids(int index);
  void set_pinnedconversationids(int index, const std::string& value);
  void set_pinnedconversationids(int index, std::string&& value);
  void set_pinnedconversationids(int index, const char* value);
  void set_pinnedconversationids(int index, const char* value, size_t size);
  std::string* add_pinnedconversationids();
  void add_pinnedconversationids(const std::string& value);
  void add_pinnedconversationids(std::string&& value);
  void add_pinnedconversationids(const char* value);
  void add_pinnedconversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pinnedconversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pinnedconversationids();
  private:
  const std::string& _internal_pinnedconversationids(int index) const;
  std::string* _internal_add_pinnedconversationids();
  public:

  // @@protoc_insertion_point(class_scope:msg.GetConversationsHasReadAndMaxSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetConversationsHasReadAndMaxSeqResp_SeqsEntry_DoNotUse,
        std::string, ::msg::Seqs,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> seqs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pinnedconversationids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetActiveUserReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetActiveUserReq) */ {
 public:
  inline GetActiveUserReq() : GetActiveUserReq(nullptr) {}
  ~GetActiveUserReq() override;
  explicit PROTOBUF_CONSTEXPR GetActiveUserReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveUserReq(const GetActiveUserReq& from);
  GetActiveUserReq(GetActiveUserReq&& from) noexcept
    : GetActiveUserReq() {
    *this = ::std::move(from);
  }

  inline GetActiveUserReq& operator=(const GetActiveUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveUserReq& operator=(GetActiveUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveUserReq* internal_default_instance() {
    return reinterpret_cast<const GetActiveUserReq*>(
               &_GetActiveUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GetActiveUserReq& a, GetActiveUserReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveUserReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveUserReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveUserReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveUserReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveUserReq& from) {
    GetActiveUserReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveUserReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetActiveUserReq";
  }
  protected:
  explicit GetActiveUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaginationFieldNumber = 5,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kAseFieldNumber = 3,
    kGroupFieldNumber = 4,
  };
  // .sdkws.RequestPagination pagination = 5;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sdkws::RequestPagination& pagination() const;
  PROTOBUF_NODISCARD ::sdkws::RequestPagination* release_pagination();
  ::sdkws::RequestPagination* mutable_pagination();
  void set_allocated_pagination(::sdkws::RequestPagination* pagination);
  private:
  const ::sdkws::RequestPagination& _internal_pagination() const;
  ::sdkws::RequestPagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sdkws::RequestPagination* pagination);
  ::sdkws::RequestPagination* unsafe_arena_release_pagination();

  // int64 start = 1;
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 end = 2;
  void clear_end();
  int64_t end() const;
  void set_end(int64_t value);
  private:
  int64_t _internal_end() const;
  void _internal_set_end(int64_t value);
  public:

  // bool ase = 3;
  void clear_ase();
  bool ase() const;
  void set_ase(bool value);
  private:
  bool _internal_ase() const;
  void _internal_set_ase(bool value);
  public:

  // bool group = 4;
  void clear_group();
  bool group() const;
  void set_group(bool value);
  private:
  bool _internal_group() const;
  void _internal_set_group(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetActiveUserReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::RequestPagination* pagination_;
    int64_t start_;
    int64_t end_;
    bool ase_;
    bool group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ActiveUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ActiveUser) */ {
 public:
  inline ActiveUser() : ActiveUser(nullptr) {}
  ~ActiveUser() override;
  explicit PROTOBUF_CONSTEXPR ActiveUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveUser(const ActiveUser& from);
  ActiveUser(ActiveUser&& from) noexcept
    : ActiveUser() {
    *this = ::std::move(from);
  }

  inline ActiveUser& operator=(const ActiveUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveUser& operator=(ActiveUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveUser* internal_default_instance() {
    return reinterpret_cast<const ActiveUser*>(
               &_ActiveUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ActiveUser& a, ActiveUser& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveUser& from) {
    ActiveUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ActiveUser";
  }
  protected:
  explicit ActiveUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .sdkws.UserInfo user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sdkws::UserInfo& user() const;
  PROTOBUF_NODISCARD ::sdkws::UserInfo* release_user();
  ::sdkws::UserInfo* mutable_user();
  void set_allocated_user(::sdkws::UserInfo* user);
  private:
  const ::sdkws::UserInfo& _internal_user() const;
  ::sdkws::UserInfo* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sdkws::UserInfo* user);
  ::sdkws::UserInfo* unsafe_arena_release_user();

  // int64 count = 2;
  void clear_count();
  int64_t count() const;
  void set_count(int64_t value);
  private:
  int64_t _internal_count() const;
  void _internal_set_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ActiveUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::UserInfo* user_;
    int64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetActiveUserResp_DateCountEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetActiveUserResp_DateCountEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetActiveUserResp_DateCountEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  GetActiveUserResp_DateCountEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetActiveUserResp_DateCountEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetActiveUserResp_DateCountEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetActiveUserResp_DateCountEntry_DoNotUse& other);
  static const GetActiveUserResp_DateCountEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetActiveUserResp_DateCountEntry_DoNotUse*>(&_GetActiveUserResp_DateCountEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetActiveUserResp.DateCountEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetActiveUserResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetActiveUserResp) */ {
 public:
  inline GetActiveUserResp() : GetActiveUserResp(nullptr) {}
  ~GetActiveUserResp() override;
  explicit PROTOBUF_CONSTEXPR GetActiveUserResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveUserResp(const GetActiveUserResp& from);
  GetActiveUserResp(GetActiveUserResp&& from) noexcept
    : GetActiveUserResp() {
    *this = ::std::move(from);
  }

  inline GetActiveUserResp& operator=(const GetActiveUserResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveUserResp& operator=(GetActiveUserResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveUserResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveUserResp* internal_default_instance() {
    return reinterpret_cast<const GetActiveUserResp*>(
               &_GetActiveUserResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(GetActiveUserResp& a, GetActiveUserResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveUserResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveUserResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveUserResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveUserResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveUserResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveUserResp& from) {
    GetActiveUserResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveUserResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetActiveUserResp";
  }
  protected:
  explicit GetActiveUserResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDateCountFieldNumber = 3,
    kUsersFieldNumber = 4,
    kMsgCountFieldNumber = 1,
    kUserCountFieldNumber = 2,
  };
  // map<string, int64> dateCount = 3;
  int datecount_size() const;
  private:
  int _internal_datecount_size() const;
  public:
  void clear_datecount();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_datecount() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_datecount();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      datecount() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_datecount();

  // repeated .msg.ActiveUser users = 4;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::msg::ActiveUser* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveUser >*
      mutable_users();
  private:
  const ::msg::ActiveUser& _internal_users(int index) const;
  ::msg::ActiveUser* _internal_add_users();
  public:
  const ::msg::ActiveUser& users(int index) const;
  ::msg::ActiveUser* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveUser >&
      users() const;

  // int64 msgCount = 1;
  void clear_msgcount();
  int64_t msgcount() const;
  void set_msgcount(int64_t value);
  private:
  int64_t _internal_msgcount() const;
  void _internal_set_msgcount(int64_t value);
  public:

  // int64 userCount = 2;
  void clear_usercount();
  int64_t usercount() const;
  void set_usercount(int64_t value);
  private:
  int64_t _internal_usercount() const;
  void _internal_set_usercount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetActiveUserResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetActiveUserResp_DateCountEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> datecount_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveUser > users_;
    int64_t msgcount_;
    int64_t usercount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetActiveGroupReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetActiveGroupReq) */ {
 public:
  inline GetActiveGroupReq() : GetActiveGroupReq(nullptr) {}
  ~GetActiveGroupReq() override;
  explicit PROTOBUF_CONSTEXPR GetActiveGroupReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveGroupReq(const GetActiveGroupReq& from);
  GetActiveGroupReq(GetActiveGroupReq&& from) noexcept
    : GetActiveGroupReq() {
    *this = ::std::move(from);
  }

  inline GetActiveGroupReq& operator=(const GetActiveGroupReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveGroupReq& operator=(GetActiveGroupReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveGroupReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveGroupReq* internal_default_instance() {
    return reinterpret_cast<const GetActiveGroupReq*>(
               &_GetActiveGroupReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(GetActiveGroupReq& a, GetActiveGroupReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveGroupReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveGroupReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveGroupReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveGroupReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveGroupReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveGroupReq& from) {
    GetActiveGroupReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveGroupReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetActiveGroupReq";
  }
  protected:
  explicit GetActiveGroupReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaginationFieldNumber = 4,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kAseFieldNumber = 3,
  };
  // .sdkws.RequestPagination pagination = 4;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sdkws::RequestPagination& pagination() const;
  PROTOBUF_NODISCARD ::sdkws::RequestPagination* release_pagination();
  ::sdkws::RequestPagination* mutable_pagination();
  void set_allocated_pagination(::sdkws::RequestPagination* pagination);
  private:
  const ::sdkws::RequestPagination& _internal_pagination() const;
  ::sdkws::RequestPagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sdkws::RequestPagination* pagination);
  ::sdkws::RequestPagination* unsafe_arena_release_pagination();

  // int64 start = 1;
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 end = 2;
  void clear_end();
  int64_t end() const;
  void set_end(int64_t value);
  private:
  int64_t _internal_end() const;
  void _internal_set_end(int64_t value);
  public:

  // bool ase = 3;
  void clear_ase();
  bool ase() const;
  void set_ase(bool value);
  private:
  bool _internal_ase() const;
  void _internal_set_ase(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetActiveGroupReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::RequestPagination* pagination_;
    int64_t start_;
    int64_t end_;
    bool ase_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ActiveGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ActiveGroup) */ {
 public:
  inline ActiveGroup() : ActiveGroup(nullptr) {}
  ~ActiveGroup() override;
  explicit PROTOBUF_CONSTEXPR ActiveGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveGroup(const ActiveGroup& from);
  ActiveGroup(ActiveGroup&& from) noexcept
    : ActiveGroup() {
    *this = ::std::move(from);
  }

  inline ActiveGroup& operator=(const ActiveGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveGroup& operator=(ActiveGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveGroup* internal_default_instance() {
    return reinterpret_cast<const ActiveGroup*>(
               &_ActiveGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ActiveGroup& a, ActiveGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveGroup& from) {
    ActiveGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ActiveGroup";
  }
  protected:
  explicit ActiveGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .sdkws.GroupInfo group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::sdkws::GroupInfo& group() const;
  PROTOBUF_NODISCARD ::sdkws::GroupInfo* release_group();
  ::sdkws::GroupInfo* mutable_group();
  void set_allocated_group(::sdkws::GroupInfo* group);
  private:
  const ::sdkws::GroupInfo& _internal_group() const;
  ::sdkws::GroupInfo* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::sdkws::GroupInfo* group);
  ::sdkws::GroupInfo* unsafe_arena_release_group();

  // int64 count = 2;
  void clear_count();
  int64_t count() const;
  void set_count(int64_t value);
  private:
  int64_t _internal_count() const;
  void _internal_set_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ActiveGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::GroupInfo* group_;
    int64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetActiveGroupResp_DateCountEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetActiveGroupResp_DateCountEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetActiveGroupResp_DateCountEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  GetActiveGroupResp_DateCountEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetActiveGroupResp_DateCountEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetActiveGroupResp_DateCountEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetActiveGroupResp_DateCountEntry_DoNotUse& other);
  static const GetActiveGroupResp_DateCountEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetActiveGroupResp_DateCountEntry_DoNotUse*>(&_GetActiveGroupResp_DateCountEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetActiveGroupResp.DateCountEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetActiveGroupResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetActiveGroupResp) */ {
 public:
  inline GetActiveGroupResp() : GetActiveGroupResp(nullptr) {}
  ~GetActiveGroupResp() override;
  explicit PROTOBUF_CONSTEXPR GetActiveGroupResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveGroupResp(const GetActiveGroupResp& from);
  GetActiveGroupResp(GetActiveGroupResp&& from) noexcept
    : GetActiveGroupResp() {
    *this = ::std::move(from);
  }

  inline GetActiveGroupResp& operator=(const GetActiveGroupResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveGroupResp& operator=(GetActiveGroupResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveGroupResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveGroupResp* internal_default_instance() {
    return reinterpret_cast<const GetActiveGroupResp*>(
               &_GetActiveGroupResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(GetActiveGroupResp& a, GetActiveGroupResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveGroupResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveGroupResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveGroupResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveGroupResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveGroupResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveGroupResp& from) {
    GetActiveGroupResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveGroupResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetActiveGroupResp";
  }
  protected:
  explicit GetActiveGroupResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDateCountFieldNumber = 3,
    kGroupsFieldNumber = 4,
    kMsgCountFieldNumber = 1,
    kGroupCountFieldNumber = 2,
  };
  // map<string, int64> dateCount = 3;
  int datecount_size() const;
  private:
  int _internal_datecount_size() const;
  public:
  void clear_datecount();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_datecount() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_datecount();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      datecount() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_datecount();

  // repeated .msg.ActiveGroup groups = 4;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::msg::ActiveGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveGroup >*
      mutable_groups();
  private:
  const ::msg::ActiveGroup& _internal_groups(int index) const;
  ::msg::ActiveGroup* _internal_add_groups();
  public:
  const ::msg::ActiveGroup& groups(int index) const;
  ::msg::ActiveGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveGroup >&
      groups() const;

  // int64 msgCount = 1;
  void clear_msgcount();
  int64_t msgcount() const;
  void set_msgcount(int64_t value);
  private:
  int64_t _internal_msgcount() const;
  void _internal_set_msgcount(int64_t value);
  public:

  // int64 groupCount = 2;
  void clear_groupcount();
  int64_t groupcount() const;
  void set_groupcount(int64_t value);
  private:
  int64_t _internal_groupcount() const;
  void _internal_set_groupcount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetActiveGroupResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetActiveGroupResp_DateCountEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> datecount_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveGroup > groups_;
    int64_t msgcount_;
    int64_t groupcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SearchMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SearchMessageReq) */ {
 public:
  inline SearchMessageReq() : SearchMessageReq(nullptr) {}
  ~SearchMessageReq() override;
  explicit PROTOBUF_CONSTEXPR SearchMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchMessageReq(const SearchMessageReq& from);
  SearchMessageReq(SearchMessageReq&& from) noexcept
    : SearchMessageReq() {
    *this = ::std::move(from);
  }

  inline SearchMessageReq& operator=(const SearchMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMessageReq& operator=(SearchMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchMessageReq* internal_default_instance() {
    return reinterpret_cast<const SearchMessageReq*>(
               &_SearchMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SearchMessageReq& a, SearchMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchMessageReq& from) {
    SearchMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SearchMessageReq";
  }
  protected:
  explicit SearchMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendIDFieldNumber = 1,
    kRecvIDFieldNumber = 2,
    kSendTimeFieldNumber = 4,
    kPaginationFieldNumber = 6,
    kContentTypeFieldNumber = 3,
    kSessionTypeFieldNumber = 5,
  };
  // string sendID = 1;
  void clear_sendid();
  const std::string& sendid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendid();
  PROTOBUF_NODISCARD std::string* release_sendid();
  void set_allocated_sendid(std::string* sendid);
  private:
  const std::string& _internal_sendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendid(const std::string& value);
  std::string* _internal_mutable_sendid();
  public:

  // string recvID = 2;
  void clear_recvid();
  const std::string& recvid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recvid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recvid();
  PROTOBUF_NODISCARD std::string* release_recvid();
  void set_allocated_recvid(std::string* recvid);
  private:
  const std::string& _internal_recvid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recvid(const std::string& value);
  std::string* _internal_mutable_recvid();
  public:

  // string sendTime = 4;
  void clear_sendtime();
  const std::string& sendtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendtime();
  PROTOBUF_NODISCARD std::string* release_sendtime();
  void set_allocated_sendtime(std::string* sendtime);
  private:
  const std::string& _internal_sendtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendtime(const std::string& value);
  std::string* _internal_mutable_sendtime();
  public:

  // .sdkws.RequestPagination pagination = 6;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::sdkws::RequestPagination& pagination() const;
  PROTOBUF_NODISCARD ::sdkws::RequestPagination* release_pagination();
  ::sdkws::RequestPagination* mutable_pagination();
  void set_allocated_pagination(::sdkws::RequestPagination* pagination);
  private:
  const ::sdkws::RequestPagination& _internal_pagination() const;
  ::sdkws::RequestPagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::sdkws::RequestPagination* pagination);
  ::sdkws::RequestPagination* unsafe_arena_release_pagination();

  // int32 contentType = 3;
  void clear_contenttype();
  int32_t contenttype() const;
  void set_contenttype(int32_t value);
  private:
  int32_t _internal_contenttype() const;
  void _internal_set_contenttype(int32_t value);
  public:

  // int32 sessionType = 5;
  void clear_sessiontype();
  int32_t sessiontype() const;
  void set_sessiontype(int32_t value);
  private:
  int32_t _internal_sessiontype() const;
  void _internal_set_sessiontype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SearchMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recvid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendtime_;
    ::sdkws::RequestPagination* pagination_;
    int32_t contenttype_;
    int32_t sessiontype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SearchChatLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SearchChatLog) */ {
 public:
  inline SearchChatLog() : SearchChatLog(nullptr) {}
  ~SearchChatLog() override;
  explicit PROTOBUF_CONSTEXPR SearchChatLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchChatLog(const SearchChatLog& from);
  SearchChatLog(SearchChatLog&& from) noexcept
    : SearchChatLog() {
    *this = ::std::move(from);
  }

  inline SearchChatLog& operator=(const SearchChatLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchChatLog& operator=(SearchChatLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchChatLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchChatLog* internal_default_instance() {
    return reinterpret_cast<const SearchChatLog*>(
               &_SearchChatLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(SearchChatLog& a, SearchChatLog& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchChatLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchChatLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchChatLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchChatLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchChatLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchChatLog& from) {
    SearchChatLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchChatLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SearchChatLog";
  }
  protected:
  explicit SearchChatLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatLogFieldNumber = 1,
    kIsRevokedFieldNumber = 2,
  };
  // .msg.ChatLog chatLog = 1;
  bool has_chatlog() const;
  private:
  bool _internal_has_chatlog() const;
  public:
  void clear_chatlog();
  const ::msg::ChatLog& chatlog() const;
  PROTOBUF_NODISCARD ::msg::ChatLog* release_chatlog();
  ::msg::ChatLog* mutable_chatlog();
  void set_allocated_chatlog(::msg::ChatLog* chatlog);
  private:
  const ::msg::ChatLog& _internal_chatlog() const;
  ::msg::ChatLog* _internal_mutable_chatlog();
  public:
  void unsafe_arena_set_allocated_chatlog(
      ::msg::ChatLog* chatlog);
  ::msg::ChatLog* unsafe_arena_release_chatlog();

  // bool isRevoked = 2;
  void clear_isrevoked();
  bool isrevoked() const;
  void set_isrevoked(bool value);
  private:
  bool _internal_isrevoked() const;
  void _internal_set_isrevoked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SearchChatLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::msg::ChatLog* chatlog_;
    bool isrevoked_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SearchedMsgData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SearchedMsgData) */ {
 public:
  inline SearchedMsgData() : SearchedMsgData(nullptr) {}
  ~SearchedMsgData() override;
  explicit PROTOBUF_CONSTEXPR SearchedMsgData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchedMsgData(const SearchedMsgData& from);
  SearchedMsgData(SearchedMsgData&& from) noexcept
    : SearchedMsgData() {
    *this = ::std::move(from);
  }

  inline SearchedMsgData& operator=(const SearchedMsgData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchedMsgData& operator=(SearchedMsgData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchedMsgData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchedMsgData* internal_default_instance() {
    return reinterpret_cast<const SearchedMsgData*>(
               &_SearchedMsgData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(SearchedMsgData& a, SearchedMsgData& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchedMsgData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchedMsgData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchedMsgData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchedMsgData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchedMsgData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchedMsgData& from) {
    SearchedMsgData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchedMsgData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SearchedMsgData";
  }
  protected:
  explicit SearchedMsgData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 1,
    kIsRevokedFieldNumber = 2,
  };
  // .sdkws.MsgData msgData = 1;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // bool isRevoked = 2;
  void clear_isrevoked();
  bool isrevoked() const;
  void set_isrevoked(bool value);
  private:
  bool _internal_isrevoked() const;
  void _internal_set_isrevoked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SearchedMsgData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sdkws::MsgData* msgdata_;
    bool isrevoked_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SearchMessageResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SearchMessageResp) */ {
 public:
  inline SearchMessageResp() : SearchMessageResp(nullptr) {}
  ~SearchMessageResp() override;
  explicit PROTOBUF_CONSTEXPR SearchMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchMessageResp(const SearchMessageResp& from);
  SearchMessageResp(SearchMessageResp&& from) noexcept
    : SearchMessageResp() {
    *this = ::std::move(from);
  }

  inline SearchMessageResp& operator=(const SearchMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMessageResp& operator=(SearchMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchMessageResp* internal_default_instance() {
    return reinterpret_cast<const SearchMessageResp*>(
               &_SearchMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(SearchMessageResp& a, SearchMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMessageResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchMessageResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchMessageResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchMessageResp& from) {
    SearchMessageResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMessageResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SearchMessageResp";
  }
  protected:
  explicit SearchMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatLogsFieldNumber = 1,
    kChatLogsNumFieldNumber = 2,
  };
  // repeated .msg.SearchChatLog chatLogs = 1;
  int chatlogs_size() const;
  private:
  int _internal_chatlogs_size() const;
  public:
  void clear_chatlogs();
  ::msg::SearchChatLog* mutable_chatlogs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::SearchChatLog >*
      mutable_chatlogs();
  private:
  const ::msg::SearchChatLog& _internal_chatlogs(int index) const;
  ::msg::SearchChatLog* _internal_add_chatlogs();
  public:
  const ::msg::SearchChatLog& chatlogs(int index) const;
  ::msg::SearchChatLog* add_chatlogs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::SearchChatLog >&
      chatlogs() const;

  // int32 chatLogsNum = 2;
  void clear_chatlogsnum();
  int32_t chatlogsnum() const;
  void set_chatlogsnum(int32_t value);
  private:
  int32_t _internal_chatlogsnum() const;
  void _internal_set_chatlogsnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SearchMessageResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::SearchChatLog > chatlogs_;
    int32_t chatlogsnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ChatLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ChatLog) */ {
 public:
  inline ChatLog() : ChatLog(nullptr) {}
  ~ChatLog() override;
  explicit PROTOBUF_CONSTEXPR ChatLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatLog(const ChatLog& from);
  ChatLog(ChatLog&& from) noexcept
    : ChatLog() {
    *this = ::std::move(from);
  }

  inline ChatLog& operator=(const ChatLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatLog& operator=(ChatLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatLog* internal_default_instance() {
    return reinterpret_cast<const ChatLog*>(
               &_ChatLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(ChatLog& a, ChatLog& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatLog& from) {
    ChatLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ChatLog";
  }
  protected:
  explicit ChatLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerMsgIDFieldNumber = 1,
    kClientMsgIDFieldNumber = 2,
    kSendIDFieldNumber = 3,
    kRecvIDFieldNumber = 4,
    kGroupIDFieldNumber = 5,
    kRecvNicknameFieldNumber = 6,
    kSenderNicknameFieldNumber = 8,
    kSenderFaceURLFieldNumber = 9,
    kGroupNameFieldNumber = 10,
    kContentFieldNumber = 14,
    kExFieldNumber = 18,
    kGroupFaceURLFieldNumber = 19,
    kGroupOwnerFieldNumber = 22,
    kSenderPlatformIDFieldNumber = 7,
    kSessionTypeFieldNumber = 11,
    kMsgFromFieldNumber = 12,
    kContentTypeFieldNumber = 13,
    kSendTimeFieldNumber = 16,
    kCreateTimeFieldNumber = 17,
    kStatusFieldNumber = 15,
    kGroupMemberCountFieldNumber = 20,
    kSeqFieldNumber = 21,
    kGroupTypeFieldNumber = 23,
  };
  // string serverMsgID = 1;
  void clear_servermsgid();
  const std::string& servermsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servermsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servermsgid();
  PROTOBUF_NODISCARD std::string* release_servermsgid();
  void set_allocated_servermsgid(std::string* servermsgid);
  private:
  const std::string& _internal_servermsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servermsgid(const std::string& value);
  std::string* _internal_mutable_servermsgid();
  public:

  // string clientMsgID = 2;
  void clear_clientmsgid();
  const std::string& clientmsgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientmsgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientmsgid();
  PROTOBUF_NODISCARD std::string* release_clientmsgid();
  void set_allocated_clientmsgid(std::string* clientmsgid);
  private:
  const std::string& _internal_clientmsgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientmsgid(const std::string& value);
  std::string* _internal_mutable_clientmsgid();
  public:

  // string sendID = 3;
  void clear_sendid();
  const std::string& sendid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendid();
  PROTOBUF_NODISCARD std::string* release_sendid();
  void set_allocated_sendid(std::string* sendid);
  private:
  const std::string& _internal_sendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendid(const std::string& value);
  std::string* _internal_mutable_sendid();
  public:

  // string recvID = 4;
  void clear_recvid();
  const std::string& recvid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recvid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recvid();
  PROTOBUF_NODISCARD std::string* release_recvid();
  void set_allocated_recvid(std::string* recvid);
  private:
  const std::string& _internal_recvid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recvid(const std::string& value);
  std::string* _internal_mutable_recvid();
  public:

  // string groupID = 5;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // string recvNickname = 6;
  void clear_recvnickname();
  const std::string& recvnickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recvnickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recvnickname();
  PROTOBUF_NODISCARD std::string* release_recvnickname();
  void set_allocated_recvnickname(std::string* recvnickname);
  private:
  const std::string& _internal_recvnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recvnickname(const std::string& value);
  std::string* _internal_mutable_recvnickname();
  public:

  // string senderNickname = 8;
  void clear_sendernickname();
  const std::string& sendernickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendernickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendernickname();
  PROTOBUF_NODISCARD std::string* release_sendernickname();
  void set_allocated_sendernickname(std::string* sendernickname);
  private:
  const std::string& _internal_sendernickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendernickname(const std::string& value);
  std::string* _internal_mutable_sendernickname();
  public:

  // string senderFaceURL = 9;
  void clear_senderfaceurl();
  const std::string& senderfaceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderfaceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderfaceurl();
  PROTOBUF_NODISCARD std::string* release_senderfaceurl();
  void set_allocated_senderfaceurl(std::string* senderfaceurl);
  private:
  const std::string& _internal_senderfaceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderfaceurl(const std::string& value);
  std::string* _internal_mutable_senderfaceurl();
  public:

  // string groupName = 10;
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // string content = 14;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string ex = 18;
  void clear_ex();
  const std::string& ex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ex();
  PROTOBUF_NODISCARD std::string* release_ex();
  void set_allocated_ex(std::string* ex);
  private:
  const std::string& _internal_ex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ex(const std::string& value);
  std::string* _internal_mutable_ex();
  public:

  // string groupFaceURL = 19;
  void clear_groupfaceurl();
  const std::string& groupfaceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupfaceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupfaceurl();
  PROTOBUF_NODISCARD std::string* release_groupfaceurl();
  void set_allocated_groupfaceurl(std::string* groupfaceurl);
  private:
  const std::string& _internal_groupfaceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupfaceurl(const std::string& value);
  std::string* _internal_mutable_groupfaceurl();
  public:

  // string groupOwner = 22;
  void clear_groupowner();
  const std::string& groupowner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupowner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupowner();
  PROTOBUF_NODISCARD std::string* release_groupowner();
  void set_allocated_groupowner(std::string* groupowner);
  private:
  const std::string& _internal_groupowner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupowner(const std::string& value);
  std::string* _internal_mutable_groupowner();
  public:

  // int32 senderPlatformID = 7;
  void clear_senderplatformid();
  int32_t senderplatformid() const;
  void set_senderplatformid(int32_t value);
  private:
  int32_t _internal_senderplatformid() const;
  void _internal_set_senderplatformid(int32_t value);
  public:

  // int32 sessionType = 11;
  void clear_sessiontype();
  int32_t sessiontype() const;
  void set_sessiontype(int32_t value);
  private:
  int32_t _internal_sessiontype() const;
  void _internal_set_sessiontype(int32_t value);
  public:

  // int32 msgFrom = 12;
  void clear_msgfrom();
  int32_t msgfrom() const;
  void set_msgfrom(int32_t value);
  private:
  int32_t _internal_msgfrom() const;
  void _internal_set_msgfrom(int32_t value);
  public:

  // int32 contentType = 13;
  void clear_contenttype();
  int32_t contenttype() const;
  void set_contenttype(int32_t value);
  private:
  int32_t _internal_contenttype() const;
  void _internal_set_contenttype(int32_t value);
  public:

  // int64 sendTime = 16;
  void clear_sendtime();
  int64_t sendtime() const;
  void set_sendtime(int64_t value);
  private:
  int64_t _internal_sendtime() const;
  void _internal_set_sendtime(int64_t value);
  public:

  // int64 createTime = 17;
  void clear_createtime();
  int64_t createtime() const;
  void set_createtime(int64_t value);
  private:
  int64_t _internal_createtime() const;
  void _internal_set_createtime(int64_t value);
  public:

  // int32 status = 15;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // uint32 groupMemberCount = 20;
  void clear_groupmembercount();
  uint32_t groupmembercount() const;
  void set_groupmembercount(uint32_t value);
  private:
  uint32_t _internal_groupmembercount() const;
  void _internal_set_groupmembercount(uint32_t value);
  public:

  // int64 seq = 21;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 groupType = 23;
  void clear_grouptype();
  int32_t grouptype() const;
  void set_grouptype(int32_t value);
  private:
  int32_t _internal_grouptype() const;
  void _internal_set_grouptype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ChatLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servermsgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientmsgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recvid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recvnickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendernickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderfaceurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ex_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupfaceurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupowner_;
    int32_t senderplatformid_;
    int32_t sessiontype_;
    int32_t msgfrom_;
    int32_t contenttype_;
    int64_t sendtime_;
    int64_t createtime_;
    int32_t status_;
    uint32_t groupmembercount_;
    int64_t seq_;
    int32_t grouptype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class batchSendMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.batchSendMessageReq) */ {
 public:
  inline batchSendMessageReq() : batchSendMessageReq(nullptr) {}
  ~batchSendMessageReq() override;
  explicit PROTOBUF_CONSTEXPR batchSendMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  batchSendMessageReq(const batchSendMessageReq& from);
  batchSendMessageReq(batchSendMessageReq&& from) noexcept
    : batchSendMessageReq() {
    *this = ::std::move(from);
  }

  inline batchSendMessageReq& operator=(const batchSendMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline batchSendMessageReq& operator=(batchSendMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const batchSendMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const batchSendMessageReq* internal_default_instance() {
    return reinterpret_cast<const batchSendMessageReq*>(
               &_batchSendMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(batchSendMessageReq& a, batchSendMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(batchSendMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(batchSendMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  batchSendMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<batchSendMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const batchSendMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const batchSendMessageReq& from) {
    batchSendMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(batchSendMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.batchSendMessageReq";
  }
  protected:
  explicit batchSendMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecvIDListFieldNumber = 1,
    kMsgDataFieldNumber = 2,
  };
  // repeated string recvIDList = 1;
  int recvidlist_size() const;
  private:
  int _internal_recvidlist_size() const;
  public:
  void clear_recvidlist();
  const std::string& recvidlist(int index) const;
  std::string* mutable_recvidlist(int index);
  void set_recvidlist(int index, const std::string& value);
  void set_recvidlist(int index, std::string&& value);
  void set_recvidlist(int index, const char* value);
  void set_recvidlist(int index, const char* value, size_t size);
  std::string* add_recvidlist();
  void add_recvidlist(const std::string& value);
  void add_recvidlist(std::string&& value);
  void add_recvidlist(const char* value);
  void add_recvidlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recvidlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recvidlist();
  private:
  const std::string& _internal_recvidlist(int index) const;
  std::string* _internal_add_recvidlist();
  public:

  // .sdkws.MsgData msgData = 2;
  bool has_msgdata() const;
  private:
  bool _internal_has_msgdata() const;
  public:
  void clear_msgdata();
  const ::sdkws::MsgData& msgdata() const;
  PROTOBUF_NODISCARD ::sdkws::MsgData* release_msgdata();
  ::sdkws::MsgData* mutable_msgdata();
  void set_allocated_msgdata(::sdkws::MsgData* msgdata);
  private:
  const ::sdkws::MsgData& _internal_msgdata() const;
  ::sdkws::MsgData* _internal_mutable_msgdata();
  public:
  void unsafe_arena_set_allocated_msgdata(
      ::sdkws::MsgData* msgdata);
  ::sdkws::MsgData* unsafe_arena_release_msgdata();

  // @@protoc_insertion_point(class_scope:msg.batchSendMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recvidlist_;
    ::sdkws::MsgData* msgdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class batchSendMessageResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.batchSendMessageResp) */ {
 public:
  inline batchSendMessageResp() : batchSendMessageResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR batchSendMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  batchSendMessageResp(const batchSendMessageResp& from);
  batchSendMessageResp(batchSendMessageResp&& from) noexcept
    : batchSendMessageResp() {
    *this = ::std::move(from);
  }

  inline batchSendMessageResp& operator=(const batchSendMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline batchSendMessageResp& operator=(batchSendMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const batchSendMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const batchSendMessageResp* internal_default_instance() {
    return reinterpret_cast<const batchSendMessageResp*>(
               &_batchSendMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(batchSendMessageResp& a, batchSendMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(batchSendMessageResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(batchSendMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  batchSendMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<batchSendMessageResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const batchSendMessageResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const batchSendMessageResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.batchSendMessageResp";
  }
  protected:
  explicit batchSendMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.batchSendMessageResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetServerTimeReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.GetServerTimeReq) */ {
 public:
  inline GetServerTimeReq() : GetServerTimeReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetServerTimeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerTimeReq(const GetServerTimeReq& from);
  GetServerTimeReq(GetServerTimeReq&& from) noexcept
    : GetServerTimeReq() {
    *this = ::std::move(from);
  }

  inline GetServerTimeReq& operator=(const GetServerTimeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerTimeReq& operator=(GetServerTimeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerTimeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerTimeReq* internal_default_instance() {
    return reinterpret_cast<const GetServerTimeReq*>(
               &_GetServerTimeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(GetServerTimeReq& a, GetServerTimeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerTimeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerTimeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerTimeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerTimeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetServerTimeReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetServerTimeReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetServerTimeReq";
  }
  protected:
  explicit GetServerTimeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.GetServerTimeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetServerTimeResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetServerTimeResp) */ {
 public:
  inline GetServerTimeResp() : GetServerTimeResp(nullptr) {}
  ~GetServerTimeResp() override;
  explicit PROTOBUF_CONSTEXPR GetServerTimeResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerTimeResp(const GetServerTimeResp& from);
  GetServerTimeResp(GetServerTimeResp&& from) noexcept
    : GetServerTimeResp() {
    *this = ::std::move(from);
  }

  inline GetServerTimeResp& operator=(const GetServerTimeResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerTimeResp& operator=(GetServerTimeResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerTimeResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerTimeResp* internal_default_instance() {
    return reinterpret_cast<const GetServerTimeResp*>(
               &_GetServerTimeResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(GetServerTimeResp& a, GetServerTimeResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerTimeResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerTimeResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerTimeResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerTimeResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServerTimeResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServerTimeResp& from) {
    GetServerTimeResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerTimeResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetServerTimeResp";
  }
  protected:
  explicit GetServerTimeResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerTimeFieldNumber = 1,
  };
  // int64 serverTime = 1;
  void clear_servertime();
  int64_t servertime() const;
  void set_servertime(int64_t value);
  private:
  int64_t _internal_servertime() const;
  void _internal_set_servertime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetServerTimeResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t servertime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ClearMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ClearMsgReq) */ {
 public:
  inline ClearMsgReq() : ClearMsgReq(nullptr) {}
  ~ClearMsgReq() override;
  explicit PROTOBUF_CONSTEXPR ClearMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearMsgReq(const ClearMsgReq& from);
  ClearMsgReq(ClearMsgReq&& from) noexcept
    : ClearMsgReq() {
    *this = ::std::move(from);
  }

  inline ClearMsgReq& operator=(const ClearMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearMsgReq& operator=(ClearMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearMsgReq* internal_default_instance() {
    return reinterpret_cast<const ClearMsgReq*>(
               &_ClearMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(ClearMsgReq& a, ClearMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearMsgReq& from) {
    ClearMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ClearMsgReq";
  }
  protected:
  explicit ClearMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 1,
  };
  // repeated string conversations = 1;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  const std::string& conversations(int index) const;
  std::string* mutable_conversations(int index);
  void set_conversations(int index, const std::string& value);
  void set_conversations(int index, std::string&& value);
  void set_conversations(int index, const char* value);
  void set_conversations(int index, const char* value, size_t size);
  std::string* add_conversations();
  void add_conversations(const std::string& value);
  void add_conversations(std::string&& value);
  void add_conversations(const char* value);
  void add_conversations(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversations();
  private:
  const std::string& _internal_conversations(int index) const;
  std::string* _internal_add_conversations();
  public:

  // @@protoc_insertion_point(class_scope:msg.ClearMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ClearMsgResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.ClearMsgResp) */ {
 public:
  inline ClearMsgResp() : ClearMsgResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClearMsgResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearMsgResp(const ClearMsgResp& from);
  ClearMsgResp(ClearMsgResp&& from) noexcept
    : ClearMsgResp() {
    *this = ::std::move(from);
  }

  inline ClearMsgResp& operator=(const ClearMsgResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearMsgResp& operator=(ClearMsgResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearMsgResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearMsgResp* internal_default_instance() {
    return reinterpret_cast<const ClearMsgResp*>(
               &_ClearMsgResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ClearMsgResp& a, ClearMsgResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearMsgResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearMsgResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearMsgResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearMsgResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClearMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClearMsgResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ClearMsgResp";
  }
  protected:
  explicit ClearMsgResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.ClearMsgResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DestructMsgsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.DestructMsgsReq) */ {
 public:
  inline DestructMsgsReq() : DestructMsgsReq(nullptr) {}
  ~DestructMsgsReq() override;
  explicit PROTOBUF_CONSTEXPR DestructMsgsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestructMsgsReq(const DestructMsgsReq& from);
  DestructMsgsReq(DestructMsgsReq&& from) noexcept
    : DestructMsgsReq() {
    *this = ::std::move(from);
  }

  inline DestructMsgsReq& operator=(const DestructMsgsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestructMsgsReq& operator=(DestructMsgsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestructMsgsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestructMsgsReq* internal_default_instance() {
    return reinterpret_cast<const DestructMsgsReq*>(
               &_DestructMsgsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(DestructMsgsReq& a, DestructMsgsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DestructMsgsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestructMsgsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestructMsgsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestructMsgsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestructMsgsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DestructMsgsReq& from) {
    DestructMsgsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestructMsgsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DestructMsgsReq";
  }
  protected:
  explicit DestructMsgsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 limit = 2;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.DestructMsgsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class DestructMsgsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.DestructMsgsResp) */ {
 public:
  inline DestructMsgsResp() : DestructMsgsResp(nullptr) {}
  ~DestructMsgsResp() override;
  explicit PROTOBUF_CONSTEXPR DestructMsgsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestructMsgsResp(const DestructMsgsResp& from);
  DestructMsgsResp(DestructMsgsResp&& from) noexcept
    : DestructMsgsResp() {
    *this = ::std::move(from);
  }

  inline DestructMsgsResp& operator=(const DestructMsgsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestructMsgsResp& operator=(DestructMsgsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestructMsgsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestructMsgsResp* internal_default_instance() {
    return reinterpret_cast<const DestructMsgsResp*>(
               &_DestructMsgsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(DestructMsgsResp& a, DestructMsgsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DestructMsgsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestructMsgsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestructMsgsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestructMsgsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestructMsgsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DestructMsgsResp& from) {
    DestructMsgsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestructMsgsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.DestructMsgsResp";
  }
  protected:
  explicit DestructMsgsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.DestructMsgsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetUserConversationsMinSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SetUserConversationsMinSeqReq) */ {
 public:
  inline SetUserConversationsMinSeqReq() : SetUserConversationsMinSeqReq(nullptr) {}
  ~SetUserConversationsMinSeqReq() override;
  explicit PROTOBUF_CONSTEXPR SetUserConversationsMinSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserConversationsMinSeqReq(const SetUserConversationsMinSeqReq& from);
  SetUserConversationsMinSeqReq(SetUserConversationsMinSeqReq&& from) noexcept
    : SetUserConversationsMinSeqReq() {
    *this = ::std::move(from);
  }

  inline SetUserConversationsMinSeqReq& operator=(const SetUserConversationsMinSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserConversationsMinSeqReq& operator=(SetUserConversationsMinSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserConversationsMinSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserConversationsMinSeqReq* internal_default_instance() {
    return reinterpret_cast<const SetUserConversationsMinSeqReq*>(
               &_SetUserConversationsMinSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SetUserConversationsMinSeqReq& a, SetUserConversationsMinSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserConversationsMinSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserConversationsMinSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserConversationsMinSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserConversationsMinSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetUserConversationsMinSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetUserConversationsMinSeqReq& from) {
    SetUserConversationsMinSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUserConversationsMinSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetUserConversationsMinSeqReq";
  }
  protected:
  explicit SetUserConversationsMinSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDsFieldNumber = 1,
    kConversationIDFieldNumber = 2,
    kSeqFieldNumber = 3,
  };
  // repeated string userIDs = 1;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  const std::string& userids(int index) const;
  std::string* mutable_userids(int index);
  void set_userids(int index, const std::string& value);
  void set_userids(int index, std::string&& value);
  void set_userids(int index, const char* value);
  void set_userids(int index, const char* value, size_t size);
  std::string* add_userids();
  void add_userids(const std::string& value);
  void add_userids(std::string&& value);
  void add_userids(const char* value);
  void add_userids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userids();
  private:
  const std::string& _internal_userids(int index) const;
  std::string* _internal_add_userids();
  public:

  // string conversationID = 2;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 seq = 3;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SetUserConversationsMinSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t seq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetUserConversationsMinSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.SetUserConversationsMinSeqResp) */ {
 public:
  inline SetUserConversationsMinSeqResp() : SetUserConversationsMinSeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetUserConversationsMinSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserConversationsMinSeqResp(const SetUserConversationsMinSeqResp& from);
  SetUserConversationsMinSeqResp(SetUserConversationsMinSeqResp&& from) noexcept
    : SetUserConversationsMinSeqResp() {
    *this = ::std::move(from);
  }

  inline SetUserConversationsMinSeqResp& operator=(const SetUserConversationsMinSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserConversationsMinSeqResp& operator=(SetUserConversationsMinSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserConversationsMinSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserConversationsMinSeqResp* internal_default_instance() {
    return reinterpret_cast<const SetUserConversationsMinSeqResp*>(
               &_SetUserConversationsMinSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(SetUserConversationsMinSeqResp& a, SetUserConversationsMinSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserConversationsMinSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserConversationsMinSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserConversationsMinSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserConversationsMinSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetUserConversationsMinSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetUserConversationsMinSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetUserConversationsMinSeqResp";
  }
  protected:
  explicit SetUserConversationsMinSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.SetUserConversationsMinSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ConversationSeqs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ConversationSeqs) */ {
 public:
  inline ConversationSeqs() : ConversationSeqs(nullptr) {}
  ~ConversationSeqs() override;
  explicit PROTOBUF_CONSTEXPR ConversationSeqs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConversationSeqs(const ConversationSeqs& from);
  ConversationSeqs(ConversationSeqs&& from) noexcept
    : ConversationSeqs() {
    *this = ::std::move(from);
  }

  inline ConversationSeqs& operator=(const ConversationSeqs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationSeqs& operator=(ConversationSeqs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConversationSeqs& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConversationSeqs* internal_default_instance() {
    return reinterpret_cast<const ConversationSeqs*>(
               &_ConversationSeqs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ConversationSeqs& a, ConversationSeqs& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationSeqs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationSeqs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConversationSeqs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConversationSeqs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConversationSeqs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConversationSeqs& from) {
    ConversationSeqs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationSeqs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ConversationSeqs";
  }
  protected:
  explicit ConversationSeqs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 3,
    kConversationIDFieldNumber = 2,
  };
  // repeated int64 seqs = 3;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  int64_t _internal_seqs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_seqs() const;
  void _internal_add_seqs(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_seqs();
  public:
  int64_t seqs(int index) const;
  void set_seqs(int index, int64_t value);
  void add_seqs(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_seqs();

  // string conversationID = 2;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // @@protoc_insertion_point(class_scope:msg.ConversationSeqs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > seqs_;
    mutable std::atomic<int> _seqs_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetSeqMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetSeqMessageReq) */ {
 public:
  inline GetSeqMessageReq() : GetSeqMessageReq(nullptr) {}
  ~GetSeqMessageReq() override;
  explicit PROTOBUF_CONSTEXPR GetSeqMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSeqMessageReq(const GetSeqMessageReq& from);
  GetSeqMessageReq(GetSeqMessageReq&& from) noexcept
    : GetSeqMessageReq() {
    *this = ::std::move(from);
  }

  inline GetSeqMessageReq& operator=(const GetSeqMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSeqMessageReq& operator=(GetSeqMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSeqMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSeqMessageReq* internal_default_instance() {
    return reinterpret_cast<const GetSeqMessageReq*>(
               &_GetSeqMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(GetSeqMessageReq& a, GetSeqMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSeqMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSeqMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSeqMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSeqMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSeqMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSeqMessageReq& from) {
    GetSeqMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSeqMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetSeqMessageReq";
  }
  protected:
  explicit GetSeqMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
    kUserIDFieldNumber = 1,
    kOrderFieldNumber = 3,
  };
  // repeated .msg.ConversationSeqs conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::msg::ConversationSeqs* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ConversationSeqs >*
      mutable_conversations();
  private:
  const ::msg::ConversationSeqs& _internal_conversations(int index) const;
  ::msg::ConversationSeqs* _internal_add_conversations();
  public:
  const ::msg::ConversationSeqs& conversations(int index) const;
  ::msg::ConversationSeqs* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ConversationSeqs >&
      conversations() const;

  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sdkws.PullOrder order = 3;
  void clear_order();
  ::sdkws::PullOrder order() const;
  void set_order(::sdkws::PullOrder value);
  private:
  ::sdkws::PullOrder _internal_order() const;
  void _internal_set_order(::sdkws::PullOrder value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetSeqMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ConversationSeqs > conversations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int order_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetSeqMessageResp_MsgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetSeqMessageResp_MsgsEntry_DoNotUse, 
    std::string, ::sdkws::PullMsgs,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetSeqMessageResp_MsgsEntry_DoNotUse, 
    std::string, ::sdkws::PullMsgs,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetSeqMessageResp_MsgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetSeqMessageResp_MsgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetSeqMessageResp_MsgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetSeqMessageResp_MsgsEntry_DoNotUse& other);
  static const GetSeqMessageResp_MsgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetSeqMessageResp_MsgsEntry_DoNotUse*>(&_GetSeqMessageResp_MsgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetSeqMessageResp.MsgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetSeqMessageResp_NotificationMsgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetSeqMessageResp_NotificationMsgsEntry_DoNotUse, 
    std::string, ::sdkws::PullMsgs,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetSeqMessageResp_NotificationMsgsEntry_DoNotUse, 
    std::string, ::sdkws::PullMsgs,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetSeqMessageResp_NotificationMsgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetSeqMessageResp_NotificationMsgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetSeqMessageResp_NotificationMsgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetSeqMessageResp_NotificationMsgsEntry_DoNotUse& other);
  static const GetSeqMessageResp_NotificationMsgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetSeqMessageResp_NotificationMsgsEntry_DoNotUse*>(&_GetSeqMessageResp_NotificationMsgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetSeqMessageResp.NotificationMsgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetSeqMessageResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetSeqMessageResp) */ {
 public:
  inline GetSeqMessageResp() : GetSeqMessageResp(nullptr) {}
  ~GetSeqMessageResp() override;
  explicit PROTOBUF_CONSTEXPR GetSeqMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSeqMessageResp(const GetSeqMessageResp& from);
  GetSeqMessageResp(GetSeqMessageResp&& from) noexcept
    : GetSeqMessageResp() {
    *this = ::std::move(from);
  }

  inline GetSeqMessageResp& operator=(const GetSeqMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSeqMessageResp& operator=(GetSeqMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSeqMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSeqMessageResp* internal_default_instance() {
    return reinterpret_cast<const GetSeqMessageResp*>(
               &_GetSeqMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(GetSeqMessageResp& a, GetSeqMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSeqMessageResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSeqMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSeqMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSeqMessageResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSeqMessageResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSeqMessageResp& from) {
    GetSeqMessageResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSeqMessageResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetSeqMessageResp";
  }
  protected:
  explicit GetSeqMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 1,
    kNotificationMsgsFieldNumber = 2,
  };
  // map<string, .sdkws.PullMsgs> msgs = 1;
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;
  public:
  void clear_msgs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
      _internal_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
      _internal_mutable_msgs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
      msgs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
      mutable_msgs();

  // map<string, .sdkws.PullMsgs> notificationMsgs = 2;
  int notificationmsgs_size() const;
  private:
  int _internal_notificationmsgs_size() const;
  public:
  void clear_notificationmsgs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
      _internal_notificationmsgs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
      _internal_mutable_notificationmsgs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
      notificationmsgs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
      mutable_notificationmsgs();

  // @@protoc_insertion_point(class_scope:msg.GetSeqMessageResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetSeqMessageResp_MsgsEntry_DoNotUse,
        std::string, ::sdkws::PullMsgs,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetSeqMessageResp_NotificationMsgsEntry_DoNotUse,
        std::string, ::sdkws::PullMsgs,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> notificationmsgs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetActiveConversationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetActiveConversationReq) */ {
 public:
  inline GetActiveConversationReq() : GetActiveConversationReq(nullptr) {}
  ~GetActiveConversationReq() override;
  explicit PROTOBUF_CONSTEXPR GetActiveConversationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveConversationReq(const GetActiveConversationReq& from);
  GetActiveConversationReq(GetActiveConversationReq&& from) noexcept
    : GetActiveConversationReq() {
    *this = ::std::move(from);
  }

  inline GetActiveConversationReq& operator=(const GetActiveConversationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveConversationReq& operator=(GetActiveConversationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveConversationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveConversationReq* internal_default_instance() {
    return reinterpret_cast<const GetActiveConversationReq*>(
               &_GetActiveConversationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(GetActiveConversationReq& a, GetActiveConversationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveConversationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveConversationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveConversationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveConversationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveConversationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveConversationReq& from) {
    GetActiveConversationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveConversationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetActiveConversationReq";
  }
  protected:
  explicit GetActiveConversationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // repeated string conversationIDs = 1;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // int64 limit = 2;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetActiveConversationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    int64_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ActiveConversation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ActiveConversation) */ {
 public:
  inline ActiveConversation() : ActiveConversation(nullptr) {}
  ~ActiveConversation() override;
  explicit PROTOBUF_CONSTEXPR ActiveConversation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveConversation(const ActiveConversation& from);
  ActiveConversation(ActiveConversation&& from) noexcept
    : ActiveConversation() {
    *this = ::std::move(from);
  }

  inline ActiveConversation& operator=(const ActiveConversation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveConversation& operator=(ActiveConversation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveConversation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveConversation* internal_default_instance() {
    return reinterpret_cast<const ActiveConversation*>(
               &_ActiveConversation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(ActiveConversation& a, ActiveConversation& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveConversation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveConversation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveConversation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveConversation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveConversation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveConversation& from) {
    ActiveConversation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveConversation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ActiveConversation";
  }
  protected:
  explicit ActiveConversation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kLastTimeFieldNumber = 2,
    kMaxSeqFieldNumber = 3,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 lastTime = 2;
  void clear_lasttime();
  int64_t lasttime() const;
  void set_lasttime(int64_t value);
  private:
  int64_t _internal_lasttime() const;
  void _internal_set_lasttime(int64_t value);
  public:

  // int64 maxSeq = 3;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ActiveConversation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t lasttime_;
    int64_t maxseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetActiveConversationResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetActiveConversationResp) */ {
 public:
  inline GetActiveConversationResp() : GetActiveConversationResp(nullptr) {}
  ~GetActiveConversationResp() override;
  explicit PROTOBUF_CONSTEXPR GetActiveConversationResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetActiveConversationResp(const GetActiveConversationResp& from);
  GetActiveConversationResp(GetActiveConversationResp&& from) noexcept
    : GetActiveConversationResp() {
    *this = ::std::move(from);
  }

  inline GetActiveConversationResp& operator=(const GetActiveConversationResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetActiveConversationResp& operator=(GetActiveConversationResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetActiveConversationResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetActiveConversationResp* internal_default_instance() {
    return reinterpret_cast<const GetActiveConversationResp*>(
               &_GetActiveConversationResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(GetActiveConversationResp& a, GetActiveConversationResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetActiveConversationResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetActiveConversationResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetActiveConversationResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetActiveConversationResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetActiveConversationResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetActiveConversationResp& from) {
    GetActiveConversationResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActiveConversationResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetActiveConversationResp";
  }
  protected:
  explicit GetActiveConversationResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 1,
  };
  // repeated .msg.ActiveConversation conversations = 1;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::msg::ActiveConversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveConversation >*
      mutable_conversations();
  private:
  const ::msg::ActiveConversation& _internal_conversations(int index) const;
  ::msg::ActiveConversation* _internal_add_conversations();
  public:
  const ::msg::ActiveConversation& conversations(int index) const;
  ::msg::ActiveConversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveConversation >&
      conversations() const;

  // @@protoc_insertion_point(class_scope:msg.GetActiveConversationResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveConversation > conversations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetUserConversationMaxSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SetUserConversationMaxSeqReq) */ {
 public:
  inline SetUserConversationMaxSeqReq() : SetUserConversationMaxSeqReq(nullptr) {}
  ~SetUserConversationMaxSeqReq() override;
  explicit PROTOBUF_CONSTEXPR SetUserConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserConversationMaxSeqReq(const SetUserConversationMaxSeqReq& from);
  SetUserConversationMaxSeqReq(SetUserConversationMaxSeqReq&& from) noexcept
    : SetUserConversationMaxSeqReq() {
    *this = ::std::move(from);
  }

  inline SetUserConversationMaxSeqReq& operator=(const SetUserConversationMaxSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserConversationMaxSeqReq& operator=(SetUserConversationMaxSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserConversationMaxSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserConversationMaxSeqReq* internal_default_instance() {
    return reinterpret_cast<const SetUserConversationMaxSeqReq*>(
               &_SetUserConversationMaxSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(SetUserConversationMaxSeqReq& a, SetUserConversationMaxSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserConversationMaxSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserConversationMaxSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserConversationMaxSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserConversationMaxSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetUserConversationMaxSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetUserConversationMaxSeqReq& from) {
    SetUserConversationMaxSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUserConversationMaxSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetUserConversationMaxSeqReq";
  }
  protected:
  explicit SetUserConversationMaxSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kMaxSeqFieldNumber = 3,
  };
  // repeated string ownerUserID = 2;
  int owneruserid_size() const;
  private:
  int _internal_owneruserid_size() const;
  public:
  void clear_owneruserid();
  const std::string& owneruserid(int index) const;
  std::string* mutable_owneruserid(int index);
  void set_owneruserid(int index, const std::string& value);
  void set_owneruserid(int index, std::string&& value);
  void set_owneruserid(int index, const char* value);
  void set_owneruserid(int index, const char* value, size_t size);
  std::string* add_owneruserid();
  void add_owneruserid(const std::string& value);
  void add_owneruserid(std::string&& value);
  void add_owneruserid(const char* value);
  void add_owneruserid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owneruserid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owneruserid();
  private:
  const std::string& _internal_owneruserid(int index) const;
  std::string* _internal_add_owneruserid();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 maxSeq = 3;
  void clear_maxseq();
  int64_t maxseq() const;
  void set_maxseq(int64_t value);
  private:
  int64_t _internal_maxseq() const;
  void _internal_set_maxseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SetUserConversationMaxSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t maxseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetUserConversationMaxSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.SetUserConversationMaxSeqResp) */ {
 public:
  inline SetUserConversationMaxSeqResp() : SetUserConversationMaxSeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetUserConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserConversationMaxSeqResp(const SetUserConversationMaxSeqResp& from);
  SetUserConversationMaxSeqResp(SetUserConversationMaxSeqResp&& from) noexcept
    : SetUserConversationMaxSeqResp() {
    *this = ::std::move(from);
  }

  inline SetUserConversationMaxSeqResp& operator=(const SetUserConversationMaxSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserConversationMaxSeqResp& operator=(SetUserConversationMaxSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserConversationMaxSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserConversationMaxSeqResp* internal_default_instance() {
    return reinterpret_cast<const SetUserConversationMaxSeqResp*>(
               &_SetUserConversationMaxSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(SetUserConversationMaxSeqResp& a, SetUserConversationMaxSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserConversationMaxSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserConversationMaxSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserConversationMaxSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserConversationMaxSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetUserConversationMaxSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetUserConversationMaxSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetUserConversationMaxSeqResp";
  }
  protected:
  explicit SetUserConversationMaxSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.SetUserConversationMaxSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetUserConversationMinSeqReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SetUserConversationMinSeqReq) */ {
 public:
  inline SetUserConversationMinSeqReq() : SetUserConversationMinSeqReq(nullptr) {}
  ~SetUserConversationMinSeqReq() override;
  explicit PROTOBUF_CONSTEXPR SetUserConversationMinSeqReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserConversationMinSeqReq(const SetUserConversationMinSeqReq& from);
  SetUserConversationMinSeqReq(SetUserConversationMinSeqReq&& from) noexcept
    : SetUserConversationMinSeqReq() {
    *this = ::std::move(from);
  }

  inline SetUserConversationMinSeqReq& operator=(const SetUserConversationMinSeqReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserConversationMinSeqReq& operator=(SetUserConversationMinSeqReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserConversationMinSeqReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserConversationMinSeqReq* internal_default_instance() {
    return reinterpret_cast<const SetUserConversationMinSeqReq*>(
               &_SetUserConversationMinSeqReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(SetUserConversationMinSeqReq& a, SetUserConversationMinSeqReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserConversationMinSeqReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserConversationMinSeqReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserConversationMinSeqReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserConversationMinSeqReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetUserConversationMinSeqReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetUserConversationMinSeqReq& from) {
    SetUserConversationMinSeqReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUserConversationMinSeqReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetUserConversationMinSeqReq";
  }
  protected:
  explicit SetUserConversationMinSeqReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerUserIDFieldNumber = 2,
    kConversationIDFieldNumber = 1,
    kMinSeqFieldNumber = 3,
  };
  // repeated string ownerUserID = 2;
  int owneruserid_size() const;
  private:
  int _internal_owneruserid_size() const;
  public:
  void clear_owneruserid();
  const std::string& owneruserid(int index) const;
  std::string* mutable_owneruserid(int index);
  void set_owneruserid(int index, const std::string& value);
  void set_owneruserid(int index, std::string&& value);
  void set_owneruserid(int index, const char* value);
  void set_owneruserid(int index, const char* value, size_t size);
  std::string* add_owneruserid();
  void add_owneruserid(const std::string& value);
  void add_owneruserid(std::string&& value);
  void add_owneruserid(const char* value);
  void add_owneruserid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owneruserid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owneruserid();
  private:
  const std::string& _internal_owneruserid(int index) const;
  std::string* _internal_add_owneruserid();
  public:

  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 minSeq = 3;
  void clear_minseq();
  int64_t minseq() const;
  void set_minseq(int64_t value);
  private:
  int64_t _internal_minseq() const;
  void _internal_set_minseq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SetUserConversationMinSeqReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owneruserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t minseq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SetUserConversationMinSeqResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.SetUserConversationMinSeqResp) */ {
 public:
  inline SetUserConversationMinSeqResp() : SetUserConversationMinSeqResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetUserConversationMinSeqResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserConversationMinSeqResp(const SetUserConversationMinSeqResp& from);
  SetUserConversationMinSeqResp(SetUserConversationMinSeqResp&& from) noexcept
    : SetUserConversationMinSeqResp() {
    *this = ::std::move(from);
  }

  inline SetUserConversationMinSeqResp& operator=(const SetUserConversationMinSeqResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserConversationMinSeqResp& operator=(SetUserConversationMinSeqResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserConversationMinSeqResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserConversationMinSeqResp* internal_default_instance() {
    return reinterpret_cast<const SetUserConversationMinSeqResp*>(
               &_SetUserConversationMinSeqResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(SetUserConversationMinSeqResp& a, SetUserConversationMinSeqResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserConversationMinSeqResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserConversationMinSeqResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserConversationMinSeqResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserConversationMinSeqResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetUserConversationMinSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetUserConversationMinSeqResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SetUserConversationMinSeqResp";
  }
  protected:
  explicit SetUserConversationMinSeqResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.SetUserConversationMinSeqResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetLastMessageSeqByTimeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetLastMessageSeqByTimeReq) */ {
 public:
  inline GetLastMessageSeqByTimeReq() : GetLastMessageSeqByTimeReq(nullptr) {}
  ~GetLastMessageSeqByTimeReq() override;
  explicit PROTOBUF_CONSTEXPR GetLastMessageSeqByTimeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastMessageSeqByTimeReq(const GetLastMessageSeqByTimeReq& from);
  GetLastMessageSeqByTimeReq(GetLastMessageSeqByTimeReq&& from) noexcept
    : GetLastMessageSeqByTimeReq() {
    *this = ::std::move(from);
  }

  inline GetLastMessageSeqByTimeReq& operator=(const GetLastMessageSeqByTimeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastMessageSeqByTimeReq& operator=(GetLastMessageSeqByTimeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastMessageSeqByTimeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastMessageSeqByTimeReq* internal_default_instance() {
    return reinterpret_cast<const GetLastMessageSeqByTimeReq*>(
               &_GetLastMessageSeqByTimeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(GetLastMessageSeqByTimeReq& a, GetLastMessageSeqByTimeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastMessageSeqByTimeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastMessageSeqByTimeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastMessageSeqByTimeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastMessageSeqByTimeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLastMessageSeqByTimeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLastMessageSeqByTimeReq& from) {
    GetLastMessageSeqByTimeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastMessageSeqByTimeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetLastMessageSeqByTimeReq";
  }
  protected:
  explicit GetLastMessageSeqByTimeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string conversationID = 1;
  void clear_conversationid();
  const std::string& conversationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversationid();
  PROTOBUF_NODISCARD std::string* release_conversationid();
  void set_allocated_conversationid(std::string* conversationid);
  private:
  const std::string& _internal_conversationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversationid(const std::string& value);
  std::string* _internal_mutable_conversationid();
  public:

  // int64 time = 2;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetLastMessageSeqByTimeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversationid_;
    int64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetLastMessageSeqByTimeResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetLastMessageSeqByTimeResp) */ {
 public:
  inline GetLastMessageSeqByTimeResp() : GetLastMessageSeqByTimeResp(nullptr) {}
  ~GetLastMessageSeqByTimeResp() override;
  explicit PROTOBUF_CONSTEXPR GetLastMessageSeqByTimeResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastMessageSeqByTimeResp(const GetLastMessageSeqByTimeResp& from);
  GetLastMessageSeqByTimeResp(GetLastMessageSeqByTimeResp&& from) noexcept
    : GetLastMessageSeqByTimeResp() {
    *this = ::std::move(from);
  }

  inline GetLastMessageSeqByTimeResp& operator=(const GetLastMessageSeqByTimeResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastMessageSeqByTimeResp& operator=(GetLastMessageSeqByTimeResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastMessageSeqByTimeResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastMessageSeqByTimeResp* internal_default_instance() {
    return reinterpret_cast<const GetLastMessageSeqByTimeResp*>(
               &_GetLastMessageSeqByTimeResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(GetLastMessageSeqByTimeResp& a, GetLastMessageSeqByTimeResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastMessageSeqByTimeResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastMessageSeqByTimeResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastMessageSeqByTimeResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastMessageSeqByTimeResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLastMessageSeqByTimeResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLastMessageSeqByTimeResp& from) {
    GetLastMessageSeqByTimeResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastMessageSeqByTimeResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetLastMessageSeqByTimeResp";
  }
  protected:
  explicit GetLastMessageSeqByTimeResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
  };
  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GetLastMessageSeqByTimeResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t seq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetLastMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetLastMessageReq) */ {
 public:
  inline GetLastMessageReq() : GetLastMessageReq(nullptr) {}
  ~GetLastMessageReq() override;
  explicit PROTOBUF_CONSTEXPR GetLastMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastMessageReq(const GetLastMessageReq& from);
  GetLastMessageReq(GetLastMessageReq&& from) noexcept
    : GetLastMessageReq() {
    *this = ::std::move(from);
  }

  inline GetLastMessageReq& operator=(const GetLastMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastMessageReq& operator=(GetLastMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastMessageReq* internal_default_instance() {
    return reinterpret_cast<const GetLastMessageReq*>(
               &_GetLastMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(GetLastMessageReq& a, GetLastMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLastMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLastMessageReq& from) {
    GetLastMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetLastMessageReq";
  }
  protected:
  explicit GetLastMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIDsFieldNumber = 2,
    kUserIDFieldNumber = 1,
  };
  // repeated string conversationIDs = 2;
  int conversationids_size() const;
  private:
  int _internal_conversationids_size() const;
  public:
  void clear_conversationids();
  const std::string& conversationids(int index) const;
  std::string* mutable_conversationids(int index);
  void set_conversationids(int index, const std::string& value);
  void set_conversationids(int index, std::string&& value);
  void set_conversationids(int index, const char* value);
  void set_conversationids(int index, const char* value, size_t size);
  std::string* add_conversationids();
  void add_conversationids(const std::string& value);
  void add_conversationids(std::string&& value);
  void add_conversationids(const char* value);
  void add_conversationids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& conversationids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_conversationids();
  private:
  const std::string& _internal_conversationids(int index) const;
  std::string* _internal_add_conversationids();
  public:

  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:msg.GetLastMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> conversationids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GetLastMessageResp_MsgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetLastMessageResp_MsgsEntry_DoNotUse, 
    std::string, ::sdkws::MsgData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetLastMessageResp_MsgsEntry_DoNotUse, 
    std::string, ::sdkws::MsgData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetLastMessageResp_MsgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetLastMessageResp_MsgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetLastMessageResp_MsgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetLastMessageResp_MsgsEntry_DoNotUse& other);
  static const GetLastMessageResp_MsgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetLastMessageResp_MsgsEntry_DoNotUse*>(&_GetLastMessageResp_MsgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "msg.GetLastMessageResp.MsgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_msg_2eproto;
};

// -------------------------------------------------------------------

class GetLastMessageResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GetLastMessageResp) */ {
 public:
  inline GetLastMessageResp() : GetLastMessageResp(nullptr) {}
  ~GetLastMessageResp() override;
  explicit PROTOBUF_CONSTEXPR GetLastMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastMessageResp(const GetLastMessageResp& from);
  GetLastMessageResp(GetLastMessageResp&& from) noexcept
    : GetLastMessageResp() {
    *this = ::std::move(from);
  }

  inline GetLastMessageResp& operator=(const GetLastMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastMessageResp& operator=(GetLastMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastMessageResp* internal_default_instance() {
    return reinterpret_cast<const GetLastMessageResp*>(
               &_GetLastMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(GetLastMessageResp& a, GetLastMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastMessageResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastMessageResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLastMessageResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLastMessageResp& from) {
    GetLastMessageResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastMessageResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GetLastMessageResp";
  }
  protected:
  explicit GetLastMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 1,
  };
  // map<string, .sdkws.MsgData> msgs = 1;
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;
  public:
  void clear_msgs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
      _internal_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
      _internal_mutable_msgs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
      msgs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
      mutable_msgs();

  // @@protoc_insertion_point(class_scope:msg.GetLastMessageResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetLastMessageResp_MsgsEntry_DoNotUse,
        std::string, ::sdkws::MsgData,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> msgs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgDataToMQ

// string token = 1;
inline void MsgDataToMQ::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& MsgDataToMQ::token() const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToMQ.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgDataToMQ::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MsgDataToMQ.token)
}
inline std::string* MsgDataToMQ::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToMQ.token)
  return _s;
}
inline const std::string& MsgDataToMQ::_internal_token() const {
  return _impl_.token_.Get();
}
inline void MsgDataToMQ::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDataToMQ::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgDataToMQ::release_token() {
  // @@protoc_insertion_point(field_release:msg.MsgDataToMQ.token)
  return _impl_.token_.Release();
}
inline void MsgDataToMQ::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MsgDataToMQ.token)
}

// .sdkws.MsgData msgData = 2;
inline bool MsgDataToMQ::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool MsgDataToMQ::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& MsgDataToMQ::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& MsgDataToMQ::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToMQ.msgData)
  return _internal_msgdata();
}
inline void MsgDataToMQ::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.MsgDataToMQ.msgData)
}
inline ::sdkws::MsgData* MsgDataToMQ::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* MsgDataToMQ::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.MsgDataToMQ.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* MsgDataToMQ::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* MsgDataToMQ::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToMQ.msgData)
  return _msg;
}
inline void MsgDataToMQ::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.MsgDataToMQ.msgData)
}

// -------------------------------------------------------------------

// MsgDataToDB

// .sdkws.MsgData msgData = 1;
inline bool MsgDataToDB::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool MsgDataToDB::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& MsgDataToDB::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& MsgDataToDB::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToDB.msgData)
  return _internal_msgdata();
}
inline void MsgDataToDB::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.MsgDataToDB.msgData)
}
inline ::sdkws::MsgData* MsgDataToDB::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* MsgDataToDB::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.MsgDataToDB.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* MsgDataToDB::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* MsgDataToDB::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToDB.msgData)
  return _msg;
}
inline void MsgDataToDB::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.MsgDataToDB.msgData)
}

// -------------------------------------------------------------------

// PushMsgDataToMQ

// .sdkws.MsgData msgData = 1;
inline bool PushMsgDataToMQ::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool PushMsgDataToMQ::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& PushMsgDataToMQ::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& PushMsgDataToMQ::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.PushMsgDataToMQ.msgData)
  return _internal_msgdata();
}
inline void PushMsgDataToMQ::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.PushMsgDataToMQ.msgData)
}
inline ::sdkws::MsgData* PushMsgDataToMQ::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* PushMsgDataToMQ::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.PushMsgDataToMQ.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* PushMsgDataToMQ::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* PushMsgDataToMQ::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.PushMsgDataToMQ.msgData)
  return _msg;
}
inline void PushMsgDataToMQ::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.PushMsgDataToMQ.msgData)
}

// string conversationID = 2;
inline void PushMsgDataToMQ::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& PushMsgDataToMQ::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.PushMsgDataToMQ.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushMsgDataToMQ::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.PushMsgDataToMQ.conversationID)
}
inline std::string* PushMsgDataToMQ::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.PushMsgDataToMQ.conversationID)
  return _s;
}
inline const std::string& PushMsgDataToMQ::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void PushMsgDataToMQ::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* PushMsgDataToMQ::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* PushMsgDataToMQ::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.PushMsgDataToMQ.conversationID)
  return _impl_.conversationid_.Release();
}
inline void PushMsgDataToMQ::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.PushMsgDataToMQ.conversationID)
}

// -------------------------------------------------------------------

// MsgDataToMongoByMQ

// int64 lastSeq = 1;
inline void MsgDataToMongoByMQ::clear_lastseq() {
  _impl_.lastseq_ = int64_t{0};
}
inline int64_t MsgDataToMongoByMQ::_internal_lastseq() const {
  return _impl_.lastseq_;
}
inline int64_t MsgDataToMongoByMQ::lastseq() const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToMongoByMQ.lastSeq)
  return _internal_lastseq();
}
inline void MsgDataToMongoByMQ::_internal_set_lastseq(int64_t value) {
  
  _impl_.lastseq_ = value;
}
inline void MsgDataToMongoByMQ::set_lastseq(int64_t value) {
  _internal_set_lastseq(value);
  // @@protoc_insertion_point(field_set:msg.MsgDataToMongoByMQ.lastSeq)
}

// string conversationID = 2;
inline void MsgDataToMongoByMQ::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& MsgDataToMongoByMQ::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToMongoByMQ.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgDataToMongoByMQ::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MsgDataToMongoByMQ.conversationID)
}
inline std::string* MsgDataToMongoByMQ::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToMongoByMQ.conversationID)
  return _s;
}
inline const std::string& MsgDataToMongoByMQ::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void MsgDataToMongoByMQ::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDataToMongoByMQ::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgDataToMongoByMQ::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.MsgDataToMongoByMQ.conversationID)
  return _impl_.conversationid_.Release();
}
inline void MsgDataToMongoByMQ::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MsgDataToMongoByMQ.conversationID)
}

// repeated .sdkws.MsgData msgData = 3;
inline int MsgDataToMongoByMQ::_internal_msgdata_size() const {
  return _impl_.msgdata_.size();
}
inline int MsgDataToMongoByMQ::msgdata_size() const {
  return _internal_msgdata_size();
}
inline ::sdkws::MsgData* MsgDataToMongoByMQ::mutable_msgdata(int index) {
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToMongoByMQ.msgData)
  return _impl_.msgdata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >*
MsgDataToMongoByMQ::mutable_msgdata() {
  // @@protoc_insertion_point(field_mutable_list:msg.MsgDataToMongoByMQ.msgData)
  return &_impl_.msgdata_;
}
inline const ::sdkws::MsgData& MsgDataToMongoByMQ::_internal_msgdata(int index) const {
  return _impl_.msgdata_.Get(index);
}
inline const ::sdkws::MsgData& MsgDataToMongoByMQ::msgdata(int index) const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToMongoByMQ.msgData)
  return _internal_msgdata(index);
}
inline ::sdkws::MsgData* MsgDataToMongoByMQ::_internal_add_msgdata() {
  return _impl_.msgdata_.Add();
}
inline ::sdkws::MsgData* MsgDataToMongoByMQ::add_msgdata() {
  ::sdkws::MsgData* _add = _internal_add_msgdata();
  // @@protoc_insertion_point(field_add:msg.MsgDataToMongoByMQ.msgData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >&
MsgDataToMongoByMQ::msgdata() const {
  // @@protoc_insertion_point(field_list:msg.MsgDataToMongoByMQ.msgData)
  return _impl_.msgdata_;
}

// -------------------------------------------------------------------

// GetMaxAndMinSeqReq

// string UserID = 1;
inline void GetMaxAndMinSeqReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetMaxAndMinSeqReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.GetMaxAndMinSeqReq.UserID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMaxAndMinSeqReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetMaxAndMinSeqReq.UserID)
}
inline std::string* GetMaxAndMinSeqReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.GetMaxAndMinSeqReq.UserID)
  return _s;
}
inline const std::string& GetMaxAndMinSeqReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetMaxAndMinSeqReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMaxAndMinSeqReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMaxAndMinSeqReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.GetMaxAndMinSeqReq.UserID)
  return _impl_.userid_.Release();
}
inline void GetMaxAndMinSeqReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetMaxAndMinSeqReq.UserID)
}

// -------------------------------------------------------------------

// GetMaxAndMinSeqResp

// int64 MaxSeq = 1;
inline void GetMaxAndMinSeqResp::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t GetMaxAndMinSeqResp::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t GetMaxAndMinSeqResp::maxseq() const {
  // @@protoc_insertion_point(field_get:msg.GetMaxAndMinSeqResp.MaxSeq)
  return _internal_maxseq();
}
inline void GetMaxAndMinSeqResp::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void GetMaxAndMinSeqResp::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:msg.GetMaxAndMinSeqResp.MaxSeq)
}

// int64 MinSeq = 2;
inline void GetMaxAndMinSeqResp::clear_minseq() {
  _impl_.minseq_ = int64_t{0};
}
inline int64_t GetMaxAndMinSeqResp::_internal_minseq() const {
  return _impl_.minseq_;
}
inline int64_t GetMaxAndMinSeqResp::minseq() const {
  // @@protoc_insertion_point(field_get:msg.GetMaxAndMinSeqResp.MinSeq)
  return _internal_minseq();
}
inline void GetMaxAndMinSeqResp::_internal_set_minseq(int64_t value) {
  
  _impl_.minseq_ = value;
}
inline void GetMaxAndMinSeqResp::set_minseq(int64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:msg.GetMaxAndMinSeqResp.MinSeq)
}

// -------------------------------------------------------------------

// SendMsgReq

// .sdkws.MsgData msgData = 3;
inline bool SendMsgReq::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool SendMsgReq::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& SendMsgReq::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& SendMsgReq::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.SendMsgReq.msgData)
  return _internal_msgdata();
}
inline void SendMsgReq::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SendMsgReq.msgData)
}
inline ::sdkws::MsgData* SendMsgReq::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* SendMsgReq::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.SendMsgReq.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* SendMsgReq::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* SendMsgReq::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.SendMsgReq.msgData)
  return _msg;
}
inline void SendMsgReq::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.SendMsgReq.msgData)
}

// -------------------------------------------------------------------

// SendMsgResp

// string serverMsgID = 1;
inline void SendMsgResp::clear_servermsgid() {
  _impl_.servermsgid_.ClearToEmpty();
}
inline const std::string& SendMsgResp::servermsgid() const {
  // @@protoc_insertion_point(field_get:msg.SendMsgResp.serverMsgID)
  return _internal_servermsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMsgResp::set_servermsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servermsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SendMsgResp.serverMsgID)
}
inline std::string* SendMsgResp::mutable_servermsgid() {
  std::string* _s = _internal_mutable_servermsgid();
  // @@protoc_insertion_point(field_mutable:msg.SendMsgResp.serverMsgID)
  return _s;
}
inline const std::string& SendMsgResp::_internal_servermsgid() const {
  return _impl_.servermsgid_.Get();
}
inline void SendMsgResp::_internal_set_servermsgid(const std::string& value) {
  
  _impl_.servermsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMsgResp::_internal_mutable_servermsgid() {
  
  return _impl_.servermsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMsgResp::release_servermsgid() {
  // @@protoc_insertion_point(field_release:msg.SendMsgResp.serverMsgID)
  return _impl_.servermsgid_.Release();
}
inline void SendMsgResp::set_allocated_servermsgid(std::string* servermsgid) {
  if (servermsgid != nullptr) {
    
  } else {
    
  }
  _impl_.servermsgid_.SetAllocated(servermsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servermsgid_.IsDefault()) {
    _impl_.servermsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SendMsgResp.serverMsgID)
}

// string clientMsgID = 2;
inline void SendMsgResp::clear_clientmsgid() {
  _impl_.clientmsgid_.ClearToEmpty();
}
inline const std::string& SendMsgResp::clientmsgid() const {
  // @@protoc_insertion_point(field_get:msg.SendMsgResp.clientMsgID)
  return _internal_clientmsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMsgResp::set_clientmsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientmsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SendMsgResp.clientMsgID)
}
inline std::string* SendMsgResp::mutable_clientmsgid() {
  std::string* _s = _internal_mutable_clientmsgid();
  // @@protoc_insertion_point(field_mutable:msg.SendMsgResp.clientMsgID)
  return _s;
}
inline const std::string& SendMsgResp::_internal_clientmsgid() const {
  return _impl_.clientmsgid_.Get();
}
inline void SendMsgResp::_internal_set_clientmsgid(const std::string& value) {
  
  _impl_.clientmsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMsgResp::_internal_mutable_clientmsgid() {
  
  return _impl_.clientmsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMsgResp::release_clientmsgid() {
  // @@protoc_insertion_point(field_release:msg.SendMsgResp.clientMsgID)
  return _impl_.clientmsgid_.Release();
}
inline void SendMsgResp::set_allocated_clientmsgid(std::string* clientmsgid) {
  if (clientmsgid != nullptr) {
    
  } else {
    
  }
  _impl_.clientmsgid_.SetAllocated(clientmsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientmsgid_.IsDefault()) {
    _impl_.clientmsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SendMsgResp.clientMsgID)
}

// int64 sendTime = 3;
inline void SendMsgResp::clear_sendtime() {
  _impl_.sendtime_ = int64_t{0};
}
inline int64_t SendMsgResp::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline int64_t SendMsgResp::sendtime() const {
  // @@protoc_insertion_point(field_get:msg.SendMsgResp.sendTime)
  return _internal_sendtime();
}
inline void SendMsgResp::_internal_set_sendtime(int64_t value) {
  
  _impl_.sendtime_ = value;
}
inline void SendMsgResp::set_sendtime(int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:msg.SendMsgResp.sendTime)
}

// .sdkws.MsgData modify = 4;
inline bool SendMsgResp::_internal_has_modify() const {
  return this != internal_default_instance() && _impl_.modify_ != nullptr;
}
inline bool SendMsgResp::has_modify() const {
  return _internal_has_modify();
}
inline const ::sdkws::MsgData& SendMsgResp::_internal_modify() const {
  const ::sdkws::MsgData* p = _impl_.modify_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& SendMsgResp::modify() const {
  // @@protoc_insertion_point(field_get:msg.SendMsgResp.modify)
  return _internal_modify();
}
inline void SendMsgResp::unsafe_arena_set_allocated_modify(
    ::sdkws::MsgData* modify) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modify_);
  }
  _impl_.modify_ = modify;
  if (modify) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SendMsgResp.modify)
}
inline ::sdkws::MsgData* SendMsgResp::release_modify() {
  
  ::sdkws::MsgData* temp = _impl_.modify_;
  _impl_.modify_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* SendMsgResp::unsafe_arena_release_modify() {
  // @@protoc_insertion_point(field_release:msg.SendMsgResp.modify)
  
  ::sdkws::MsgData* temp = _impl_.modify_;
  _impl_.modify_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* SendMsgResp::_internal_mutable_modify() {
  
  if (_impl_.modify_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.modify_ = p;
  }
  return _impl_.modify_;
}
inline ::sdkws::MsgData* SendMsgResp::mutable_modify() {
  ::sdkws::MsgData* _msg = _internal_mutable_modify();
  // @@protoc_insertion_point(field_mutable:msg.SendMsgResp.modify)
  return _msg;
}
inline void SendMsgResp::set_allocated_modify(::sdkws::MsgData* modify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modify_);
  }
  if (modify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modify));
    if (message_arena != submessage_arena) {
      modify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modify, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modify_ = modify;
  // @@protoc_insertion_point(field_set_allocated:msg.SendMsgResp.modify)
}

// -------------------------------------------------------------------

// SendSimpleMsgReq

// .sdkws.MsgData msgData = 3;
inline bool SendSimpleMsgReq::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool SendSimpleMsgReq::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& SendSimpleMsgReq::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& SendSimpleMsgReq::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.SendSimpleMsgReq.msgData)
  return _internal_msgdata();
}
inline void SendSimpleMsgReq::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SendSimpleMsgReq.msgData)
}
inline ::sdkws::MsgData* SendSimpleMsgReq::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* SendSimpleMsgReq::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.SendSimpleMsgReq.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* SendSimpleMsgReq::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* SendSimpleMsgReq::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.SendSimpleMsgReq.msgData)
  return _msg;
}
inline void SendSimpleMsgReq::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.SendSimpleMsgReq.msgData)
}

// -------------------------------------------------------------------

// SendSimpleMsgResp

// string serverMsgID = 1;
inline void SendSimpleMsgResp::clear_servermsgid() {
  _impl_.servermsgid_.ClearToEmpty();
}
inline const std::string& SendSimpleMsgResp::servermsgid() const {
  // @@protoc_insertion_point(field_get:msg.SendSimpleMsgResp.serverMsgID)
  return _internal_servermsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendSimpleMsgResp::set_servermsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servermsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SendSimpleMsgResp.serverMsgID)
}
inline std::string* SendSimpleMsgResp::mutable_servermsgid() {
  std::string* _s = _internal_mutable_servermsgid();
  // @@protoc_insertion_point(field_mutable:msg.SendSimpleMsgResp.serverMsgID)
  return _s;
}
inline const std::string& SendSimpleMsgResp::_internal_servermsgid() const {
  return _impl_.servermsgid_.Get();
}
inline void SendSimpleMsgResp::_internal_set_servermsgid(const std::string& value) {
  
  _impl_.servermsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* SendSimpleMsgResp::_internal_mutable_servermsgid() {
  
  return _impl_.servermsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* SendSimpleMsgResp::release_servermsgid() {
  // @@protoc_insertion_point(field_release:msg.SendSimpleMsgResp.serverMsgID)
  return _impl_.servermsgid_.Release();
}
inline void SendSimpleMsgResp::set_allocated_servermsgid(std::string* servermsgid) {
  if (servermsgid != nullptr) {
    
  } else {
    
  }
  _impl_.servermsgid_.SetAllocated(servermsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servermsgid_.IsDefault()) {
    _impl_.servermsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SendSimpleMsgResp.serverMsgID)
}

// string clientMsgID = 2;
inline void SendSimpleMsgResp::clear_clientmsgid() {
  _impl_.clientmsgid_.ClearToEmpty();
}
inline const std::string& SendSimpleMsgResp::clientmsgid() const {
  // @@protoc_insertion_point(field_get:msg.SendSimpleMsgResp.clientMsgID)
  return _internal_clientmsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendSimpleMsgResp::set_clientmsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientmsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SendSimpleMsgResp.clientMsgID)
}
inline std::string* SendSimpleMsgResp::mutable_clientmsgid() {
  std::string* _s = _internal_mutable_clientmsgid();
  // @@protoc_insertion_point(field_mutable:msg.SendSimpleMsgResp.clientMsgID)
  return _s;
}
inline const std::string& SendSimpleMsgResp::_internal_clientmsgid() const {
  return _impl_.clientmsgid_.Get();
}
inline void SendSimpleMsgResp::_internal_set_clientmsgid(const std::string& value) {
  
  _impl_.clientmsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* SendSimpleMsgResp::_internal_mutable_clientmsgid() {
  
  return _impl_.clientmsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* SendSimpleMsgResp::release_clientmsgid() {
  // @@protoc_insertion_point(field_release:msg.SendSimpleMsgResp.clientMsgID)
  return _impl_.clientmsgid_.Release();
}
inline void SendSimpleMsgResp::set_allocated_clientmsgid(std::string* clientmsgid) {
  if (clientmsgid != nullptr) {
    
  } else {
    
  }
  _impl_.clientmsgid_.SetAllocated(clientmsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientmsgid_.IsDefault()) {
    _impl_.clientmsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SendSimpleMsgResp.clientMsgID)
}

// int64 sendTime = 3;
inline void SendSimpleMsgResp::clear_sendtime() {
  _impl_.sendtime_ = int64_t{0};
}
inline int64_t SendSimpleMsgResp::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline int64_t SendSimpleMsgResp::sendtime() const {
  // @@protoc_insertion_point(field_get:msg.SendSimpleMsgResp.sendTime)
  return _internal_sendtime();
}
inline void SendSimpleMsgResp::_internal_set_sendtime(int64_t value) {
  
  _impl_.sendtime_ = value;
}
inline void SendSimpleMsgResp::set_sendtime(int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:msg.SendSimpleMsgResp.sendTime)
}

// .sdkws.MsgData modify = 4;
inline bool SendSimpleMsgResp::_internal_has_modify() const {
  return this != internal_default_instance() && _impl_.modify_ != nullptr;
}
inline bool SendSimpleMsgResp::has_modify() const {
  return _internal_has_modify();
}
inline const ::sdkws::MsgData& SendSimpleMsgResp::_internal_modify() const {
  const ::sdkws::MsgData* p = _impl_.modify_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& SendSimpleMsgResp::modify() const {
  // @@protoc_insertion_point(field_get:msg.SendSimpleMsgResp.modify)
  return _internal_modify();
}
inline void SendSimpleMsgResp::unsafe_arena_set_allocated_modify(
    ::sdkws::MsgData* modify) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modify_);
  }
  _impl_.modify_ = modify;
  if (modify) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SendSimpleMsgResp.modify)
}
inline ::sdkws::MsgData* SendSimpleMsgResp::release_modify() {
  
  ::sdkws::MsgData* temp = _impl_.modify_;
  _impl_.modify_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* SendSimpleMsgResp::unsafe_arena_release_modify() {
  // @@protoc_insertion_point(field_release:msg.SendSimpleMsgResp.modify)
  
  ::sdkws::MsgData* temp = _impl_.modify_;
  _impl_.modify_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* SendSimpleMsgResp::_internal_mutable_modify() {
  
  if (_impl_.modify_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.modify_ = p;
  }
  return _impl_.modify_;
}
inline ::sdkws::MsgData* SendSimpleMsgResp::mutable_modify() {
  ::sdkws::MsgData* _msg = _internal_mutable_modify();
  // @@protoc_insertion_point(field_mutable:msg.SendSimpleMsgResp.modify)
  return _msg;
}
inline void SendSimpleMsgResp::set_allocated_modify(::sdkws::MsgData* modify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modify_);
  }
  if (modify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modify));
    if (message_arena != submessage_arena) {
      modify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modify, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modify_ = modify;
  // @@protoc_insertion_point(field_set_allocated:msg.SendSimpleMsgResp.modify)
}

// -------------------------------------------------------------------

// SetSendMsgStatusReq

// int32 status = 1;
inline void SetSendMsgStatusReq::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t SetSendMsgStatusReq::_internal_status() const {
  return _impl_.status_;
}
inline int32_t SetSendMsgStatusReq::status() const {
  // @@protoc_insertion_point(field_get:msg.SetSendMsgStatusReq.status)
  return _internal_status();
}
inline void SetSendMsgStatusReq::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void SetSendMsgStatusReq::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:msg.SetSendMsgStatusReq.status)
}

// -------------------------------------------------------------------

// SetSendMsgStatusResp

// -------------------------------------------------------------------

// GetSendMsgStatusReq

// -------------------------------------------------------------------

// GetSendMsgStatusResp

// int32 status = 1;
inline void GetSendMsgStatusResp::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t GetSendMsgStatusResp::_internal_status() const {
  return _impl_.status_;
}
inline int32_t GetSendMsgStatusResp::status() const {
  // @@protoc_insertion_point(field_get:msg.GetSendMsgStatusResp.status)
  return _internal_status();
}
inline void GetSendMsgStatusResp::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void GetSendMsgStatusResp::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:msg.GetSendMsgStatusResp.status)
}

// -------------------------------------------------------------------

// MsgDataToModifyByMQ

// repeated .sdkws.MsgData messages = 1;
inline int MsgDataToModifyByMQ::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int MsgDataToModifyByMQ::messages_size() const {
  return _internal_messages_size();
}
inline ::sdkws::MsgData* MsgDataToModifyByMQ::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToModifyByMQ.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >*
MsgDataToModifyByMQ::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:msg.MsgDataToModifyByMQ.messages)
  return &_impl_.messages_;
}
inline const ::sdkws::MsgData& MsgDataToModifyByMQ::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::sdkws::MsgData& MsgDataToModifyByMQ::messages(int index) const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToModifyByMQ.messages)
  return _internal_messages(index);
}
inline ::sdkws::MsgData* MsgDataToModifyByMQ::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::sdkws::MsgData* MsgDataToModifyByMQ::add_messages() {
  ::sdkws::MsgData* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:msg.MsgDataToModifyByMQ.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sdkws::MsgData >&
MsgDataToModifyByMQ::messages() const {
  // @@protoc_insertion_point(field_list:msg.MsgDataToModifyByMQ.messages)
  return _impl_.messages_;
}

// string conversationID = 2;
inline void MsgDataToModifyByMQ::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& MsgDataToModifyByMQ::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.MsgDataToModifyByMQ.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgDataToModifyByMQ::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MsgDataToModifyByMQ.conversationID)
}
inline std::string* MsgDataToModifyByMQ::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.MsgDataToModifyByMQ.conversationID)
  return _s;
}
inline const std::string& MsgDataToModifyByMQ::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void MsgDataToModifyByMQ::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDataToModifyByMQ::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgDataToModifyByMQ::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.MsgDataToModifyByMQ.conversationID)
  return _impl_.conversationid_.Release();
}
inline void MsgDataToModifyByMQ::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MsgDataToModifyByMQ.conversationID)
}

// -------------------------------------------------------------------

// DelMsgsReq

// -------------------------------------------------------------------

// DelMsgsResp

// -------------------------------------------------------------------

// RevokeMsgReq

// string conversationID = 1;
inline void RevokeMsgReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& RevokeMsgReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.RevokeMsgReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokeMsgReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.RevokeMsgReq.conversationID)
}
inline std::string* RevokeMsgReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.RevokeMsgReq.conversationID)
  return _s;
}
inline const std::string& RevokeMsgReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void RevokeMsgReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* RevokeMsgReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* RevokeMsgReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.RevokeMsgReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void RevokeMsgReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.RevokeMsgReq.conversationID)
}

// int64 seq = 2;
inline void RevokeMsgReq::clear_seq() {
  _impl_.seq_ = int64_t{0};
}
inline int64_t RevokeMsgReq::_internal_seq() const {
  return _impl_.seq_;
}
inline int64_t RevokeMsgReq::seq() const {
  // @@protoc_insertion_point(field_get:msg.RevokeMsgReq.seq)
  return _internal_seq();
}
inline void RevokeMsgReq::_internal_set_seq(int64_t value) {
  
  _impl_.seq_ = value;
}
inline void RevokeMsgReq::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:msg.RevokeMsgReq.seq)
}

// string userID = 3;
inline void RevokeMsgReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& RevokeMsgReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.RevokeMsgReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokeMsgReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.RevokeMsgReq.userID)
}
inline std::string* RevokeMsgReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.RevokeMsgReq.userID)
  return _s;
}
inline const std::string& RevokeMsgReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void RevokeMsgReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* RevokeMsgReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* RevokeMsgReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.RevokeMsgReq.userID)
  return _impl_.userid_.Release();
}
inline void RevokeMsgReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.RevokeMsgReq.userID)
}

// -------------------------------------------------------------------

// RevokeMsgResp

// -------------------------------------------------------------------

// MarkMsgsAsReadReq

// string conversationID = 1;
inline void MarkMsgsAsReadReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& MarkMsgsAsReadReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.MarkMsgsAsReadReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkMsgsAsReadReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MarkMsgsAsReadReq.conversationID)
}
inline std::string* MarkMsgsAsReadReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.MarkMsgsAsReadReq.conversationID)
  return _s;
}
inline const std::string& MarkMsgsAsReadReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void MarkMsgsAsReadReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkMsgsAsReadReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkMsgsAsReadReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.MarkMsgsAsReadReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void MarkMsgsAsReadReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MarkMsgsAsReadReq.conversationID)
}

// repeated int64 seqs = 2;
inline int MarkMsgsAsReadReq::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int MarkMsgsAsReadReq::seqs_size() const {
  return _internal_seqs_size();
}
inline void MarkMsgsAsReadReq::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline int64_t MarkMsgsAsReadReq::_internal_seqs(int index) const {
  return _impl_.seqs_.Get(index);
}
inline int64_t MarkMsgsAsReadReq::seqs(int index) const {
  // @@protoc_insertion_point(field_get:msg.MarkMsgsAsReadReq.seqs)
  return _internal_seqs(index);
}
inline void MarkMsgsAsReadReq::set_seqs(int index, int64_t value) {
  _impl_.seqs_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.MarkMsgsAsReadReq.seqs)
}
inline void MarkMsgsAsReadReq::_internal_add_seqs(int64_t value) {
  _impl_.seqs_.Add(value);
}
inline void MarkMsgsAsReadReq::add_seqs(int64_t value) {
  _internal_add_seqs(value);
  // @@protoc_insertion_point(field_add:msg.MarkMsgsAsReadReq.seqs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
MarkMsgsAsReadReq::_internal_seqs() const {
  return _impl_.seqs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
MarkMsgsAsReadReq::seqs() const {
  // @@protoc_insertion_point(field_list:msg.MarkMsgsAsReadReq.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
MarkMsgsAsReadReq::_internal_mutable_seqs() {
  return &_impl_.seqs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
MarkMsgsAsReadReq::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_list:msg.MarkMsgsAsReadReq.seqs)
  return _internal_mutable_seqs();
}

// string userID = 3;
inline void MarkMsgsAsReadReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& MarkMsgsAsReadReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.MarkMsgsAsReadReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkMsgsAsReadReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MarkMsgsAsReadReq.userID)
}
inline std::string* MarkMsgsAsReadReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.MarkMsgsAsReadReq.userID)
  return _s;
}
inline const std::string& MarkMsgsAsReadReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void MarkMsgsAsReadReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkMsgsAsReadReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkMsgsAsReadReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.MarkMsgsAsReadReq.userID)
  return _impl_.userid_.Release();
}
inline void MarkMsgsAsReadReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MarkMsgsAsReadReq.userID)
}

// -------------------------------------------------------------------

// MarkMsgsAsReadResp

// -------------------------------------------------------------------

// MarkConversationAsReadReq

// string conversationID = 1;
inline void MarkConversationAsReadReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& MarkConversationAsReadReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.MarkConversationAsReadReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkConversationAsReadReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MarkConversationAsReadReq.conversationID)
}
inline std::string* MarkConversationAsReadReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.MarkConversationAsReadReq.conversationID)
  return _s;
}
inline const std::string& MarkConversationAsReadReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void MarkConversationAsReadReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkConversationAsReadReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkConversationAsReadReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.MarkConversationAsReadReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void MarkConversationAsReadReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MarkConversationAsReadReq.conversationID)
}

// string userID = 2;
inline void MarkConversationAsReadReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& MarkConversationAsReadReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.MarkConversationAsReadReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkConversationAsReadReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.MarkConversationAsReadReq.userID)
}
inline std::string* MarkConversationAsReadReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.MarkConversationAsReadReq.userID)
  return _s;
}
inline const std::string& MarkConversationAsReadReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void MarkConversationAsReadReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkConversationAsReadReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkConversationAsReadReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.MarkConversationAsReadReq.userID)
  return _impl_.userid_.Release();
}
inline void MarkConversationAsReadReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.MarkConversationAsReadReq.userID)
}

// int64 hasReadSeq = 3;
inline void MarkConversationAsReadReq::clear_hasreadseq() {
  _impl_.hasreadseq_ = int64_t{0};
}
inline int64_t MarkConversationAsReadReq::_internal_hasreadseq() const {
  return _impl_.hasreadseq_;
}
inline int64_t MarkConversationAsReadReq::hasreadseq() const {
  // @@protoc_insertion_point(field_get:msg.MarkConversationAsReadReq.hasReadSeq)
  return _internal_hasreadseq();
}
inline void MarkConversationAsReadReq::_internal_set_hasreadseq(int64_t value) {
  
  _impl_.hasreadseq_ = value;
}
inline void MarkConversationAsReadReq::set_hasreadseq(int64_t value) {
  _internal_set_hasreadseq(value);
  // @@protoc_insertion_point(field_set:msg.MarkConversationAsReadReq.hasReadSeq)
}

// repeated int64 seqs = 4;
inline int MarkConversationAsReadReq::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int MarkConversationAsReadReq::seqs_size() const {
  return _internal_seqs_size();
}
inline void MarkConversationAsReadReq::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline int64_t MarkConversationAsReadReq::_internal_seqs(int index) const {
  return _impl_.seqs_.Get(index);
}
inline int64_t MarkConversationAsReadReq::seqs(int index) const {
  // @@protoc_insertion_point(field_get:msg.MarkConversationAsReadReq.seqs)
  return _internal_seqs(index);
}
inline void MarkConversationAsReadReq::set_seqs(int index, int64_t value) {
  _impl_.seqs_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.MarkConversationAsReadReq.seqs)
}
inline void MarkConversationAsReadReq::_internal_add_seqs(int64_t value) {
  _impl_.seqs_.Add(value);
}
inline void MarkConversationAsReadReq::add_seqs(int64_t value) {
  _internal_add_seqs(value);
  // @@protoc_insertion_point(field_add:msg.MarkConversationAsReadReq.seqs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
MarkConversationAsReadReq::_internal_seqs() const {
  return _impl_.seqs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
MarkConversationAsReadReq::seqs() const {
  // @@protoc_insertion_point(field_list:msg.MarkConversationAsReadReq.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
MarkConversationAsReadReq::_internal_mutable_seqs() {
  return &_impl_.seqs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
MarkConversationAsReadReq::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_list:msg.MarkConversationAsReadReq.seqs)
  return _internal_mutable_seqs();
}

// -------------------------------------------------------------------

// MarkConversationAsReadResp

// -------------------------------------------------------------------

// SetConversationHasReadSeqReq

// string conversationID = 1;
inline void SetConversationHasReadSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& SetConversationHasReadSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.SetConversationHasReadSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetConversationHasReadSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SetConversationHasReadSeqReq.conversationID)
}
inline std::string* SetConversationHasReadSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.SetConversationHasReadSeqReq.conversationID)
  return _s;
}
inline const std::string& SetConversationHasReadSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void SetConversationHasReadSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetConversationHasReadSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetConversationHasReadSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.SetConversationHasReadSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void SetConversationHasReadSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SetConversationHasReadSeqReq.conversationID)
}

// string userID = 2;
inline void SetConversationHasReadSeqReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& SetConversationHasReadSeqReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.SetConversationHasReadSeqReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetConversationHasReadSeqReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SetConversationHasReadSeqReq.userID)
}
inline std::string* SetConversationHasReadSeqReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.SetConversationHasReadSeqReq.userID)
  return _s;
}
inline const std::string& SetConversationHasReadSeqReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void SetConversationHasReadSeqReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetConversationHasReadSeqReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetConversationHasReadSeqReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.SetConversationHasReadSeqReq.userID)
  return _impl_.userid_.Release();
}
inline void SetConversationHasReadSeqReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SetConversationHasReadSeqReq.userID)
}

// int64 hasReadSeq = 3;
inline void SetConversationHasReadSeqReq::clear_hasreadseq() {
  _impl_.hasreadseq_ = int64_t{0};
}
inline int64_t SetConversationHasReadSeqReq::_internal_hasreadseq() const {
  return _impl_.hasreadseq_;
}
inline int64_t SetConversationHasReadSeqReq::hasreadseq() const {
  // @@protoc_insertion_point(field_get:msg.SetConversationHasReadSeqReq.hasReadSeq)
  return _internal_hasreadseq();
}
inline void SetConversationHasReadSeqReq::_internal_set_hasreadseq(int64_t value) {
  
  _impl_.hasreadseq_ = value;
}
inline void SetConversationHasReadSeqReq::set_hasreadseq(int64_t value) {
  _internal_set_hasreadseq(value);
  // @@protoc_insertion_point(field_set:msg.SetConversationHasReadSeqReq.hasReadSeq)
}

// bool noNotification = 4;
inline void SetConversationHasReadSeqReq::clear_nonotification() {
  _impl_.nonotification_ = false;
}
inline bool SetConversationHasReadSeqReq::_internal_nonotification() const {
  return _impl_.nonotification_;
}
inline bool SetConversationHasReadSeqReq::nonotification() const {
  // @@protoc_insertion_point(field_get:msg.SetConversationHasReadSeqReq.noNotification)
  return _internal_nonotification();
}
inline void SetConversationHasReadSeqReq::_internal_set_nonotification(bool value) {
  
  _impl_.nonotification_ = value;
}
inline void SetConversationHasReadSeqReq::set_nonotification(bool value) {
  _internal_set_nonotification(value);
  // @@protoc_insertion_point(field_set:msg.SetConversationHasReadSeqReq.noNotification)
}

// -------------------------------------------------------------------

// SetConversationHasReadSeqResp

// -------------------------------------------------------------------

// DeleteSyncOpt

// bool IsSyncSelf = 3;
inline void DeleteSyncOpt::clear_issyncself() {
  _impl_.issyncself_ = false;
}
inline bool DeleteSyncOpt::_internal_issyncself() const {
  return _impl_.issyncself_;
}
inline bool DeleteSyncOpt::issyncself() const {
  // @@protoc_insertion_point(field_get:msg.DeleteSyncOpt.IsSyncSelf)
  return _internal_issyncself();
}
inline void DeleteSyncOpt::_internal_set_issyncself(bool value) {
  
  _impl_.issyncself_ = value;
}
inline void DeleteSyncOpt::set_issyncself(bool value) {
  _internal_set_issyncself(value);
  // @@protoc_insertion_point(field_set:msg.DeleteSyncOpt.IsSyncSelf)
}

// bool IsSyncOther = 4;
inline void DeleteSyncOpt::clear_issyncother() {
  _impl_.issyncother_ = false;
}
inline bool DeleteSyncOpt::_internal_issyncother() const {
  return _impl_.issyncother_;
}
inline bool DeleteSyncOpt::issyncother() const {
  // @@protoc_insertion_point(field_get:msg.DeleteSyncOpt.IsSyncOther)
  return _internal_issyncother();
}
inline void DeleteSyncOpt::_internal_set_issyncother(bool value) {
  
  _impl_.issyncother_ = value;
}
inline void DeleteSyncOpt::set_issyncother(bool value) {
  _internal_set_issyncother(value);
  // @@protoc_insertion_point(field_set:msg.DeleteSyncOpt.IsSyncOther)
}

// -------------------------------------------------------------------

// ClearConversationsMsgReq

// repeated string conversationIDs = 1;
inline int ClearConversationsMsgReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int ClearConversationsMsgReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void ClearConversationsMsgReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* ClearConversationsMsgReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.ClearConversationsMsgReq.conversationIDs)
  return _s;
}
inline const std::string& ClearConversationsMsgReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& ClearConversationsMsgReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.ClearConversationsMsgReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* ClearConversationsMsgReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.ClearConversationsMsgReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void ClearConversationsMsgReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.ClearConversationsMsgReq.conversationIDs)
}
inline void ClearConversationsMsgReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.ClearConversationsMsgReq.conversationIDs)
}
inline void ClearConversationsMsgReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.ClearConversationsMsgReq.conversationIDs)
}
inline void ClearConversationsMsgReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.ClearConversationsMsgReq.conversationIDs)
}
inline std::string* ClearConversationsMsgReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void ClearConversationsMsgReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.ClearConversationsMsgReq.conversationIDs)
}
inline void ClearConversationsMsgReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.ClearConversationsMsgReq.conversationIDs)
}
inline void ClearConversationsMsgReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.ClearConversationsMsgReq.conversationIDs)
}
inline void ClearConversationsMsgReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.ClearConversationsMsgReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClearConversationsMsgReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.ClearConversationsMsgReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClearConversationsMsgReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.ClearConversationsMsgReq.conversationIDs)
  return &_impl_.conversationids_;
}

// string userID = 2;
inline void ClearConversationsMsgReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& ClearConversationsMsgReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.ClearConversationsMsgReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearConversationsMsgReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ClearConversationsMsgReq.userID)
}
inline std::string* ClearConversationsMsgReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.ClearConversationsMsgReq.userID)
  return _s;
}
inline const std::string& ClearConversationsMsgReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ClearConversationsMsgReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearConversationsMsgReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearConversationsMsgReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.ClearConversationsMsgReq.userID)
  return _impl_.userid_.Release();
}
inline void ClearConversationsMsgReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ClearConversationsMsgReq.userID)
}

// .msg.DeleteSyncOpt deleteSyncOpt = 3;
inline bool ClearConversationsMsgReq::_internal_has_deletesyncopt() const {
  return this != internal_default_instance() && _impl_.deletesyncopt_ != nullptr;
}
inline bool ClearConversationsMsgReq::has_deletesyncopt() const {
  return _internal_has_deletesyncopt();
}
inline void ClearConversationsMsgReq::clear_deletesyncopt() {
  if (GetArenaForAllocation() == nullptr && _impl_.deletesyncopt_ != nullptr) {
    delete _impl_.deletesyncopt_;
  }
  _impl_.deletesyncopt_ = nullptr;
}
inline const ::msg::DeleteSyncOpt& ClearConversationsMsgReq::_internal_deletesyncopt() const {
  const ::msg::DeleteSyncOpt* p = _impl_.deletesyncopt_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::DeleteSyncOpt&>(
      ::msg::_DeleteSyncOpt_default_instance_);
}
inline const ::msg::DeleteSyncOpt& ClearConversationsMsgReq::deletesyncopt() const {
  // @@protoc_insertion_point(field_get:msg.ClearConversationsMsgReq.deleteSyncOpt)
  return _internal_deletesyncopt();
}
inline void ClearConversationsMsgReq::unsafe_arena_set_allocated_deletesyncopt(
    ::msg::DeleteSyncOpt* deletesyncopt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletesyncopt_);
  }
  _impl_.deletesyncopt_ = deletesyncopt;
  if (deletesyncopt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ClearConversationsMsgReq.deleteSyncOpt)
}
inline ::msg::DeleteSyncOpt* ClearConversationsMsgReq::release_deletesyncopt() {
  
  ::msg::DeleteSyncOpt* temp = _impl_.deletesyncopt_;
  _impl_.deletesyncopt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::DeleteSyncOpt* ClearConversationsMsgReq::unsafe_arena_release_deletesyncopt() {
  // @@protoc_insertion_point(field_release:msg.ClearConversationsMsgReq.deleteSyncOpt)
  
  ::msg::DeleteSyncOpt* temp = _impl_.deletesyncopt_;
  _impl_.deletesyncopt_ = nullptr;
  return temp;
}
inline ::msg::DeleteSyncOpt* ClearConversationsMsgReq::_internal_mutable_deletesyncopt() {
  
  if (_impl_.deletesyncopt_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::DeleteSyncOpt>(GetArenaForAllocation());
    _impl_.deletesyncopt_ = p;
  }
  return _impl_.deletesyncopt_;
}
inline ::msg::DeleteSyncOpt* ClearConversationsMsgReq::mutable_deletesyncopt() {
  ::msg::DeleteSyncOpt* _msg = _internal_mutable_deletesyncopt();
  // @@protoc_insertion_point(field_mutable:msg.ClearConversationsMsgReq.deleteSyncOpt)
  return _msg;
}
inline void ClearConversationsMsgReq::set_allocated_deletesyncopt(::msg::DeleteSyncOpt* deletesyncopt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deletesyncopt_;
  }
  if (deletesyncopt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deletesyncopt);
    if (message_arena != submessage_arena) {
      deletesyncopt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletesyncopt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deletesyncopt_ = deletesyncopt;
  // @@protoc_insertion_point(field_set_allocated:msg.ClearConversationsMsgReq.deleteSyncOpt)
}

// -------------------------------------------------------------------

// ClearConversationsMsgResp

// -------------------------------------------------------------------

// UserClearAllMsgReq

// string userID = 1;
inline void UserClearAllMsgReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserClearAllMsgReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.UserClearAllMsgReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserClearAllMsgReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.UserClearAllMsgReq.userID)
}
inline std::string* UserClearAllMsgReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.UserClearAllMsgReq.userID)
  return _s;
}
inline const std::string& UserClearAllMsgReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserClearAllMsgReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserClearAllMsgReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserClearAllMsgReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.UserClearAllMsgReq.userID)
  return _impl_.userid_.Release();
}
inline void UserClearAllMsgReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.UserClearAllMsgReq.userID)
}

// .msg.DeleteSyncOpt deleteSyncOpt = 3;
inline bool UserClearAllMsgReq::_internal_has_deletesyncopt() const {
  return this != internal_default_instance() && _impl_.deletesyncopt_ != nullptr;
}
inline bool UserClearAllMsgReq::has_deletesyncopt() const {
  return _internal_has_deletesyncopt();
}
inline void UserClearAllMsgReq::clear_deletesyncopt() {
  if (GetArenaForAllocation() == nullptr && _impl_.deletesyncopt_ != nullptr) {
    delete _impl_.deletesyncopt_;
  }
  _impl_.deletesyncopt_ = nullptr;
}
inline const ::msg::DeleteSyncOpt& UserClearAllMsgReq::_internal_deletesyncopt() const {
  const ::msg::DeleteSyncOpt* p = _impl_.deletesyncopt_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::DeleteSyncOpt&>(
      ::msg::_DeleteSyncOpt_default_instance_);
}
inline const ::msg::DeleteSyncOpt& UserClearAllMsgReq::deletesyncopt() const {
  // @@protoc_insertion_point(field_get:msg.UserClearAllMsgReq.deleteSyncOpt)
  return _internal_deletesyncopt();
}
inline void UserClearAllMsgReq::unsafe_arena_set_allocated_deletesyncopt(
    ::msg::DeleteSyncOpt* deletesyncopt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletesyncopt_);
  }
  _impl_.deletesyncopt_ = deletesyncopt;
  if (deletesyncopt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.UserClearAllMsgReq.deleteSyncOpt)
}
inline ::msg::DeleteSyncOpt* UserClearAllMsgReq::release_deletesyncopt() {
  
  ::msg::DeleteSyncOpt* temp = _impl_.deletesyncopt_;
  _impl_.deletesyncopt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::DeleteSyncOpt* UserClearAllMsgReq::unsafe_arena_release_deletesyncopt() {
  // @@protoc_insertion_point(field_release:msg.UserClearAllMsgReq.deleteSyncOpt)
  
  ::msg::DeleteSyncOpt* temp = _impl_.deletesyncopt_;
  _impl_.deletesyncopt_ = nullptr;
  return temp;
}
inline ::msg::DeleteSyncOpt* UserClearAllMsgReq::_internal_mutable_deletesyncopt() {
  
  if (_impl_.deletesyncopt_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::DeleteSyncOpt>(GetArenaForAllocation());
    _impl_.deletesyncopt_ = p;
  }
  return _impl_.deletesyncopt_;
}
inline ::msg::DeleteSyncOpt* UserClearAllMsgReq::mutable_deletesyncopt() {
  ::msg::DeleteSyncOpt* _msg = _internal_mutable_deletesyncopt();
  // @@protoc_insertion_point(field_mutable:msg.UserClearAllMsgReq.deleteSyncOpt)
  return _msg;
}
inline void UserClearAllMsgReq::set_allocated_deletesyncopt(::msg::DeleteSyncOpt* deletesyncopt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deletesyncopt_;
  }
  if (deletesyncopt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deletesyncopt);
    if (message_arena != submessage_arena) {
      deletesyncopt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletesyncopt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deletesyncopt_ = deletesyncopt;
  // @@protoc_insertion_point(field_set_allocated:msg.UserClearAllMsgReq.deleteSyncOpt)
}

// -------------------------------------------------------------------

// UserClearAllMsgResp

// -------------------------------------------------------------------

// DeleteMsgsReq

// string conversationID = 1;
inline void DeleteMsgsReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& DeleteMsgsReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgsReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteMsgsReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.DeleteMsgsReq.conversationID)
}
inline std::string* DeleteMsgsReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.DeleteMsgsReq.conversationID)
  return _s;
}
inline const std::string& DeleteMsgsReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void DeleteMsgsReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteMsgsReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteMsgsReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.DeleteMsgsReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void DeleteMsgsReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.DeleteMsgsReq.conversationID)
}

// repeated int64 seqs = 2;
inline int DeleteMsgsReq::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int DeleteMsgsReq::seqs_size() const {
  return _internal_seqs_size();
}
inline void DeleteMsgsReq::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline int64_t DeleteMsgsReq::_internal_seqs(int index) const {
  return _impl_.seqs_.Get(index);
}
inline int64_t DeleteMsgsReq::seqs(int index) const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgsReq.seqs)
  return _internal_seqs(index);
}
inline void DeleteMsgsReq::set_seqs(int index, int64_t value) {
  _impl_.seqs_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.DeleteMsgsReq.seqs)
}
inline void DeleteMsgsReq::_internal_add_seqs(int64_t value) {
  _impl_.seqs_.Add(value);
}
inline void DeleteMsgsReq::add_seqs(int64_t value) {
  _internal_add_seqs(value);
  // @@protoc_insertion_point(field_add:msg.DeleteMsgsReq.seqs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DeleteMsgsReq::_internal_seqs() const {
  return _impl_.seqs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DeleteMsgsReq::seqs() const {
  // @@protoc_insertion_point(field_list:msg.DeleteMsgsReq.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DeleteMsgsReq::_internal_mutable_seqs() {
  return &_impl_.seqs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DeleteMsgsReq::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_list:msg.DeleteMsgsReq.seqs)
  return _internal_mutable_seqs();
}

// string userID = 3;
inline void DeleteMsgsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& DeleteMsgsReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgsReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteMsgsReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.DeleteMsgsReq.userID)
}
inline std::string* DeleteMsgsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.DeleteMsgsReq.userID)
  return _s;
}
inline const std::string& DeleteMsgsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void DeleteMsgsReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteMsgsReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteMsgsReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.DeleteMsgsReq.userID)
  return _impl_.userid_.Release();
}
inline void DeleteMsgsReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.DeleteMsgsReq.userID)
}

// .msg.DeleteSyncOpt deleteSyncOpt = 4;
inline bool DeleteMsgsReq::_internal_has_deletesyncopt() const {
  return this != internal_default_instance() && _impl_.deletesyncopt_ != nullptr;
}
inline bool DeleteMsgsReq::has_deletesyncopt() const {
  return _internal_has_deletesyncopt();
}
inline void DeleteMsgsReq::clear_deletesyncopt() {
  if (GetArenaForAllocation() == nullptr && _impl_.deletesyncopt_ != nullptr) {
    delete _impl_.deletesyncopt_;
  }
  _impl_.deletesyncopt_ = nullptr;
}
inline const ::msg::DeleteSyncOpt& DeleteMsgsReq::_internal_deletesyncopt() const {
  const ::msg::DeleteSyncOpt* p = _impl_.deletesyncopt_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::DeleteSyncOpt&>(
      ::msg::_DeleteSyncOpt_default_instance_);
}
inline const ::msg::DeleteSyncOpt& DeleteMsgsReq::deletesyncopt() const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgsReq.deleteSyncOpt)
  return _internal_deletesyncopt();
}
inline void DeleteMsgsReq::unsafe_arena_set_allocated_deletesyncopt(
    ::msg::DeleteSyncOpt* deletesyncopt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletesyncopt_);
  }
  _impl_.deletesyncopt_ = deletesyncopt;
  if (deletesyncopt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.DeleteMsgsReq.deleteSyncOpt)
}
inline ::msg::DeleteSyncOpt* DeleteMsgsReq::release_deletesyncopt() {
  
  ::msg::DeleteSyncOpt* temp = _impl_.deletesyncopt_;
  _impl_.deletesyncopt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::DeleteSyncOpt* DeleteMsgsReq::unsafe_arena_release_deletesyncopt() {
  // @@protoc_insertion_point(field_release:msg.DeleteMsgsReq.deleteSyncOpt)
  
  ::msg::DeleteSyncOpt* temp = _impl_.deletesyncopt_;
  _impl_.deletesyncopt_ = nullptr;
  return temp;
}
inline ::msg::DeleteSyncOpt* DeleteMsgsReq::_internal_mutable_deletesyncopt() {
  
  if (_impl_.deletesyncopt_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::DeleteSyncOpt>(GetArenaForAllocation());
    _impl_.deletesyncopt_ = p;
  }
  return _impl_.deletesyncopt_;
}
inline ::msg::DeleteSyncOpt* DeleteMsgsReq::mutable_deletesyncopt() {
  ::msg::DeleteSyncOpt* _msg = _internal_mutable_deletesyncopt();
  // @@protoc_insertion_point(field_mutable:msg.DeleteMsgsReq.deleteSyncOpt)
  return _msg;
}
inline void DeleteMsgsReq::set_allocated_deletesyncopt(::msg::DeleteSyncOpt* deletesyncopt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deletesyncopt_;
  }
  if (deletesyncopt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deletesyncopt);
    if (message_arena != submessage_arena) {
      deletesyncopt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletesyncopt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deletesyncopt_ = deletesyncopt;
  // @@protoc_insertion_point(field_set_allocated:msg.DeleteMsgsReq.deleteSyncOpt)
}

// -------------------------------------------------------------------

// DeleteMsgsResp

// -------------------------------------------------------------------

// DeleteMsgPhysicalReq

// repeated string conversationIDs = 1;
inline int DeleteMsgPhysicalReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int DeleteMsgPhysicalReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void DeleteMsgPhysicalReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* DeleteMsgPhysicalReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.DeleteMsgPhysicalReq.conversationIDs)
  return _s;
}
inline const std::string& DeleteMsgPhysicalReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& DeleteMsgPhysicalReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgPhysicalReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* DeleteMsgPhysicalReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.DeleteMsgPhysicalReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void DeleteMsgPhysicalReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline void DeleteMsgPhysicalReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline void DeleteMsgPhysicalReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline void DeleteMsgPhysicalReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline std::string* DeleteMsgPhysicalReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void DeleteMsgPhysicalReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline void DeleteMsgPhysicalReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline void DeleteMsgPhysicalReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline void DeleteMsgPhysicalReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.DeleteMsgPhysicalReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteMsgPhysicalReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.DeleteMsgPhysicalReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteMsgPhysicalReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.DeleteMsgPhysicalReq.conversationIDs)
  return &_impl_.conversationids_;
}

// int64 timestamp = 2;
inline void DeleteMsgPhysicalReq::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t DeleteMsgPhysicalReq::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t DeleteMsgPhysicalReq::timestamp() const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgPhysicalReq.timestamp)
  return _internal_timestamp();
}
inline void DeleteMsgPhysicalReq::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void DeleteMsgPhysicalReq::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:msg.DeleteMsgPhysicalReq.timestamp)
}

// -------------------------------------------------------------------

// DeleteMsgPhysicalResp

// -------------------------------------------------------------------

// DeleteMsgPhysicalBySeqReq

// string conversationID = 1;
inline void DeleteMsgPhysicalBySeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& DeleteMsgPhysicalBySeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgPhysicalBySeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteMsgPhysicalBySeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.DeleteMsgPhysicalBySeqReq.conversationID)
}
inline std::string* DeleteMsgPhysicalBySeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.DeleteMsgPhysicalBySeqReq.conversationID)
  return _s;
}
inline const std::string& DeleteMsgPhysicalBySeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void DeleteMsgPhysicalBySeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteMsgPhysicalBySeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteMsgPhysicalBySeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.DeleteMsgPhysicalBySeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void DeleteMsgPhysicalBySeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.DeleteMsgPhysicalBySeqReq.conversationID)
}

// repeated int64 seqs = 2;
inline int DeleteMsgPhysicalBySeqReq::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int DeleteMsgPhysicalBySeqReq::seqs_size() const {
  return _internal_seqs_size();
}
inline void DeleteMsgPhysicalBySeqReq::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline int64_t DeleteMsgPhysicalBySeqReq::_internal_seqs(int index) const {
  return _impl_.seqs_.Get(index);
}
inline int64_t DeleteMsgPhysicalBySeqReq::seqs(int index) const {
  // @@protoc_insertion_point(field_get:msg.DeleteMsgPhysicalBySeqReq.seqs)
  return _internal_seqs(index);
}
inline void DeleteMsgPhysicalBySeqReq::set_seqs(int index, int64_t value) {
  _impl_.seqs_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.DeleteMsgPhysicalBySeqReq.seqs)
}
inline void DeleteMsgPhysicalBySeqReq::_internal_add_seqs(int64_t value) {
  _impl_.seqs_.Add(value);
}
inline void DeleteMsgPhysicalBySeqReq::add_seqs(int64_t value) {
  _internal_add_seqs(value);
  // @@protoc_insertion_point(field_add:msg.DeleteMsgPhysicalBySeqReq.seqs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DeleteMsgPhysicalBySeqReq::_internal_seqs() const {
  return _impl_.seqs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DeleteMsgPhysicalBySeqReq::seqs() const {
  // @@protoc_insertion_point(field_list:msg.DeleteMsgPhysicalBySeqReq.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DeleteMsgPhysicalBySeqReq::_internal_mutable_seqs() {
  return &_impl_.seqs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DeleteMsgPhysicalBySeqReq::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_list:msg.DeleteMsgPhysicalBySeqReq.seqs)
  return _internal_mutable_seqs();
}

// -------------------------------------------------------------------

// DeleteMsgPhysicalBySeqResp

// -------------------------------------------------------------------

// GetMaxSeqsReq

// repeated string conversationIDs = 1;
inline int GetMaxSeqsReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetMaxSeqsReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetMaxSeqsReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetMaxSeqsReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetMaxSeqsReq.conversationIDs)
  return _s;
}
inline const std::string& GetMaxSeqsReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetMaxSeqsReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetMaxSeqsReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetMaxSeqsReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetMaxSeqsReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetMaxSeqsReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetMaxSeqsReq.conversationIDs)
}
inline void GetMaxSeqsReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetMaxSeqsReq.conversationIDs)
}
inline void GetMaxSeqsReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetMaxSeqsReq.conversationIDs)
}
inline void GetMaxSeqsReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetMaxSeqsReq.conversationIDs)
}
inline std::string* GetMaxSeqsReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetMaxSeqsReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetMaxSeqsReq.conversationIDs)
}
inline void GetMaxSeqsReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetMaxSeqsReq.conversationIDs)
}
inline void GetMaxSeqsReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetMaxSeqsReq.conversationIDs)
}
inline void GetMaxSeqsReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetMaxSeqsReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetMaxSeqsReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetMaxSeqsReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetMaxSeqsReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetMaxSeqsReq.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// GetHasReadSeqsReq

// string userID = 1;
inline void GetHasReadSeqsReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetHasReadSeqsReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.GetHasReadSeqsReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetHasReadSeqsReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetHasReadSeqsReq.userID)
}
inline std::string* GetHasReadSeqsReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.GetHasReadSeqsReq.userID)
  return _s;
}
inline const std::string& GetHasReadSeqsReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetHasReadSeqsReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetHasReadSeqsReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetHasReadSeqsReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.GetHasReadSeqsReq.userID)
  return _impl_.userid_.Release();
}
inline void GetHasReadSeqsReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetHasReadSeqsReq.userID)
}

// repeated string conversationIDs = 2;
inline int GetHasReadSeqsReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetHasReadSeqsReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetHasReadSeqsReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetHasReadSeqsReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetHasReadSeqsReq.conversationIDs)
  return _s;
}
inline const std::string& GetHasReadSeqsReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetHasReadSeqsReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetHasReadSeqsReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetHasReadSeqsReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetHasReadSeqsReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetHasReadSeqsReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetHasReadSeqsReq.conversationIDs)
}
inline void GetHasReadSeqsReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetHasReadSeqsReq.conversationIDs)
}
inline void GetHasReadSeqsReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetHasReadSeqsReq.conversationIDs)
}
inline void GetHasReadSeqsReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetHasReadSeqsReq.conversationIDs)
}
inline std::string* GetHasReadSeqsReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetHasReadSeqsReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetHasReadSeqsReq.conversationIDs)
}
inline void GetHasReadSeqsReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetHasReadSeqsReq.conversationIDs)
}
inline void GetHasReadSeqsReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetHasReadSeqsReq.conversationIDs)
}
inline void GetHasReadSeqsReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetHasReadSeqsReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetHasReadSeqsReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetHasReadSeqsReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetHasReadSeqsReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetHasReadSeqsReq.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SeqsInfoResp

// map<string, int64> maxSeqs = 1;
inline int SeqsInfoResp::_internal_maxseqs_size() const {
  return _impl_.maxseqs_.size();
}
inline int SeqsInfoResp::maxseqs_size() const {
  return _internal_maxseqs_size();
}
inline void SeqsInfoResp::clear_maxseqs() {
  _impl_.maxseqs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
SeqsInfoResp::_internal_maxseqs() const {
  return _impl_.maxseqs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
SeqsInfoResp::maxseqs() const {
  // @@protoc_insertion_point(field_map:msg.SeqsInfoResp.maxSeqs)
  return _internal_maxseqs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
SeqsInfoResp::_internal_mutable_maxseqs() {
  return _impl_.maxseqs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
SeqsInfoResp::mutable_maxseqs() {
  // @@protoc_insertion_point(field_mutable_map:msg.SeqsInfoResp.maxSeqs)
  return _internal_mutable_maxseqs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetMsgByConversationIDsReq

// repeated string conversationIDs = 1;
inline int GetMsgByConversationIDsReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetMsgByConversationIDsReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetMsgByConversationIDsReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetMsgByConversationIDsReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetMsgByConversationIDsReq.conversationIDs)
  return _s;
}
inline const std::string& GetMsgByConversationIDsReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetMsgByConversationIDsReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetMsgByConversationIDsReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetMsgByConversationIDsReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetMsgByConversationIDsReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetMsgByConversationIDsReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline void GetMsgByConversationIDsReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline void GetMsgByConversationIDsReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline void GetMsgByConversationIDsReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline std::string* GetMsgByConversationIDsReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetMsgByConversationIDsReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline void GetMsgByConversationIDsReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline void GetMsgByConversationIDsReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline void GetMsgByConversationIDsReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetMsgByConversationIDsReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetMsgByConversationIDsReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetMsgByConversationIDsReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetMsgByConversationIDsReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetMsgByConversationIDsReq.conversationIDs)
  return &_impl_.conversationids_;
}

// map<string, int64> maxSeqs = 2;
inline int GetMsgByConversationIDsReq::_internal_maxseqs_size() const {
  return _impl_.maxseqs_.size();
}
inline int GetMsgByConversationIDsReq::maxseqs_size() const {
  return _internal_maxseqs_size();
}
inline void GetMsgByConversationIDsReq::clear_maxseqs() {
  _impl_.maxseqs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
GetMsgByConversationIDsReq::_internal_maxseqs() const {
  return _impl_.maxseqs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
GetMsgByConversationIDsReq::maxseqs() const {
  // @@protoc_insertion_point(field_map:msg.GetMsgByConversationIDsReq.maxSeqs)
  return _internal_maxseqs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
GetMsgByConversationIDsReq::_internal_mutable_maxseqs() {
  return _impl_.maxseqs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
GetMsgByConversationIDsReq::mutable_maxseqs() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetMsgByConversationIDsReq.maxSeqs)
  return _internal_mutable_maxseqs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetMsgByConversationIDsResp

// map<string, .sdkws.MsgData> msgDatas = 1;
inline int GetMsgByConversationIDsResp::_internal_msgdatas_size() const {
  return _impl_.msgdatas_.size();
}
inline int GetMsgByConversationIDsResp::msgdatas_size() const {
  return _internal_msgdatas_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
GetMsgByConversationIDsResp::_internal_msgdatas() const {
  return _impl_.msgdatas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
GetMsgByConversationIDsResp::msgdatas() const {
  // @@protoc_insertion_point(field_map:msg.GetMsgByConversationIDsResp.msgDatas)
  return _internal_msgdatas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
GetMsgByConversationIDsResp::_internal_mutable_msgdatas() {
  return _impl_.msgdatas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
GetMsgByConversationIDsResp::mutable_msgdatas() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetMsgByConversationIDsResp.msgDatas)
  return _internal_mutable_msgdatas();
}

// -------------------------------------------------------------------

// GetConversationMaxSeqReq

// string conversationID = 1;
inline void GetConversationMaxSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& GetConversationMaxSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.GetConversationMaxSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationMaxSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetConversationMaxSeqReq.conversationID)
}
inline std::string* GetConversationMaxSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.GetConversationMaxSeqReq.conversationID)
  return _s;
}
inline const std::string& GetConversationMaxSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void GetConversationMaxSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationMaxSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationMaxSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.GetConversationMaxSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void GetConversationMaxSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetConversationMaxSeqReq.conversationID)
}

// -------------------------------------------------------------------

// GetConversationMaxSeqResp

// int64 maxSeq = 1;
inline void GetConversationMaxSeqResp::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t GetConversationMaxSeqResp::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t GetConversationMaxSeqResp::maxseq() const {
  // @@protoc_insertion_point(field_get:msg.GetConversationMaxSeqResp.maxSeq)
  return _internal_maxseq();
}
inline void GetConversationMaxSeqResp::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void GetConversationMaxSeqResp::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:msg.GetConversationMaxSeqResp.maxSeq)
}

// -------------------------------------------------------------------

// GetConversationsHasReadAndMaxSeqReq

// string userID = 1;
inline void GetConversationsHasReadAndMaxSeqReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetConversationsHasReadAndMaxSeqReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.GetConversationsHasReadAndMaxSeqReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationsHasReadAndMaxSeqReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetConversationsHasReadAndMaxSeqReq.userID)
}
inline std::string* GetConversationsHasReadAndMaxSeqReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.GetConversationsHasReadAndMaxSeqReq.userID)
  return _s;
}
inline const std::string& GetConversationsHasReadAndMaxSeqReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetConversationsHasReadAndMaxSeqReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationsHasReadAndMaxSeqReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationsHasReadAndMaxSeqReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.GetConversationsHasReadAndMaxSeqReq.userID)
  return _impl_.userid_.Release();
}
inline void GetConversationsHasReadAndMaxSeqReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetConversationsHasReadAndMaxSeqReq.userID)
}

// repeated string conversationIDs = 2;
inline int GetConversationsHasReadAndMaxSeqReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetConversationsHasReadAndMaxSeqReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetConversationsHasReadAndMaxSeqReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetConversationsHasReadAndMaxSeqReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
  return _s;
}
inline const std::string& GetConversationsHasReadAndMaxSeqReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetConversationsHasReadAndMaxSeqReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetConversationsHasReadAndMaxSeqReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetConversationsHasReadAndMaxSeqReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline std::string* GetConversationsHasReadAndMaxSeqReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetConversationsHasReadAndMaxSeqReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationsHasReadAndMaxSeqReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationsHasReadAndMaxSeqReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetConversationsHasReadAndMaxSeqReq.conversationIDs)
  return &_impl_.conversationids_;
}

// bool returnPinned = 3;
inline void GetConversationsHasReadAndMaxSeqReq::clear_returnpinned() {
  _impl_.returnpinned_ = false;
}
inline bool GetConversationsHasReadAndMaxSeqReq::_internal_returnpinned() const {
  return _impl_.returnpinned_;
}
inline bool GetConversationsHasReadAndMaxSeqReq::returnpinned() const {
  // @@protoc_insertion_point(field_get:msg.GetConversationsHasReadAndMaxSeqReq.returnPinned)
  return _internal_returnpinned();
}
inline void GetConversationsHasReadAndMaxSeqReq::_internal_set_returnpinned(bool value) {
  
  _impl_.returnpinned_ = value;
}
inline void GetConversationsHasReadAndMaxSeqReq::set_returnpinned(bool value) {
  _internal_set_returnpinned(value);
  // @@protoc_insertion_point(field_set:msg.GetConversationsHasReadAndMaxSeqReq.returnPinned)
}

// -------------------------------------------------------------------

// Seqs

// int64 maxSeq = 1;
inline void Seqs::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t Seqs::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t Seqs::maxseq() const {
  // @@protoc_insertion_point(field_get:msg.Seqs.maxSeq)
  return _internal_maxseq();
}
inline void Seqs::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void Seqs::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:msg.Seqs.maxSeq)
}

// int64 hasReadSeq = 2;
inline void Seqs::clear_hasreadseq() {
  _impl_.hasreadseq_ = int64_t{0};
}
inline int64_t Seqs::_internal_hasreadseq() const {
  return _impl_.hasreadseq_;
}
inline int64_t Seqs::hasreadseq() const {
  // @@protoc_insertion_point(field_get:msg.Seqs.hasReadSeq)
  return _internal_hasreadseq();
}
inline void Seqs::_internal_set_hasreadseq(int64_t value) {
  
  _impl_.hasreadseq_ = value;
}
inline void Seqs::set_hasreadseq(int64_t value) {
  _internal_set_hasreadseq(value);
  // @@protoc_insertion_point(field_set:msg.Seqs.hasReadSeq)
}

// int64 maxSeqTime = 3;
inline void Seqs::clear_maxseqtime() {
  _impl_.maxseqtime_ = int64_t{0};
}
inline int64_t Seqs::_internal_maxseqtime() const {
  return _impl_.maxseqtime_;
}
inline int64_t Seqs::maxseqtime() const {
  // @@protoc_insertion_point(field_get:msg.Seqs.maxSeqTime)
  return _internal_maxseqtime();
}
inline void Seqs::_internal_set_maxseqtime(int64_t value) {
  
  _impl_.maxseqtime_ = value;
}
inline void Seqs::set_maxseqtime(int64_t value) {
  _internal_set_maxseqtime(value);
  // @@protoc_insertion_point(field_set:msg.Seqs.maxSeqTime)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetConversationsHasReadAndMaxSeqResp

// map<string, .msg.Seqs> seqs = 1;
inline int GetConversationsHasReadAndMaxSeqResp::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int GetConversationsHasReadAndMaxSeqResp::seqs_size() const {
  return _internal_seqs_size();
}
inline void GetConversationsHasReadAndMaxSeqResp::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >&
GetConversationsHasReadAndMaxSeqResp::_internal_seqs() const {
  return _impl_.seqs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >&
GetConversationsHasReadAndMaxSeqResp::seqs() const {
  // @@protoc_insertion_point(field_map:msg.GetConversationsHasReadAndMaxSeqResp.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >*
GetConversationsHasReadAndMaxSeqResp::_internal_mutable_seqs() {
  return _impl_.seqs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::msg::Seqs >*
GetConversationsHasReadAndMaxSeqResp::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetConversationsHasReadAndMaxSeqResp.seqs)
  return _internal_mutable_seqs();
}

// repeated string pinnedConversationIDs = 2;
inline int GetConversationsHasReadAndMaxSeqResp::_internal_pinnedconversationids_size() const {
  return _impl_.pinnedconversationids_.size();
}
inline int GetConversationsHasReadAndMaxSeqResp::pinnedconversationids_size() const {
  return _internal_pinnedconversationids_size();
}
inline void GetConversationsHasReadAndMaxSeqResp::clear_pinnedconversationids() {
  _impl_.pinnedconversationids_.Clear();
}
inline std::string* GetConversationsHasReadAndMaxSeqResp::add_pinnedconversationids() {
  std::string* _s = _internal_add_pinnedconversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
  return _s;
}
inline const std::string& GetConversationsHasReadAndMaxSeqResp::_internal_pinnedconversationids(int index) const {
  return _impl_.pinnedconversationids_.Get(index);
}
inline const std::string& GetConversationsHasReadAndMaxSeqResp::pinnedconversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
  return _internal_pinnedconversationids(index);
}
inline std::string* GetConversationsHasReadAndMaxSeqResp::mutable_pinnedconversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
  return _impl_.pinnedconversationids_.Mutable(index);
}
inline void GetConversationsHasReadAndMaxSeqResp::set_pinnedconversationids(int index, const std::string& value) {
  _impl_.pinnedconversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqResp::set_pinnedconversationids(int index, std::string&& value) {
  _impl_.pinnedconversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqResp::set_pinnedconversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pinnedconversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqResp::set_pinnedconversationids(int index, const char* value, size_t size) {
  _impl_.pinnedconversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline std::string* GetConversationsHasReadAndMaxSeqResp::_internal_add_pinnedconversationids() {
  return _impl_.pinnedconversationids_.Add();
}
inline void GetConversationsHasReadAndMaxSeqResp::add_pinnedconversationids(const std::string& value) {
  _impl_.pinnedconversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqResp::add_pinnedconversationids(std::string&& value) {
  _impl_.pinnedconversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqResp::add_pinnedconversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pinnedconversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline void GetConversationsHasReadAndMaxSeqResp::add_pinnedconversationids(const char* value, size_t size) {
  _impl_.pinnedconversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConversationsHasReadAndMaxSeqResp::pinnedconversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
  return _impl_.pinnedconversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConversationsHasReadAndMaxSeqResp::mutable_pinnedconversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetConversationsHasReadAndMaxSeqResp.pinnedConversationIDs)
  return &_impl_.pinnedconversationids_;
}

// -------------------------------------------------------------------

// GetActiveUserReq

// int64 start = 1;
inline void GetActiveUserReq::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t GetActiveUserReq::_internal_start() const {
  return _impl_.start_;
}
inline int64_t GetActiveUserReq::start() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserReq.start)
  return _internal_start();
}
inline void GetActiveUserReq::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void GetActiveUserReq::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveUserReq.start)
}

// int64 end = 2;
inline void GetActiveUserReq::clear_end() {
  _impl_.end_ = int64_t{0};
}
inline int64_t GetActiveUserReq::_internal_end() const {
  return _impl_.end_;
}
inline int64_t GetActiveUserReq::end() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserReq.end)
  return _internal_end();
}
inline void GetActiveUserReq::_internal_set_end(int64_t value) {
  
  _impl_.end_ = value;
}
inline void GetActiveUserReq::set_end(int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveUserReq.end)
}

// bool ase = 3;
inline void GetActiveUserReq::clear_ase() {
  _impl_.ase_ = false;
}
inline bool GetActiveUserReq::_internal_ase() const {
  return _impl_.ase_;
}
inline bool GetActiveUserReq::ase() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserReq.ase)
  return _internal_ase();
}
inline void GetActiveUserReq::_internal_set_ase(bool value) {
  
  _impl_.ase_ = value;
}
inline void GetActiveUserReq::set_ase(bool value) {
  _internal_set_ase(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveUserReq.ase)
}

// bool group = 4;
inline void GetActiveUserReq::clear_group() {
  _impl_.group_ = false;
}
inline bool GetActiveUserReq::_internal_group() const {
  return _impl_.group_;
}
inline bool GetActiveUserReq::group() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserReq.group)
  return _internal_group();
}
inline void GetActiveUserReq::_internal_set_group(bool value) {
  
  _impl_.group_ = value;
}
inline void GetActiveUserReq::set_group(bool value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveUserReq.group)
}

// .sdkws.RequestPagination pagination = 5;
inline bool GetActiveUserReq::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetActiveUserReq::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sdkws::RequestPagination& GetActiveUserReq::_internal_pagination() const {
  const ::sdkws::RequestPagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::RequestPagination&>(
      ::sdkws::_RequestPagination_default_instance_);
}
inline const ::sdkws::RequestPagination& GetActiveUserReq::pagination() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserReq.pagination)
  return _internal_pagination();
}
inline void GetActiveUserReq::unsafe_arena_set_allocated_pagination(
    ::sdkws::RequestPagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.GetActiveUserReq.pagination)
}
inline ::sdkws::RequestPagination* GetActiveUserReq::release_pagination() {
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::RequestPagination* GetActiveUserReq::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:msg.GetActiveUserReq.pagination)
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sdkws::RequestPagination* GetActiveUserReq::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::RequestPagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sdkws::RequestPagination* GetActiveUserReq::mutable_pagination() {
  ::sdkws::RequestPagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:msg.GetActiveUserReq.pagination)
  return _msg;
}
inline void GetActiveUserReq::set_allocated_pagination(::sdkws::RequestPagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:msg.GetActiveUserReq.pagination)
}

// -------------------------------------------------------------------

// ActiveUser

// .sdkws.UserInfo user = 1;
inline bool ActiveUser::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool ActiveUser::has_user() const {
  return _internal_has_user();
}
inline const ::sdkws::UserInfo& ActiveUser::_internal_user() const {
  const ::sdkws::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::UserInfo&>(
      ::sdkws::_UserInfo_default_instance_);
}
inline const ::sdkws::UserInfo& ActiveUser::user() const {
  // @@protoc_insertion_point(field_get:msg.ActiveUser.user)
  return _internal_user();
}
inline void ActiveUser::unsafe_arena_set_allocated_user(
    ::sdkws::UserInfo* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ActiveUser.user)
}
inline ::sdkws::UserInfo* ActiveUser::release_user() {
  
  ::sdkws::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::UserInfo* ActiveUser::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:msg.ActiveUser.user)
  
  ::sdkws::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sdkws::UserInfo* ActiveUser::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::UserInfo>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sdkws::UserInfo* ActiveUser::mutable_user() {
  ::sdkws::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:msg.ActiveUser.user)
  return _msg;
}
inline void ActiveUser::set_allocated_user(::sdkws::UserInfo* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user));
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:msg.ActiveUser.user)
}

// int64 count = 2;
inline void ActiveUser::clear_count() {
  _impl_.count_ = int64_t{0};
}
inline int64_t ActiveUser::_internal_count() const {
  return _impl_.count_;
}
inline int64_t ActiveUser::count() const {
  // @@protoc_insertion_point(field_get:msg.ActiveUser.count)
  return _internal_count();
}
inline void ActiveUser::_internal_set_count(int64_t value) {
  
  _impl_.count_ = value;
}
inline void ActiveUser::set_count(int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:msg.ActiveUser.count)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetActiveUserResp

// int64 msgCount = 1;
inline void GetActiveUserResp::clear_msgcount() {
  _impl_.msgcount_ = int64_t{0};
}
inline int64_t GetActiveUserResp::_internal_msgcount() const {
  return _impl_.msgcount_;
}
inline int64_t GetActiveUserResp::msgcount() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserResp.msgCount)
  return _internal_msgcount();
}
inline void GetActiveUserResp::_internal_set_msgcount(int64_t value) {
  
  _impl_.msgcount_ = value;
}
inline void GetActiveUserResp::set_msgcount(int64_t value) {
  _internal_set_msgcount(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveUserResp.msgCount)
}

// int64 userCount = 2;
inline void GetActiveUserResp::clear_usercount() {
  _impl_.usercount_ = int64_t{0};
}
inline int64_t GetActiveUserResp::_internal_usercount() const {
  return _impl_.usercount_;
}
inline int64_t GetActiveUserResp::usercount() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserResp.userCount)
  return _internal_usercount();
}
inline void GetActiveUserResp::_internal_set_usercount(int64_t value) {
  
  _impl_.usercount_ = value;
}
inline void GetActiveUserResp::set_usercount(int64_t value) {
  _internal_set_usercount(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveUserResp.userCount)
}

// map<string, int64> dateCount = 3;
inline int GetActiveUserResp::_internal_datecount_size() const {
  return _impl_.datecount_.size();
}
inline int GetActiveUserResp::datecount_size() const {
  return _internal_datecount_size();
}
inline void GetActiveUserResp::clear_datecount() {
  _impl_.datecount_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
GetActiveUserResp::_internal_datecount() const {
  return _impl_.datecount_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
GetActiveUserResp::datecount() const {
  // @@protoc_insertion_point(field_map:msg.GetActiveUserResp.dateCount)
  return _internal_datecount();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
GetActiveUserResp::_internal_mutable_datecount() {
  return _impl_.datecount_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
GetActiveUserResp::mutable_datecount() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetActiveUserResp.dateCount)
  return _internal_mutable_datecount();
}

// repeated .msg.ActiveUser users = 4;
inline int GetActiveUserResp::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int GetActiveUserResp::users_size() const {
  return _internal_users_size();
}
inline void GetActiveUserResp::clear_users() {
  _impl_.users_.Clear();
}
inline ::msg::ActiveUser* GetActiveUserResp::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetActiveUserResp.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveUser >*
GetActiveUserResp::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetActiveUserResp.users)
  return &_impl_.users_;
}
inline const ::msg::ActiveUser& GetActiveUserResp::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::msg::ActiveUser& GetActiveUserResp::users(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetActiveUserResp.users)
  return _internal_users(index);
}
inline ::msg::ActiveUser* GetActiveUserResp::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::msg::ActiveUser* GetActiveUserResp::add_users() {
  ::msg::ActiveUser* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:msg.GetActiveUserResp.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveUser >&
GetActiveUserResp::users() const {
  // @@protoc_insertion_point(field_list:msg.GetActiveUserResp.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// GetActiveGroupReq

// int64 start = 1;
inline void GetActiveGroupReq::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t GetActiveGroupReq::_internal_start() const {
  return _impl_.start_;
}
inline int64_t GetActiveGroupReq::start() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupReq.start)
  return _internal_start();
}
inline void GetActiveGroupReq::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void GetActiveGroupReq::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveGroupReq.start)
}

// int64 end = 2;
inline void GetActiveGroupReq::clear_end() {
  _impl_.end_ = int64_t{0};
}
inline int64_t GetActiveGroupReq::_internal_end() const {
  return _impl_.end_;
}
inline int64_t GetActiveGroupReq::end() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupReq.end)
  return _internal_end();
}
inline void GetActiveGroupReq::_internal_set_end(int64_t value) {
  
  _impl_.end_ = value;
}
inline void GetActiveGroupReq::set_end(int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveGroupReq.end)
}

// bool ase = 3;
inline void GetActiveGroupReq::clear_ase() {
  _impl_.ase_ = false;
}
inline bool GetActiveGroupReq::_internal_ase() const {
  return _impl_.ase_;
}
inline bool GetActiveGroupReq::ase() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupReq.ase)
  return _internal_ase();
}
inline void GetActiveGroupReq::_internal_set_ase(bool value) {
  
  _impl_.ase_ = value;
}
inline void GetActiveGroupReq::set_ase(bool value) {
  _internal_set_ase(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveGroupReq.ase)
}

// .sdkws.RequestPagination pagination = 4;
inline bool GetActiveGroupReq::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetActiveGroupReq::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sdkws::RequestPagination& GetActiveGroupReq::_internal_pagination() const {
  const ::sdkws::RequestPagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::RequestPagination&>(
      ::sdkws::_RequestPagination_default_instance_);
}
inline const ::sdkws::RequestPagination& GetActiveGroupReq::pagination() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupReq.pagination)
  return _internal_pagination();
}
inline void GetActiveGroupReq::unsafe_arena_set_allocated_pagination(
    ::sdkws::RequestPagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.GetActiveGroupReq.pagination)
}
inline ::sdkws::RequestPagination* GetActiveGroupReq::release_pagination() {
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::RequestPagination* GetActiveGroupReq::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:msg.GetActiveGroupReq.pagination)
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sdkws::RequestPagination* GetActiveGroupReq::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::RequestPagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sdkws::RequestPagination* GetActiveGroupReq::mutable_pagination() {
  ::sdkws::RequestPagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:msg.GetActiveGroupReq.pagination)
  return _msg;
}
inline void GetActiveGroupReq::set_allocated_pagination(::sdkws::RequestPagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:msg.GetActiveGroupReq.pagination)
}

// -------------------------------------------------------------------

// ActiveGroup

// .sdkws.GroupInfo group = 1;
inline bool ActiveGroup::_internal_has_group() const {
  return this != internal_default_instance() && _impl_.group_ != nullptr;
}
inline bool ActiveGroup::has_group() const {
  return _internal_has_group();
}
inline const ::sdkws::GroupInfo& ActiveGroup::_internal_group() const {
  const ::sdkws::GroupInfo* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::GroupInfo&>(
      ::sdkws::_GroupInfo_default_instance_);
}
inline const ::sdkws::GroupInfo& ActiveGroup::group() const {
  // @@protoc_insertion_point(field_get:msg.ActiveGroup.group)
  return _internal_group();
}
inline void ActiveGroup::unsafe_arena_set_allocated_group(
    ::sdkws::GroupInfo* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ActiveGroup.group)
}
inline ::sdkws::GroupInfo* ActiveGroup::release_group() {
  
  ::sdkws::GroupInfo* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::GroupInfo* ActiveGroup::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:msg.ActiveGroup.group)
  
  ::sdkws::GroupInfo* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::sdkws::GroupInfo* ActiveGroup::_internal_mutable_group() {
  
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::GroupInfo>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::sdkws::GroupInfo* ActiveGroup::mutable_group() {
  ::sdkws::GroupInfo* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:msg.ActiveGroup.group)
  return _msg;
}
inline void ActiveGroup::set_allocated_group(::sdkws::GroupInfo* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:msg.ActiveGroup.group)
}

// int64 count = 2;
inline void ActiveGroup::clear_count() {
  _impl_.count_ = int64_t{0};
}
inline int64_t ActiveGroup::_internal_count() const {
  return _impl_.count_;
}
inline int64_t ActiveGroup::count() const {
  // @@protoc_insertion_point(field_get:msg.ActiveGroup.count)
  return _internal_count();
}
inline void ActiveGroup::_internal_set_count(int64_t value) {
  
  _impl_.count_ = value;
}
inline void ActiveGroup::set_count(int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:msg.ActiveGroup.count)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetActiveGroupResp

// int64 msgCount = 1;
inline void GetActiveGroupResp::clear_msgcount() {
  _impl_.msgcount_ = int64_t{0};
}
inline int64_t GetActiveGroupResp::_internal_msgcount() const {
  return _impl_.msgcount_;
}
inline int64_t GetActiveGroupResp::msgcount() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupResp.msgCount)
  return _internal_msgcount();
}
inline void GetActiveGroupResp::_internal_set_msgcount(int64_t value) {
  
  _impl_.msgcount_ = value;
}
inline void GetActiveGroupResp::set_msgcount(int64_t value) {
  _internal_set_msgcount(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveGroupResp.msgCount)
}

// int64 groupCount = 2;
inline void GetActiveGroupResp::clear_groupcount() {
  _impl_.groupcount_ = int64_t{0};
}
inline int64_t GetActiveGroupResp::_internal_groupcount() const {
  return _impl_.groupcount_;
}
inline int64_t GetActiveGroupResp::groupcount() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupResp.groupCount)
  return _internal_groupcount();
}
inline void GetActiveGroupResp::_internal_set_groupcount(int64_t value) {
  
  _impl_.groupcount_ = value;
}
inline void GetActiveGroupResp::set_groupcount(int64_t value) {
  _internal_set_groupcount(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveGroupResp.groupCount)
}

// map<string, int64> dateCount = 3;
inline int GetActiveGroupResp::_internal_datecount_size() const {
  return _impl_.datecount_.size();
}
inline int GetActiveGroupResp::datecount_size() const {
  return _internal_datecount_size();
}
inline void GetActiveGroupResp::clear_datecount() {
  _impl_.datecount_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
GetActiveGroupResp::_internal_datecount() const {
  return _impl_.datecount_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
GetActiveGroupResp::datecount() const {
  // @@protoc_insertion_point(field_map:msg.GetActiveGroupResp.dateCount)
  return _internal_datecount();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
GetActiveGroupResp::_internal_mutable_datecount() {
  return _impl_.datecount_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
GetActiveGroupResp::mutable_datecount() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetActiveGroupResp.dateCount)
  return _internal_mutable_datecount();
}

// repeated .msg.ActiveGroup groups = 4;
inline int GetActiveGroupResp::_internal_groups_size() const {
  return _impl_.groups_.size();
}
inline int GetActiveGroupResp::groups_size() const {
  return _internal_groups_size();
}
inline void GetActiveGroupResp::clear_groups() {
  _impl_.groups_.Clear();
}
inline ::msg::ActiveGroup* GetActiveGroupResp::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetActiveGroupResp.groups)
  return _impl_.groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveGroup >*
GetActiveGroupResp::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetActiveGroupResp.groups)
  return &_impl_.groups_;
}
inline const ::msg::ActiveGroup& GetActiveGroupResp::_internal_groups(int index) const {
  return _impl_.groups_.Get(index);
}
inline const ::msg::ActiveGroup& GetActiveGroupResp::groups(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetActiveGroupResp.groups)
  return _internal_groups(index);
}
inline ::msg::ActiveGroup* GetActiveGroupResp::_internal_add_groups() {
  return _impl_.groups_.Add();
}
inline ::msg::ActiveGroup* GetActiveGroupResp::add_groups() {
  ::msg::ActiveGroup* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:msg.GetActiveGroupResp.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveGroup >&
GetActiveGroupResp::groups() const {
  // @@protoc_insertion_point(field_list:msg.GetActiveGroupResp.groups)
  return _impl_.groups_;
}

// -------------------------------------------------------------------

// SearchMessageReq

// string sendID = 1;
inline void SearchMessageReq::clear_sendid() {
  _impl_.sendid_.ClearToEmpty();
}
inline const std::string& SearchMessageReq::sendid() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageReq.sendID)
  return _internal_sendid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessageReq::set_sendid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SearchMessageReq.sendID)
}
inline std::string* SearchMessageReq::mutable_sendid() {
  std::string* _s = _internal_mutable_sendid();
  // @@protoc_insertion_point(field_mutable:msg.SearchMessageReq.sendID)
  return _s;
}
inline const std::string& SearchMessageReq::_internal_sendid() const {
  return _impl_.sendid_.Get();
}
inline void SearchMessageReq::_internal_set_sendid(const std::string& value) {
  
  _impl_.sendid_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchMessageReq::_internal_mutable_sendid() {
  
  return _impl_.sendid_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchMessageReq::release_sendid() {
  // @@protoc_insertion_point(field_release:msg.SearchMessageReq.sendID)
  return _impl_.sendid_.Release();
}
inline void SearchMessageReq::set_allocated_sendid(std::string* sendid) {
  if (sendid != nullptr) {
    
  } else {
    
  }
  _impl_.sendid_.SetAllocated(sendid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendid_.IsDefault()) {
    _impl_.sendid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SearchMessageReq.sendID)
}

// string recvID = 2;
inline void SearchMessageReq::clear_recvid() {
  _impl_.recvid_.ClearToEmpty();
}
inline const std::string& SearchMessageReq::recvid() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageReq.recvID)
  return _internal_recvid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessageReq::set_recvid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recvid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SearchMessageReq.recvID)
}
inline std::string* SearchMessageReq::mutable_recvid() {
  std::string* _s = _internal_mutable_recvid();
  // @@protoc_insertion_point(field_mutable:msg.SearchMessageReq.recvID)
  return _s;
}
inline const std::string& SearchMessageReq::_internal_recvid() const {
  return _impl_.recvid_.Get();
}
inline void SearchMessageReq::_internal_set_recvid(const std::string& value) {
  
  _impl_.recvid_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchMessageReq::_internal_mutable_recvid() {
  
  return _impl_.recvid_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchMessageReq::release_recvid() {
  // @@protoc_insertion_point(field_release:msg.SearchMessageReq.recvID)
  return _impl_.recvid_.Release();
}
inline void SearchMessageReq::set_allocated_recvid(std::string* recvid) {
  if (recvid != nullptr) {
    
  } else {
    
  }
  _impl_.recvid_.SetAllocated(recvid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recvid_.IsDefault()) {
    _impl_.recvid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SearchMessageReq.recvID)
}

// int32 contentType = 3;
inline void SearchMessageReq::clear_contenttype() {
  _impl_.contenttype_ = 0;
}
inline int32_t SearchMessageReq::_internal_contenttype() const {
  return _impl_.contenttype_;
}
inline int32_t SearchMessageReq::contenttype() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageReq.contentType)
  return _internal_contenttype();
}
inline void SearchMessageReq::_internal_set_contenttype(int32_t value) {
  
  _impl_.contenttype_ = value;
}
inline void SearchMessageReq::set_contenttype(int32_t value) {
  _internal_set_contenttype(value);
  // @@protoc_insertion_point(field_set:msg.SearchMessageReq.contentType)
}

// string sendTime = 4;
inline void SearchMessageReq::clear_sendtime() {
  _impl_.sendtime_.ClearToEmpty();
}
inline const std::string& SearchMessageReq::sendtime() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageReq.sendTime)
  return _internal_sendtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessageReq::set_sendtime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SearchMessageReq.sendTime)
}
inline std::string* SearchMessageReq::mutable_sendtime() {
  std::string* _s = _internal_mutable_sendtime();
  // @@protoc_insertion_point(field_mutable:msg.SearchMessageReq.sendTime)
  return _s;
}
inline const std::string& SearchMessageReq::_internal_sendtime() const {
  return _impl_.sendtime_.Get();
}
inline void SearchMessageReq::_internal_set_sendtime(const std::string& value) {
  
  _impl_.sendtime_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchMessageReq::_internal_mutable_sendtime() {
  
  return _impl_.sendtime_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchMessageReq::release_sendtime() {
  // @@protoc_insertion_point(field_release:msg.SearchMessageReq.sendTime)
  return _impl_.sendtime_.Release();
}
inline void SearchMessageReq::set_allocated_sendtime(std::string* sendtime) {
  if (sendtime != nullptr) {
    
  } else {
    
  }
  _impl_.sendtime_.SetAllocated(sendtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendtime_.IsDefault()) {
    _impl_.sendtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SearchMessageReq.sendTime)
}

// int32 sessionType = 5;
inline void SearchMessageReq::clear_sessiontype() {
  _impl_.sessiontype_ = 0;
}
inline int32_t SearchMessageReq::_internal_sessiontype() const {
  return _impl_.sessiontype_;
}
inline int32_t SearchMessageReq::sessiontype() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageReq.sessionType)
  return _internal_sessiontype();
}
inline void SearchMessageReq::_internal_set_sessiontype(int32_t value) {
  
  _impl_.sessiontype_ = value;
}
inline void SearchMessageReq::set_sessiontype(int32_t value) {
  _internal_set_sessiontype(value);
  // @@protoc_insertion_point(field_set:msg.SearchMessageReq.sessionType)
}

// .sdkws.RequestPagination pagination = 6;
inline bool SearchMessageReq::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool SearchMessageReq::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::sdkws::RequestPagination& SearchMessageReq::_internal_pagination() const {
  const ::sdkws::RequestPagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::RequestPagination&>(
      ::sdkws::_RequestPagination_default_instance_);
}
inline const ::sdkws::RequestPagination& SearchMessageReq::pagination() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageReq.pagination)
  return _internal_pagination();
}
inline void SearchMessageReq::unsafe_arena_set_allocated_pagination(
    ::sdkws::RequestPagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SearchMessageReq.pagination)
}
inline ::sdkws::RequestPagination* SearchMessageReq::release_pagination() {
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::RequestPagination* SearchMessageReq::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:msg.SearchMessageReq.pagination)
  
  ::sdkws::RequestPagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::sdkws::RequestPagination* SearchMessageReq::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::RequestPagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::sdkws::RequestPagination* SearchMessageReq::mutable_pagination() {
  ::sdkws::RequestPagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:msg.SearchMessageReq.pagination)
  return _msg;
}
inline void SearchMessageReq::set_allocated_pagination(::sdkws::RequestPagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:msg.SearchMessageReq.pagination)
}

// -------------------------------------------------------------------

// SearchChatLog

// .msg.ChatLog chatLog = 1;
inline bool SearchChatLog::_internal_has_chatlog() const {
  return this != internal_default_instance() && _impl_.chatlog_ != nullptr;
}
inline bool SearchChatLog::has_chatlog() const {
  return _internal_has_chatlog();
}
inline void SearchChatLog::clear_chatlog() {
  if (GetArenaForAllocation() == nullptr && _impl_.chatlog_ != nullptr) {
    delete _impl_.chatlog_;
  }
  _impl_.chatlog_ = nullptr;
}
inline const ::msg::ChatLog& SearchChatLog::_internal_chatlog() const {
  const ::msg::ChatLog* p = _impl_.chatlog_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::ChatLog&>(
      ::msg::_ChatLog_default_instance_);
}
inline const ::msg::ChatLog& SearchChatLog::chatlog() const {
  // @@protoc_insertion_point(field_get:msg.SearchChatLog.chatLog)
  return _internal_chatlog();
}
inline void SearchChatLog::unsafe_arena_set_allocated_chatlog(
    ::msg::ChatLog* chatlog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chatlog_);
  }
  _impl_.chatlog_ = chatlog;
  if (chatlog) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SearchChatLog.chatLog)
}
inline ::msg::ChatLog* SearchChatLog::release_chatlog() {
  
  ::msg::ChatLog* temp = _impl_.chatlog_;
  _impl_.chatlog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::ChatLog* SearchChatLog::unsafe_arena_release_chatlog() {
  // @@protoc_insertion_point(field_release:msg.SearchChatLog.chatLog)
  
  ::msg::ChatLog* temp = _impl_.chatlog_;
  _impl_.chatlog_ = nullptr;
  return temp;
}
inline ::msg::ChatLog* SearchChatLog::_internal_mutable_chatlog() {
  
  if (_impl_.chatlog_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::ChatLog>(GetArenaForAllocation());
    _impl_.chatlog_ = p;
  }
  return _impl_.chatlog_;
}
inline ::msg::ChatLog* SearchChatLog::mutable_chatlog() {
  ::msg::ChatLog* _msg = _internal_mutable_chatlog();
  // @@protoc_insertion_point(field_mutable:msg.SearchChatLog.chatLog)
  return _msg;
}
inline void SearchChatLog::set_allocated_chatlog(::msg::ChatLog* chatlog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chatlog_;
  }
  if (chatlog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chatlog);
    if (message_arena != submessage_arena) {
      chatlog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatlog, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chatlog_ = chatlog;
  // @@protoc_insertion_point(field_set_allocated:msg.SearchChatLog.chatLog)
}

// bool isRevoked = 2;
inline void SearchChatLog::clear_isrevoked() {
  _impl_.isrevoked_ = false;
}
inline bool SearchChatLog::_internal_isrevoked() const {
  return _impl_.isrevoked_;
}
inline bool SearchChatLog::isrevoked() const {
  // @@protoc_insertion_point(field_get:msg.SearchChatLog.isRevoked)
  return _internal_isrevoked();
}
inline void SearchChatLog::_internal_set_isrevoked(bool value) {
  
  _impl_.isrevoked_ = value;
}
inline void SearchChatLog::set_isrevoked(bool value) {
  _internal_set_isrevoked(value);
  // @@protoc_insertion_point(field_set:msg.SearchChatLog.isRevoked)
}

// -------------------------------------------------------------------

// SearchedMsgData

// .sdkws.MsgData msgData = 1;
inline bool SearchedMsgData::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool SearchedMsgData::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& SearchedMsgData::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& SearchedMsgData::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.SearchedMsgData.msgData)
  return _internal_msgdata();
}
inline void SearchedMsgData::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.SearchedMsgData.msgData)
}
inline ::sdkws::MsgData* SearchedMsgData::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* SearchedMsgData::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.SearchedMsgData.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* SearchedMsgData::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* SearchedMsgData::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.SearchedMsgData.msgData)
  return _msg;
}
inline void SearchedMsgData::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.SearchedMsgData.msgData)
}

// bool isRevoked = 2;
inline void SearchedMsgData::clear_isrevoked() {
  _impl_.isrevoked_ = false;
}
inline bool SearchedMsgData::_internal_isrevoked() const {
  return _impl_.isrevoked_;
}
inline bool SearchedMsgData::isrevoked() const {
  // @@protoc_insertion_point(field_get:msg.SearchedMsgData.isRevoked)
  return _internal_isrevoked();
}
inline void SearchedMsgData::_internal_set_isrevoked(bool value) {
  
  _impl_.isrevoked_ = value;
}
inline void SearchedMsgData::set_isrevoked(bool value) {
  _internal_set_isrevoked(value);
  // @@protoc_insertion_point(field_set:msg.SearchedMsgData.isRevoked)
}

// -------------------------------------------------------------------

// SearchMessageResp

// repeated .msg.SearchChatLog chatLogs = 1;
inline int SearchMessageResp::_internal_chatlogs_size() const {
  return _impl_.chatlogs_.size();
}
inline int SearchMessageResp::chatlogs_size() const {
  return _internal_chatlogs_size();
}
inline void SearchMessageResp::clear_chatlogs() {
  _impl_.chatlogs_.Clear();
}
inline ::msg::SearchChatLog* SearchMessageResp::mutable_chatlogs(int index) {
  // @@protoc_insertion_point(field_mutable:msg.SearchMessageResp.chatLogs)
  return _impl_.chatlogs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::SearchChatLog >*
SearchMessageResp::mutable_chatlogs() {
  // @@protoc_insertion_point(field_mutable_list:msg.SearchMessageResp.chatLogs)
  return &_impl_.chatlogs_;
}
inline const ::msg::SearchChatLog& SearchMessageResp::_internal_chatlogs(int index) const {
  return _impl_.chatlogs_.Get(index);
}
inline const ::msg::SearchChatLog& SearchMessageResp::chatlogs(int index) const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageResp.chatLogs)
  return _internal_chatlogs(index);
}
inline ::msg::SearchChatLog* SearchMessageResp::_internal_add_chatlogs() {
  return _impl_.chatlogs_.Add();
}
inline ::msg::SearchChatLog* SearchMessageResp::add_chatlogs() {
  ::msg::SearchChatLog* _add = _internal_add_chatlogs();
  // @@protoc_insertion_point(field_add:msg.SearchMessageResp.chatLogs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::SearchChatLog >&
SearchMessageResp::chatlogs() const {
  // @@protoc_insertion_point(field_list:msg.SearchMessageResp.chatLogs)
  return _impl_.chatlogs_;
}

// int32 chatLogsNum = 2;
inline void SearchMessageResp::clear_chatlogsnum() {
  _impl_.chatlogsnum_ = 0;
}
inline int32_t SearchMessageResp::_internal_chatlogsnum() const {
  return _impl_.chatlogsnum_;
}
inline int32_t SearchMessageResp::chatlogsnum() const {
  // @@protoc_insertion_point(field_get:msg.SearchMessageResp.chatLogsNum)
  return _internal_chatlogsnum();
}
inline void SearchMessageResp::_internal_set_chatlogsnum(int32_t value) {
  
  _impl_.chatlogsnum_ = value;
}
inline void SearchMessageResp::set_chatlogsnum(int32_t value) {
  _internal_set_chatlogsnum(value);
  // @@protoc_insertion_point(field_set:msg.SearchMessageResp.chatLogsNum)
}

// -------------------------------------------------------------------

// ChatLog

// string serverMsgID = 1;
inline void ChatLog::clear_servermsgid() {
  _impl_.servermsgid_.ClearToEmpty();
}
inline const std::string& ChatLog::servermsgid() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.serverMsgID)
  return _internal_servermsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_servermsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servermsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.serverMsgID)
}
inline std::string* ChatLog::mutable_servermsgid() {
  std::string* _s = _internal_mutable_servermsgid();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.serverMsgID)
  return _s;
}
inline const std::string& ChatLog::_internal_servermsgid() const {
  return _impl_.servermsgid_.Get();
}
inline void ChatLog::_internal_set_servermsgid(const std::string& value) {
  
  _impl_.servermsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_servermsgid() {
  
  return _impl_.servermsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_servermsgid() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.serverMsgID)
  return _impl_.servermsgid_.Release();
}
inline void ChatLog::set_allocated_servermsgid(std::string* servermsgid) {
  if (servermsgid != nullptr) {
    
  } else {
    
  }
  _impl_.servermsgid_.SetAllocated(servermsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servermsgid_.IsDefault()) {
    _impl_.servermsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.serverMsgID)
}

// string clientMsgID = 2;
inline void ChatLog::clear_clientmsgid() {
  _impl_.clientmsgid_.ClearToEmpty();
}
inline const std::string& ChatLog::clientmsgid() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.clientMsgID)
  return _internal_clientmsgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_clientmsgid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientmsgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.clientMsgID)
}
inline std::string* ChatLog::mutable_clientmsgid() {
  std::string* _s = _internal_mutable_clientmsgid();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.clientMsgID)
  return _s;
}
inline const std::string& ChatLog::_internal_clientmsgid() const {
  return _impl_.clientmsgid_.Get();
}
inline void ChatLog::_internal_set_clientmsgid(const std::string& value) {
  
  _impl_.clientmsgid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_clientmsgid() {
  
  return _impl_.clientmsgid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_clientmsgid() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.clientMsgID)
  return _impl_.clientmsgid_.Release();
}
inline void ChatLog::set_allocated_clientmsgid(std::string* clientmsgid) {
  if (clientmsgid != nullptr) {
    
  } else {
    
  }
  _impl_.clientmsgid_.SetAllocated(clientmsgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientmsgid_.IsDefault()) {
    _impl_.clientmsgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.clientMsgID)
}

// string sendID = 3;
inline void ChatLog::clear_sendid() {
  _impl_.sendid_.ClearToEmpty();
}
inline const std::string& ChatLog::sendid() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.sendID)
  return _internal_sendid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_sendid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.sendID)
}
inline std::string* ChatLog::mutable_sendid() {
  std::string* _s = _internal_mutable_sendid();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.sendID)
  return _s;
}
inline const std::string& ChatLog::_internal_sendid() const {
  return _impl_.sendid_.Get();
}
inline void ChatLog::_internal_set_sendid(const std::string& value) {
  
  _impl_.sendid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_sendid() {
  
  return _impl_.sendid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_sendid() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.sendID)
  return _impl_.sendid_.Release();
}
inline void ChatLog::set_allocated_sendid(std::string* sendid) {
  if (sendid != nullptr) {
    
  } else {
    
  }
  _impl_.sendid_.SetAllocated(sendid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendid_.IsDefault()) {
    _impl_.sendid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.sendID)
}

// string recvID = 4;
inline void ChatLog::clear_recvid() {
  _impl_.recvid_.ClearToEmpty();
}
inline const std::string& ChatLog::recvid() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.recvID)
  return _internal_recvid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_recvid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recvid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.recvID)
}
inline std::string* ChatLog::mutable_recvid() {
  std::string* _s = _internal_mutable_recvid();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.recvID)
  return _s;
}
inline const std::string& ChatLog::_internal_recvid() const {
  return _impl_.recvid_.Get();
}
inline void ChatLog::_internal_set_recvid(const std::string& value) {
  
  _impl_.recvid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_recvid() {
  
  return _impl_.recvid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_recvid() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.recvID)
  return _impl_.recvid_.Release();
}
inline void ChatLog::set_allocated_recvid(std::string* recvid) {
  if (recvid != nullptr) {
    
  } else {
    
  }
  _impl_.recvid_.SetAllocated(recvid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recvid_.IsDefault()) {
    _impl_.recvid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.recvID)
}

// string groupID = 5;
inline void ChatLog::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
}
inline const std::string& ChatLog::groupid() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.groupID)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.groupID)
}
inline std::string* ChatLog::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.groupID)
  return _s;
}
inline const std::string& ChatLog::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void ChatLog::_internal_set_groupid(const std::string& value) {
  
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_groupid() {
  
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_groupid() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.groupID)
  return _impl_.groupid_.Release();
}
inline void ChatLog::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.groupID)
}

// string recvNickname = 6;
inline void ChatLog::clear_recvnickname() {
  _impl_.recvnickname_.ClearToEmpty();
}
inline const std::string& ChatLog::recvnickname() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.recvNickname)
  return _internal_recvnickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_recvnickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recvnickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.recvNickname)
}
inline std::string* ChatLog::mutable_recvnickname() {
  std::string* _s = _internal_mutable_recvnickname();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.recvNickname)
  return _s;
}
inline const std::string& ChatLog::_internal_recvnickname() const {
  return _impl_.recvnickname_.Get();
}
inline void ChatLog::_internal_set_recvnickname(const std::string& value) {
  
  _impl_.recvnickname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_recvnickname() {
  
  return _impl_.recvnickname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_recvnickname() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.recvNickname)
  return _impl_.recvnickname_.Release();
}
inline void ChatLog::set_allocated_recvnickname(std::string* recvnickname) {
  if (recvnickname != nullptr) {
    
  } else {
    
  }
  _impl_.recvnickname_.SetAllocated(recvnickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recvnickname_.IsDefault()) {
    _impl_.recvnickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.recvNickname)
}

// int32 senderPlatformID = 7;
inline void ChatLog::clear_senderplatformid() {
  _impl_.senderplatformid_ = 0;
}
inline int32_t ChatLog::_internal_senderplatformid() const {
  return _impl_.senderplatformid_;
}
inline int32_t ChatLog::senderplatformid() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.senderPlatformID)
  return _internal_senderplatformid();
}
inline void ChatLog::_internal_set_senderplatformid(int32_t value) {
  
  _impl_.senderplatformid_ = value;
}
inline void ChatLog::set_senderplatformid(int32_t value) {
  _internal_set_senderplatformid(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.senderPlatformID)
}

// string senderNickname = 8;
inline void ChatLog::clear_sendernickname() {
  _impl_.sendernickname_.ClearToEmpty();
}
inline const std::string& ChatLog::sendernickname() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.senderNickname)
  return _internal_sendernickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_sendernickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendernickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.senderNickname)
}
inline std::string* ChatLog::mutable_sendernickname() {
  std::string* _s = _internal_mutable_sendernickname();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.senderNickname)
  return _s;
}
inline const std::string& ChatLog::_internal_sendernickname() const {
  return _impl_.sendernickname_.Get();
}
inline void ChatLog::_internal_set_sendernickname(const std::string& value) {
  
  _impl_.sendernickname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_sendernickname() {
  
  return _impl_.sendernickname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_sendernickname() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.senderNickname)
  return _impl_.sendernickname_.Release();
}
inline void ChatLog::set_allocated_sendernickname(std::string* sendernickname) {
  if (sendernickname != nullptr) {
    
  } else {
    
  }
  _impl_.sendernickname_.SetAllocated(sendernickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendernickname_.IsDefault()) {
    _impl_.sendernickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.senderNickname)
}

// string senderFaceURL = 9;
inline void ChatLog::clear_senderfaceurl() {
  _impl_.senderfaceurl_.ClearToEmpty();
}
inline const std::string& ChatLog::senderfaceurl() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.senderFaceURL)
  return _internal_senderfaceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_senderfaceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.senderfaceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.senderFaceURL)
}
inline std::string* ChatLog::mutable_senderfaceurl() {
  std::string* _s = _internal_mutable_senderfaceurl();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.senderFaceURL)
  return _s;
}
inline const std::string& ChatLog::_internal_senderfaceurl() const {
  return _impl_.senderfaceurl_.Get();
}
inline void ChatLog::_internal_set_senderfaceurl(const std::string& value) {
  
  _impl_.senderfaceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_senderfaceurl() {
  
  return _impl_.senderfaceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_senderfaceurl() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.senderFaceURL)
  return _impl_.senderfaceurl_.Release();
}
inline void ChatLog::set_allocated_senderfaceurl(std::string* senderfaceurl) {
  if (senderfaceurl != nullptr) {
    
  } else {
    
  }
  _impl_.senderfaceurl_.SetAllocated(senderfaceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderfaceurl_.IsDefault()) {
    _impl_.senderfaceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.senderFaceURL)
}

// string groupName = 10;
inline void ChatLog::clear_groupname() {
  _impl_.groupname_.ClearToEmpty();
}
inline const std::string& ChatLog::groupname() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.groupName)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_groupname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.groupName)
}
inline std::string* ChatLog::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.groupName)
  return _s;
}
inline const std::string& ChatLog::_internal_groupname() const {
  return _impl_.groupname_.Get();
}
inline void ChatLog::_internal_set_groupname(const std::string& value) {
  
  _impl_.groupname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_groupname() {
  
  return _impl_.groupname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_groupname() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.groupName)
  return _impl_.groupname_.Release();
}
inline void ChatLog::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    
  } else {
    
  }
  _impl_.groupname_.SetAllocated(groupname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupname_.IsDefault()) {
    _impl_.groupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.groupName)
}

// int32 sessionType = 11;
inline void ChatLog::clear_sessiontype() {
  _impl_.sessiontype_ = 0;
}
inline int32_t ChatLog::_internal_sessiontype() const {
  return _impl_.sessiontype_;
}
inline int32_t ChatLog::sessiontype() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.sessionType)
  return _internal_sessiontype();
}
inline void ChatLog::_internal_set_sessiontype(int32_t value) {
  
  _impl_.sessiontype_ = value;
}
inline void ChatLog::set_sessiontype(int32_t value) {
  _internal_set_sessiontype(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.sessionType)
}

// int32 msgFrom = 12;
inline void ChatLog::clear_msgfrom() {
  _impl_.msgfrom_ = 0;
}
inline int32_t ChatLog::_internal_msgfrom() const {
  return _impl_.msgfrom_;
}
inline int32_t ChatLog::msgfrom() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.msgFrom)
  return _internal_msgfrom();
}
inline void ChatLog::_internal_set_msgfrom(int32_t value) {
  
  _impl_.msgfrom_ = value;
}
inline void ChatLog::set_msgfrom(int32_t value) {
  _internal_set_msgfrom(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.msgFrom)
}

// int32 contentType = 13;
inline void ChatLog::clear_contenttype() {
  _impl_.contenttype_ = 0;
}
inline int32_t ChatLog::_internal_contenttype() const {
  return _impl_.contenttype_;
}
inline int32_t ChatLog::contenttype() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.contentType)
  return _internal_contenttype();
}
inline void ChatLog::_internal_set_contenttype(int32_t value) {
  
  _impl_.contenttype_ = value;
}
inline void ChatLog::set_contenttype(int32_t value) {
  _internal_set_contenttype(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.contentType)
}

// string content = 14;
inline void ChatLog::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ChatLog::content() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.content)
}
inline std::string* ChatLog::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.content)
  return _s;
}
inline const std::string& ChatLog::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ChatLog::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_content() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.content)
  return _impl_.content_.Release();
}
inline void ChatLog::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.content)
}

// int32 status = 15;
inline void ChatLog::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t ChatLog::_internal_status() const {
  return _impl_.status_;
}
inline int32_t ChatLog::status() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.status)
  return _internal_status();
}
inline void ChatLog::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void ChatLog::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.status)
}

// int64 sendTime = 16;
inline void ChatLog::clear_sendtime() {
  _impl_.sendtime_ = int64_t{0};
}
inline int64_t ChatLog::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline int64_t ChatLog::sendtime() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.sendTime)
  return _internal_sendtime();
}
inline void ChatLog::_internal_set_sendtime(int64_t value) {
  
  _impl_.sendtime_ = value;
}
inline void ChatLog::set_sendtime(int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.sendTime)
}

// int64 createTime = 17;
inline void ChatLog::clear_createtime() {
  _impl_.createtime_ = int64_t{0};
}
inline int64_t ChatLog::_internal_createtime() const {
  return _impl_.createtime_;
}
inline int64_t ChatLog::createtime() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.createTime)
  return _internal_createtime();
}
inline void ChatLog::_internal_set_createtime(int64_t value) {
  
  _impl_.createtime_ = value;
}
inline void ChatLog::set_createtime(int64_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.createTime)
}

// string ex = 18;
inline void ChatLog::clear_ex() {
  _impl_.ex_.ClearToEmpty();
}
inline const std::string& ChatLog::ex() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.ex)
  return _internal_ex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_ex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.ex)
}
inline std::string* ChatLog::mutable_ex() {
  std::string* _s = _internal_mutable_ex();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.ex)
  return _s;
}
inline const std::string& ChatLog::_internal_ex() const {
  return _impl_.ex_.Get();
}
inline void ChatLog::_internal_set_ex(const std::string& value) {
  
  _impl_.ex_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_ex() {
  
  return _impl_.ex_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_ex() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.ex)
  return _impl_.ex_.Release();
}
inline void ChatLog::set_allocated_ex(std::string* ex) {
  if (ex != nullptr) {
    
  } else {
    
  }
  _impl_.ex_.SetAllocated(ex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ex_.IsDefault()) {
    _impl_.ex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.ex)
}

// string groupFaceURL = 19;
inline void ChatLog::clear_groupfaceurl() {
  _impl_.groupfaceurl_.ClearToEmpty();
}
inline const std::string& ChatLog::groupfaceurl() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.groupFaceURL)
  return _internal_groupfaceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_groupfaceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupfaceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.groupFaceURL)
}
inline std::string* ChatLog::mutable_groupfaceurl() {
  std::string* _s = _internal_mutable_groupfaceurl();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.groupFaceURL)
  return _s;
}
inline const std::string& ChatLog::_internal_groupfaceurl() const {
  return _impl_.groupfaceurl_.Get();
}
inline void ChatLog::_internal_set_groupfaceurl(const std::string& value) {
  
  _impl_.groupfaceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_groupfaceurl() {
  
  return _impl_.groupfaceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_groupfaceurl() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.groupFaceURL)
  return _impl_.groupfaceurl_.Release();
}
inline void ChatLog::set_allocated_groupfaceurl(std::string* groupfaceurl) {
  if (groupfaceurl != nullptr) {
    
  } else {
    
  }
  _impl_.groupfaceurl_.SetAllocated(groupfaceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupfaceurl_.IsDefault()) {
    _impl_.groupfaceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.groupFaceURL)
}

// uint32 groupMemberCount = 20;
inline void ChatLog::clear_groupmembercount() {
  _impl_.groupmembercount_ = 0u;
}
inline uint32_t ChatLog::_internal_groupmembercount() const {
  return _impl_.groupmembercount_;
}
inline uint32_t ChatLog::groupmembercount() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.groupMemberCount)
  return _internal_groupmembercount();
}
inline void ChatLog::_internal_set_groupmembercount(uint32_t value) {
  
  _impl_.groupmembercount_ = value;
}
inline void ChatLog::set_groupmembercount(uint32_t value) {
  _internal_set_groupmembercount(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.groupMemberCount)
}

// int64 seq = 21;
inline void ChatLog::clear_seq() {
  _impl_.seq_ = int64_t{0};
}
inline int64_t ChatLog::_internal_seq() const {
  return _impl_.seq_;
}
inline int64_t ChatLog::seq() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.seq)
  return _internal_seq();
}
inline void ChatLog::_internal_set_seq(int64_t value) {
  
  _impl_.seq_ = value;
}
inline void ChatLog::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.seq)
}

// string groupOwner = 22;
inline void ChatLog::clear_groupowner() {
  _impl_.groupowner_.ClearToEmpty();
}
inline const std::string& ChatLog::groupowner() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.groupOwner)
  return _internal_groupowner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatLog::set_groupowner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.groupowner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatLog.groupOwner)
}
inline std::string* ChatLog::mutable_groupowner() {
  std::string* _s = _internal_mutable_groupowner();
  // @@protoc_insertion_point(field_mutable:msg.ChatLog.groupOwner)
  return _s;
}
inline const std::string& ChatLog::_internal_groupowner() const {
  return _impl_.groupowner_.Get();
}
inline void ChatLog::_internal_set_groupowner(const std::string& value) {
  
  _impl_.groupowner_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatLog::_internal_mutable_groupowner() {
  
  return _impl_.groupowner_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatLog::release_groupowner() {
  // @@protoc_insertion_point(field_release:msg.ChatLog.groupOwner)
  return _impl_.groupowner_.Release();
}
inline void ChatLog::set_allocated_groupowner(std::string* groupowner) {
  if (groupowner != nullptr) {
    
  } else {
    
  }
  _impl_.groupowner_.SetAllocated(groupowner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupowner_.IsDefault()) {
    _impl_.groupowner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatLog.groupOwner)
}

// int32 groupType = 23;
inline void ChatLog::clear_grouptype() {
  _impl_.grouptype_ = 0;
}
inline int32_t ChatLog::_internal_grouptype() const {
  return _impl_.grouptype_;
}
inline int32_t ChatLog::grouptype() const {
  // @@protoc_insertion_point(field_get:msg.ChatLog.groupType)
  return _internal_grouptype();
}
inline void ChatLog::_internal_set_grouptype(int32_t value) {
  
  _impl_.grouptype_ = value;
}
inline void ChatLog::set_grouptype(int32_t value) {
  _internal_set_grouptype(value);
  // @@protoc_insertion_point(field_set:msg.ChatLog.groupType)
}

// -------------------------------------------------------------------

// batchSendMessageReq

// repeated string recvIDList = 1;
inline int batchSendMessageReq::_internal_recvidlist_size() const {
  return _impl_.recvidlist_.size();
}
inline int batchSendMessageReq::recvidlist_size() const {
  return _internal_recvidlist_size();
}
inline void batchSendMessageReq::clear_recvidlist() {
  _impl_.recvidlist_.Clear();
}
inline std::string* batchSendMessageReq::add_recvidlist() {
  std::string* _s = _internal_add_recvidlist();
  // @@protoc_insertion_point(field_add_mutable:msg.batchSendMessageReq.recvIDList)
  return _s;
}
inline const std::string& batchSendMessageReq::_internal_recvidlist(int index) const {
  return _impl_.recvidlist_.Get(index);
}
inline const std::string& batchSendMessageReq::recvidlist(int index) const {
  // @@protoc_insertion_point(field_get:msg.batchSendMessageReq.recvIDList)
  return _internal_recvidlist(index);
}
inline std::string* batchSendMessageReq::mutable_recvidlist(int index) {
  // @@protoc_insertion_point(field_mutable:msg.batchSendMessageReq.recvIDList)
  return _impl_.recvidlist_.Mutable(index);
}
inline void batchSendMessageReq::set_recvidlist(int index, const std::string& value) {
  _impl_.recvidlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.batchSendMessageReq.recvIDList)
}
inline void batchSendMessageReq::set_recvidlist(int index, std::string&& value) {
  _impl_.recvidlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.batchSendMessageReq.recvIDList)
}
inline void batchSendMessageReq::set_recvidlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recvidlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.batchSendMessageReq.recvIDList)
}
inline void batchSendMessageReq::set_recvidlist(int index, const char* value, size_t size) {
  _impl_.recvidlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.batchSendMessageReq.recvIDList)
}
inline std::string* batchSendMessageReq::_internal_add_recvidlist() {
  return _impl_.recvidlist_.Add();
}
inline void batchSendMessageReq::add_recvidlist(const std::string& value) {
  _impl_.recvidlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.batchSendMessageReq.recvIDList)
}
inline void batchSendMessageReq::add_recvidlist(std::string&& value) {
  _impl_.recvidlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.batchSendMessageReq.recvIDList)
}
inline void batchSendMessageReq::add_recvidlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recvidlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.batchSendMessageReq.recvIDList)
}
inline void batchSendMessageReq::add_recvidlist(const char* value, size_t size) {
  _impl_.recvidlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.batchSendMessageReq.recvIDList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
batchSendMessageReq::recvidlist() const {
  // @@protoc_insertion_point(field_list:msg.batchSendMessageReq.recvIDList)
  return _impl_.recvidlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
batchSendMessageReq::mutable_recvidlist() {
  // @@protoc_insertion_point(field_mutable_list:msg.batchSendMessageReq.recvIDList)
  return &_impl_.recvidlist_;
}

// .sdkws.MsgData msgData = 2;
inline bool batchSendMessageReq::_internal_has_msgdata() const {
  return this != internal_default_instance() && _impl_.msgdata_ != nullptr;
}
inline bool batchSendMessageReq::has_msgdata() const {
  return _internal_has_msgdata();
}
inline const ::sdkws::MsgData& batchSendMessageReq::_internal_msgdata() const {
  const ::sdkws::MsgData* p = _impl_.msgdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::sdkws::MsgData&>(
      ::sdkws::_MsgData_default_instance_);
}
inline const ::sdkws::MsgData& batchSendMessageReq::msgdata() const {
  // @@protoc_insertion_point(field_get:msg.batchSendMessageReq.msgData)
  return _internal_msgdata();
}
inline void batchSendMessageReq::unsafe_arena_set_allocated_msgdata(
    ::sdkws::MsgData* msgdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  _impl_.msgdata_ = msgdata;
  if (msgdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.batchSendMessageReq.msgData)
}
inline ::sdkws::MsgData* batchSendMessageReq::release_msgdata() {
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sdkws::MsgData* batchSendMessageReq::unsafe_arena_release_msgdata() {
  // @@protoc_insertion_point(field_release:msg.batchSendMessageReq.msgData)
  
  ::sdkws::MsgData* temp = _impl_.msgdata_;
  _impl_.msgdata_ = nullptr;
  return temp;
}
inline ::sdkws::MsgData* batchSendMessageReq::_internal_mutable_msgdata() {
  
  if (_impl_.msgdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::sdkws::MsgData>(GetArenaForAllocation());
    _impl_.msgdata_ = p;
  }
  return _impl_.msgdata_;
}
inline ::sdkws::MsgData* batchSendMessageReq::mutable_msgdata() {
  ::sdkws::MsgData* _msg = _internal_mutable_msgdata();
  // @@protoc_insertion_point(field_mutable:msg.batchSendMessageReq.msgData)
  return _msg;
}
inline void batchSendMessageReq::set_allocated_msgdata(::sdkws::MsgData* msgdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgdata_);
  }
  if (msgdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msgdata));
    if (message_arena != submessage_arena) {
      msgdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgdata_ = msgdata;
  // @@protoc_insertion_point(field_set_allocated:msg.batchSendMessageReq.msgData)
}

// -------------------------------------------------------------------

// batchSendMessageResp

// -------------------------------------------------------------------

// GetServerTimeReq

// -------------------------------------------------------------------

// GetServerTimeResp

// int64 serverTime = 1;
inline void GetServerTimeResp::clear_servertime() {
  _impl_.servertime_ = int64_t{0};
}
inline int64_t GetServerTimeResp::_internal_servertime() const {
  return _impl_.servertime_;
}
inline int64_t GetServerTimeResp::servertime() const {
  // @@protoc_insertion_point(field_get:msg.GetServerTimeResp.serverTime)
  return _internal_servertime();
}
inline void GetServerTimeResp::_internal_set_servertime(int64_t value) {
  
  _impl_.servertime_ = value;
}
inline void GetServerTimeResp::set_servertime(int64_t value) {
  _internal_set_servertime(value);
  // @@protoc_insertion_point(field_set:msg.GetServerTimeResp.serverTime)
}

// -------------------------------------------------------------------

// ClearMsgReq

// repeated string conversations = 1;
inline int ClearMsgReq::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int ClearMsgReq::conversations_size() const {
  return _internal_conversations_size();
}
inline void ClearMsgReq::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline std::string* ClearMsgReq::add_conversations() {
  std::string* _s = _internal_add_conversations();
  // @@protoc_insertion_point(field_add_mutable:msg.ClearMsgReq.conversations)
  return _s;
}
inline const std::string& ClearMsgReq::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const std::string& ClearMsgReq::conversations(int index) const {
  // @@protoc_insertion_point(field_get:msg.ClearMsgReq.conversations)
  return _internal_conversations(index);
}
inline std::string* ClearMsgReq::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:msg.ClearMsgReq.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline void ClearMsgReq::set_conversations(int index, const std::string& value) {
  _impl_.conversations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.ClearMsgReq.conversations)
}
inline void ClearMsgReq::set_conversations(int index, std::string&& value) {
  _impl_.conversations_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.ClearMsgReq.conversations)
}
inline void ClearMsgReq::set_conversations(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.ClearMsgReq.conversations)
}
inline void ClearMsgReq::set_conversations(int index, const char* value, size_t size) {
  _impl_.conversations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.ClearMsgReq.conversations)
}
inline std::string* ClearMsgReq::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline void ClearMsgReq::add_conversations(const std::string& value) {
  _impl_.conversations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.ClearMsgReq.conversations)
}
inline void ClearMsgReq::add_conversations(std::string&& value) {
  _impl_.conversations_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.ClearMsgReq.conversations)
}
inline void ClearMsgReq::add_conversations(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.ClearMsgReq.conversations)
}
inline void ClearMsgReq::add_conversations(const char* value, size_t size) {
  _impl_.conversations_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.ClearMsgReq.conversations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClearMsgReq::conversations() const {
  // @@protoc_insertion_point(field_list:msg.ClearMsgReq.conversations)
  return _impl_.conversations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClearMsgReq::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:msg.ClearMsgReq.conversations)
  return &_impl_.conversations_;
}

// -------------------------------------------------------------------

// ClearMsgResp

// -------------------------------------------------------------------

// DestructMsgsReq

// int64 timestamp = 1;
inline void DestructMsgsReq::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t DestructMsgsReq::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t DestructMsgsReq::timestamp() const {
  // @@protoc_insertion_point(field_get:msg.DestructMsgsReq.timestamp)
  return _internal_timestamp();
}
inline void DestructMsgsReq::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void DestructMsgsReq::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:msg.DestructMsgsReq.timestamp)
}

// int32 limit = 2;
inline void DestructMsgsReq::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t DestructMsgsReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t DestructMsgsReq::limit() const {
  // @@protoc_insertion_point(field_get:msg.DestructMsgsReq.limit)
  return _internal_limit();
}
inline void DestructMsgsReq::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void DestructMsgsReq::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:msg.DestructMsgsReq.limit)
}

// -------------------------------------------------------------------

// DestructMsgsResp

// int32 count = 1;
inline void DestructMsgsResp::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t DestructMsgsResp::_internal_count() const {
  return _impl_.count_;
}
inline int32_t DestructMsgsResp::count() const {
  // @@protoc_insertion_point(field_get:msg.DestructMsgsResp.count)
  return _internal_count();
}
inline void DestructMsgsResp::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void DestructMsgsResp::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:msg.DestructMsgsResp.count)
}

// -------------------------------------------------------------------

// SetUserConversationsMinSeqReq

// repeated string userIDs = 1;
inline int SetUserConversationsMinSeqReq::_internal_userids_size() const {
  return _impl_.userids_.size();
}
inline int SetUserConversationsMinSeqReq::userids_size() const {
  return _internal_userids_size();
}
inline void SetUserConversationsMinSeqReq::clear_userids() {
  _impl_.userids_.Clear();
}
inline std::string* SetUserConversationsMinSeqReq::add_userids() {
  std::string* _s = _internal_add_userids();
  // @@protoc_insertion_point(field_add_mutable:msg.SetUserConversationsMinSeqReq.userIDs)
  return _s;
}
inline const std::string& SetUserConversationsMinSeqReq::_internal_userids(int index) const {
  return _impl_.userids_.Get(index);
}
inline const std::string& SetUserConversationsMinSeqReq::userids(int index) const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationsMinSeqReq.userIDs)
  return _internal_userids(index);
}
inline std::string* SetUserConversationsMinSeqReq::mutable_userids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.SetUserConversationsMinSeqReq.userIDs)
  return _impl_.userids_.Mutable(index);
}
inline void SetUserConversationsMinSeqReq::set_userids(int index, const std::string& value) {
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline void SetUserConversationsMinSeqReq::set_userids(int index, std::string&& value) {
  _impl_.userids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline void SetUserConversationsMinSeqReq::set_userids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline void SetUserConversationsMinSeqReq::set_userids(int index, const char* value, size_t size) {
  _impl_.userids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline std::string* SetUserConversationsMinSeqReq::_internal_add_userids() {
  return _impl_.userids_.Add();
}
inline void SetUserConversationsMinSeqReq::add_userids(const std::string& value) {
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline void SetUserConversationsMinSeqReq::add_userids(std::string&& value) {
  _impl_.userids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline void SetUserConversationsMinSeqReq::add_userids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.userids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline void SetUserConversationsMinSeqReq::add_userids(const char* value, size_t size) {
  _impl_.userids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.SetUserConversationsMinSeqReq.userIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetUserConversationsMinSeqReq::userids() const {
  // @@protoc_insertion_point(field_list:msg.SetUserConversationsMinSeqReq.userIDs)
  return _impl_.userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetUserConversationsMinSeqReq::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:msg.SetUserConversationsMinSeqReq.userIDs)
  return &_impl_.userids_;
}

// string conversationID = 2;
inline void SetUserConversationsMinSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& SetUserConversationsMinSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationsMinSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUserConversationsMinSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SetUserConversationsMinSeqReq.conversationID)
}
inline std::string* SetUserConversationsMinSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.SetUserConversationsMinSeqReq.conversationID)
  return _s;
}
inline const std::string& SetUserConversationsMinSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void SetUserConversationsMinSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetUserConversationsMinSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetUserConversationsMinSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.SetUserConversationsMinSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void SetUserConversationsMinSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SetUserConversationsMinSeqReq.conversationID)
}

// int64 seq = 3;
inline void SetUserConversationsMinSeqReq::clear_seq() {
  _impl_.seq_ = int64_t{0};
}
inline int64_t SetUserConversationsMinSeqReq::_internal_seq() const {
  return _impl_.seq_;
}
inline int64_t SetUserConversationsMinSeqReq::seq() const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationsMinSeqReq.seq)
  return _internal_seq();
}
inline void SetUserConversationsMinSeqReq::_internal_set_seq(int64_t value) {
  
  _impl_.seq_ = value;
}
inline void SetUserConversationsMinSeqReq::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:msg.SetUserConversationsMinSeqReq.seq)
}

// -------------------------------------------------------------------

// SetUserConversationsMinSeqResp

// -------------------------------------------------------------------

// ConversationSeqs

// string conversationID = 2;
inline void ConversationSeqs::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& ConversationSeqs::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.ConversationSeqs.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationSeqs::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ConversationSeqs.conversationID)
}
inline std::string* ConversationSeqs::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.ConversationSeqs.conversationID)
  return _s;
}
inline const std::string& ConversationSeqs::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void ConversationSeqs::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationSeqs::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationSeqs::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.ConversationSeqs.conversationID)
  return _impl_.conversationid_.Release();
}
inline void ConversationSeqs::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ConversationSeqs.conversationID)
}

// repeated int64 seqs = 3;
inline int ConversationSeqs::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int ConversationSeqs::seqs_size() const {
  return _internal_seqs_size();
}
inline void ConversationSeqs::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline int64_t ConversationSeqs::_internal_seqs(int index) const {
  return _impl_.seqs_.Get(index);
}
inline int64_t ConversationSeqs::seqs(int index) const {
  // @@protoc_insertion_point(field_get:msg.ConversationSeqs.seqs)
  return _internal_seqs(index);
}
inline void ConversationSeqs::set_seqs(int index, int64_t value) {
  _impl_.seqs_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.ConversationSeqs.seqs)
}
inline void ConversationSeqs::_internal_add_seqs(int64_t value) {
  _impl_.seqs_.Add(value);
}
inline void ConversationSeqs::add_seqs(int64_t value) {
  _internal_add_seqs(value);
  // @@protoc_insertion_point(field_add:msg.ConversationSeqs.seqs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ConversationSeqs::_internal_seqs() const {
  return _impl_.seqs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ConversationSeqs::seqs() const {
  // @@protoc_insertion_point(field_list:msg.ConversationSeqs.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ConversationSeqs::_internal_mutable_seqs() {
  return &_impl_.seqs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ConversationSeqs::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_list:msg.ConversationSeqs.seqs)
  return _internal_mutable_seqs();
}

// -------------------------------------------------------------------

// GetSeqMessageReq

// string userID = 1;
inline void GetSeqMessageReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetSeqMessageReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.GetSeqMessageReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSeqMessageReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetSeqMessageReq.userID)
}
inline std::string* GetSeqMessageReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.GetSeqMessageReq.userID)
  return _s;
}
inline const std::string& GetSeqMessageReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetSeqMessageReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSeqMessageReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSeqMessageReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.GetSeqMessageReq.userID)
  return _impl_.userid_.Release();
}
inline void GetSeqMessageReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetSeqMessageReq.userID)
}

// repeated .msg.ConversationSeqs conversations = 2;
inline int GetSeqMessageReq::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetSeqMessageReq::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetSeqMessageReq::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::msg::ConversationSeqs* GetSeqMessageReq::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetSeqMessageReq.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ConversationSeqs >*
GetSeqMessageReq::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetSeqMessageReq.conversations)
  return &_impl_.conversations_;
}
inline const ::msg::ConversationSeqs& GetSeqMessageReq::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::msg::ConversationSeqs& GetSeqMessageReq::conversations(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetSeqMessageReq.conversations)
  return _internal_conversations(index);
}
inline ::msg::ConversationSeqs* GetSeqMessageReq::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::msg::ConversationSeqs* GetSeqMessageReq::add_conversations() {
  ::msg::ConversationSeqs* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:msg.GetSeqMessageReq.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ConversationSeqs >&
GetSeqMessageReq::conversations() const {
  // @@protoc_insertion_point(field_list:msg.GetSeqMessageReq.conversations)
  return _impl_.conversations_;
}

// .sdkws.PullOrder order = 3;
inline void GetSeqMessageReq::clear_order() {
  _impl_.order_ = 0;
}
inline ::sdkws::PullOrder GetSeqMessageReq::_internal_order() const {
  return static_cast< ::sdkws::PullOrder >(_impl_.order_);
}
inline ::sdkws::PullOrder GetSeqMessageReq::order() const {
  // @@protoc_insertion_point(field_get:msg.GetSeqMessageReq.order)
  return _internal_order();
}
inline void GetSeqMessageReq::_internal_set_order(::sdkws::PullOrder value) {
  
  _impl_.order_ = value;
}
inline void GetSeqMessageReq::set_order(::sdkws::PullOrder value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:msg.GetSeqMessageReq.order)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetSeqMessageResp

// map<string, .sdkws.PullMsgs> msgs = 1;
inline int GetSeqMessageResp::_internal_msgs_size() const {
  return _impl_.msgs_.size();
}
inline int GetSeqMessageResp::msgs_size() const {
  return _internal_msgs_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
GetSeqMessageResp::_internal_msgs() const {
  return _impl_.msgs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
GetSeqMessageResp::msgs() const {
  // @@protoc_insertion_point(field_map:msg.GetSeqMessageResp.msgs)
  return _internal_msgs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
GetSeqMessageResp::_internal_mutable_msgs() {
  return _impl_.msgs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
GetSeqMessageResp::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetSeqMessageResp.msgs)
  return _internal_mutable_msgs();
}

// map<string, .sdkws.PullMsgs> notificationMsgs = 2;
inline int GetSeqMessageResp::_internal_notificationmsgs_size() const {
  return _impl_.notificationmsgs_.size();
}
inline int GetSeqMessageResp::notificationmsgs_size() const {
  return _internal_notificationmsgs_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
GetSeqMessageResp::_internal_notificationmsgs() const {
  return _impl_.notificationmsgs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >&
GetSeqMessageResp::notificationmsgs() const {
  // @@protoc_insertion_point(field_map:msg.GetSeqMessageResp.notificationMsgs)
  return _internal_notificationmsgs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
GetSeqMessageResp::_internal_mutable_notificationmsgs() {
  return _impl_.notificationmsgs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::PullMsgs >*
GetSeqMessageResp::mutable_notificationmsgs() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetSeqMessageResp.notificationMsgs)
  return _internal_mutable_notificationmsgs();
}

// -------------------------------------------------------------------

// GetActiveConversationReq

// repeated string conversationIDs = 1;
inline int GetActiveConversationReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetActiveConversationReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetActiveConversationReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetActiveConversationReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetActiveConversationReq.conversationIDs)
  return _s;
}
inline const std::string& GetActiveConversationReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetActiveConversationReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetActiveConversationReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetActiveConversationReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetActiveConversationReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetActiveConversationReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveConversationReq.conversationIDs)
}
inline void GetActiveConversationReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetActiveConversationReq.conversationIDs)
}
inline void GetActiveConversationReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetActiveConversationReq.conversationIDs)
}
inline void GetActiveConversationReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetActiveConversationReq.conversationIDs)
}
inline std::string* GetActiveConversationReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetActiveConversationReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetActiveConversationReq.conversationIDs)
}
inline void GetActiveConversationReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetActiveConversationReq.conversationIDs)
}
inline void GetActiveConversationReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetActiveConversationReq.conversationIDs)
}
inline void GetActiveConversationReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetActiveConversationReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetActiveConversationReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetActiveConversationReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetActiveConversationReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetActiveConversationReq.conversationIDs)
  return &_impl_.conversationids_;
}

// int64 limit = 2;
inline void GetActiveConversationReq::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t GetActiveConversationReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t GetActiveConversationReq::limit() const {
  // @@protoc_insertion_point(field_get:msg.GetActiveConversationReq.limit)
  return _internal_limit();
}
inline void GetActiveConversationReq::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void GetActiveConversationReq::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:msg.GetActiveConversationReq.limit)
}

// -------------------------------------------------------------------

// ActiveConversation

// string conversationID = 1;
inline void ActiveConversation::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& ActiveConversation::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.ActiveConversation.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveConversation::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ActiveConversation.conversationID)
}
inline std::string* ActiveConversation::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.ActiveConversation.conversationID)
  return _s;
}
inline const std::string& ActiveConversation::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void ActiveConversation::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveConversation::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveConversation::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.ActiveConversation.conversationID)
  return _impl_.conversationid_.Release();
}
inline void ActiveConversation::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ActiveConversation.conversationID)
}

// int64 lastTime = 2;
inline void ActiveConversation::clear_lasttime() {
  _impl_.lasttime_ = int64_t{0};
}
inline int64_t ActiveConversation::_internal_lasttime() const {
  return _impl_.lasttime_;
}
inline int64_t ActiveConversation::lasttime() const {
  // @@protoc_insertion_point(field_get:msg.ActiveConversation.lastTime)
  return _internal_lasttime();
}
inline void ActiveConversation::_internal_set_lasttime(int64_t value) {
  
  _impl_.lasttime_ = value;
}
inline void ActiveConversation::set_lasttime(int64_t value) {
  _internal_set_lasttime(value);
  // @@protoc_insertion_point(field_set:msg.ActiveConversation.lastTime)
}

// int64 maxSeq = 3;
inline void ActiveConversation::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t ActiveConversation::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t ActiveConversation::maxseq() const {
  // @@protoc_insertion_point(field_get:msg.ActiveConversation.maxSeq)
  return _internal_maxseq();
}
inline void ActiveConversation::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void ActiveConversation::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:msg.ActiveConversation.maxSeq)
}

// -------------------------------------------------------------------

// GetActiveConversationResp

// repeated .msg.ActiveConversation conversations = 1;
inline int GetActiveConversationResp::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int GetActiveConversationResp::conversations_size() const {
  return _internal_conversations_size();
}
inline void GetActiveConversationResp::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::msg::ActiveConversation* GetActiveConversationResp::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetActiveConversationResp.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveConversation >*
GetActiveConversationResp::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetActiveConversationResp.conversations)
  return &_impl_.conversations_;
}
inline const ::msg::ActiveConversation& GetActiveConversationResp::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::msg::ActiveConversation& GetActiveConversationResp::conversations(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetActiveConversationResp.conversations)
  return _internal_conversations(index);
}
inline ::msg::ActiveConversation* GetActiveConversationResp::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::msg::ActiveConversation* GetActiveConversationResp::add_conversations() {
  ::msg::ActiveConversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:msg.GetActiveConversationResp.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::ActiveConversation >&
GetActiveConversationResp::conversations() const {
  // @@protoc_insertion_point(field_list:msg.GetActiveConversationResp.conversations)
  return _impl_.conversations_;
}

// -------------------------------------------------------------------

// SetUserConversationMaxSeqReq

// string conversationID = 1;
inline void SetUserConversationMaxSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& SetUserConversationMaxSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationMaxSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUserConversationMaxSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMaxSeqReq.conversationID)
}
inline std::string* SetUserConversationMaxSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.SetUserConversationMaxSeqReq.conversationID)
  return _s;
}
inline const std::string& SetUserConversationMaxSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void SetUserConversationMaxSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetUserConversationMaxSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetUserConversationMaxSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.SetUserConversationMaxSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void SetUserConversationMaxSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SetUserConversationMaxSeqReq.conversationID)
}

// repeated string ownerUserID = 2;
inline int SetUserConversationMaxSeqReq::_internal_owneruserid_size() const {
  return _impl_.owneruserid_.size();
}
inline int SetUserConversationMaxSeqReq::owneruserid_size() const {
  return _internal_owneruserid_size();
}
inline void SetUserConversationMaxSeqReq::clear_owneruserid() {
  _impl_.owneruserid_.Clear();
}
inline std::string* SetUserConversationMaxSeqReq::add_owneruserid() {
  std::string* _s = _internal_add_owneruserid();
  // @@protoc_insertion_point(field_add_mutable:msg.SetUserConversationMaxSeqReq.ownerUserID)
  return _s;
}
inline const std::string& SetUserConversationMaxSeqReq::_internal_owneruserid(int index) const {
  return _impl_.owneruserid_.Get(index);
}
inline const std::string& SetUserConversationMaxSeqReq::owneruserid(int index) const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationMaxSeqReq.ownerUserID)
  return _internal_owneruserid(index);
}
inline std::string* SetUserConversationMaxSeqReq::mutable_owneruserid(int index) {
  // @@protoc_insertion_point(field_mutable:msg.SetUserConversationMaxSeqReq.ownerUserID)
  return _impl_.owneruserid_.Mutable(index);
}
inline void SetUserConversationMaxSeqReq::set_owneruserid(int index, const std::string& value) {
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline void SetUserConversationMaxSeqReq::set_owneruserid(int index, std::string&& value) {
  _impl_.owneruserid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline void SetUserConversationMaxSeqReq::set_owneruserid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline void SetUserConversationMaxSeqReq::set_owneruserid(int index, const char* value, size_t size) {
  _impl_.owneruserid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline std::string* SetUserConversationMaxSeqReq::_internal_add_owneruserid() {
  return _impl_.owneruserid_.Add();
}
inline void SetUserConversationMaxSeqReq::add_owneruserid(const std::string& value) {
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline void SetUserConversationMaxSeqReq::add_owneruserid(std::string&& value) {
  _impl_.owneruserid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline void SetUserConversationMaxSeqReq::add_owneruserid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline void SetUserConversationMaxSeqReq::add_owneruserid(const char* value, size_t size) {
  _impl_.owneruserid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.SetUserConversationMaxSeqReq.ownerUserID)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetUserConversationMaxSeqReq::owneruserid() const {
  // @@protoc_insertion_point(field_list:msg.SetUserConversationMaxSeqReq.ownerUserID)
  return _impl_.owneruserid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetUserConversationMaxSeqReq::mutable_owneruserid() {
  // @@protoc_insertion_point(field_mutable_list:msg.SetUserConversationMaxSeqReq.ownerUserID)
  return &_impl_.owneruserid_;
}

// int64 maxSeq = 3;
inline void SetUserConversationMaxSeqReq::clear_maxseq() {
  _impl_.maxseq_ = int64_t{0};
}
inline int64_t SetUserConversationMaxSeqReq::_internal_maxseq() const {
  return _impl_.maxseq_;
}
inline int64_t SetUserConversationMaxSeqReq::maxseq() const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationMaxSeqReq.maxSeq)
  return _internal_maxseq();
}
inline void SetUserConversationMaxSeqReq::_internal_set_maxseq(int64_t value) {
  
  _impl_.maxseq_ = value;
}
inline void SetUserConversationMaxSeqReq::set_maxseq(int64_t value) {
  _internal_set_maxseq(value);
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMaxSeqReq.maxSeq)
}

// -------------------------------------------------------------------

// SetUserConversationMaxSeqResp

// -------------------------------------------------------------------

// SetUserConversationMinSeqReq

// string conversationID = 1;
inline void SetUserConversationMinSeqReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& SetUserConversationMinSeqReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationMinSeqReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUserConversationMinSeqReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMinSeqReq.conversationID)
}
inline std::string* SetUserConversationMinSeqReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.SetUserConversationMinSeqReq.conversationID)
  return _s;
}
inline const std::string& SetUserConversationMinSeqReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void SetUserConversationMinSeqReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetUserConversationMinSeqReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetUserConversationMinSeqReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.SetUserConversationMinSeqReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void SetUserConversationMinSeqReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SetUserConversationMinSeqReq.conversationID)
}

// repeated string ownerUserID = 2;
inline int SetUserConversationMinSeqReq::_internal_owneruserid_size() const {
  return _impl_.owneruserid_.size();
}
inline int SetUserConversationMinSeqReq::owneruserid_size() const {
  return _internal_owneruserid_size();
}
inline void SetUserConversationMinSeqReq::clear_owneruserid() {
  _impl_.owneruserid_.Clear();
}
inline std::string* SetUserConversationMinSeqReq::add_owneruserid() {
  std::string* _s = _internal_add_owneruserid();
  // @@protoc_insertion_point(field_add_mutable:msg.SetUserConversationMinSeqReq.ownerUserID)
  return _s;
}
inline const std::string& SetUserConversationMinSeqReq::_internal_owneruserid(int index) const {
  return _impl_.owneruserid_.Get(index);
}
inline const std::string& SetUserConversationMinSeqReq::owneruserid(int index) const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationMinSeqReq.ownerUserID)
  return _internal_owneruserid(index);
}
inline std::string* SetUserConversationMinSeqReq::mutable_owneruserid(int index) {
  // @@protoc_insertion_point(field_mutable:msg.SetUserConversationMinSeqReq.ownerUserID)
  return _impl_.owneruserid_.Mutable(index);
}
inline void SetUserConversationMinSeqReq::set_owneruserid(int index, const std::string& value) {
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline void SetUserConversationMinSeqReq::set_owneruserid(int index, std::string&& value) {
  _impl_.owneruserid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline void SetUserConversationMinSeqReq::set_owneruserid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline void SetUserConversationMinSeqReq::set_owneruserid(int index, const char* value, size_t size) {
  _impl_.owneruserid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline std::string* SetUserConversationMinSeqReq::_internal_add_owneruserid() {
  return _impl_.owneruserid_.Add();
}
inline void SetUserConversationMinSeqReq::add_owneruserid(const std::string& value) {
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline void SetUserConversationMinSeqReq::add_owneruserid(std::string&& value) {
  _impl_.owneruserid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline void SetUserConversationMinSeqReq::add_owneruserid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owneruserid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline void SetUserConversationMinSeqReq::add_owneruserid(const char* value, size_t size) {
  _impl_.owneruserid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.SetUserConversationMinSeqReq.ownerUserID)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetUserConversationMinSeqReq::owneruserid() const {
  // @@protoc_insertion_point(field_list:msg.SetUserConversationMinSeqReq.ownerUserID)
  return _impl_.owneruserid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetUserConversationMinSeqReq::mutable_owneruserid() {
  // @@protoc_insertion_point(field_mutable_list:msg.SetUserConversationMinSeqReq.ownerUserID)
  return &_impl_.owneruserid_;
}

// int64 minSeq = 3;
inline void SetUserConversationMinSeqReq::clear_minseq() {
  _impl_.minseq_ = int64_t{0};
}
inline int64_t SetUserConversationMinSeqReq::_internal_minseq() const {
  return _impl_.minseq_;
}
inline int64_t SetUserConversationMinSeqReq::minseq() const {
  // @@protoc_insertion_point(field_get:msg.SetUserConversationMinSeqReq.minSeq)
  return _internal_minseq();
}
inline void SetUserConversationMinSeqReq::_internal_set_minseq(int64_t value) {
  
  _impl_.minseq_ = value;
}
inline void SetUserConversationMinSeqReq::set_minseq(int64_t value) {
  _internal_set_minseq(value);
  // @@protoc_insertion_point(field_set:msg.SetUserConversationMinSeqReq.minSeq)
}

// -------------------------------------------------------------------

// SetUserConversationMinSeqResp

// -------------------------------------------------------------------

// GetLastMessageSeqByTimeReq

// string conversationID = 1;
inline void GetLastMessageSeqByTimeReq::clear_conversationid() {
  _impl_.conversationid_.ClearToEmpty();
}
inline const std::string& GetLastMessageSeqByTimeReq::conversationid() const {
  // @@protoc_insertion_point(field_get:msg.GetLastMessageSeqByTimeReq.conversationID)
  return _internal_conversationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLastMessageSeqByTimeReq::set_conversationid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetLastMessageSeqByTimeReq.conversationID)
}
inline std::string* GetLastMessageSeqByTimeReq::mutable_conversationid() {
  std::string* _s = _internal_mutable_conversationid();
  // @@protoc_insertion_point(field_mutable:msg.GetLastMessageSeqByTimeReq.conversationID)
  return _s;
}
inline const std::string& GetLastMessageSeqByTimeReq::_internal_conversationid() const {
  return _impl_.conversationid_.Get();
}
inline void GetLastMessageSeqByTimeReq::_internal_set_conversationid(const std::string& value) {
  
  _impl_.conversationid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLastMessageSeqByTimeReq::_internal_mutable_conversationid() {
  
  return _impl_.conversationid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLastMessageSeqByTimeReq::release_conversationid() {
  // @@protoc_insertion_point(field_release:msg.GetLastMessageSeqByTimeReq.conversationID)
  return _impl_.conversationid_.Release();
}
inline void GetLastMessageSeqByTimeReq::set_allocated_conversationid(std::string* conversationid) {
  if (conversationid != nullptr) {
    
  } else {
    
  }
  _impl_.conversationid_.SetAllocated(conversationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversationid_.IsDefault()) {
    _impl_.conversationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetLastMessageSeqByTimeReq.conversationID)
}

// int64 time = 2;
inline void GetLastMessageSeqByTimeReq::clear_time() {
  _impl_.time_ = int64_t{0};
}
inline int64_t GetLastMessageSeqByTimeReq::_internal_time() const {
  return _impl_.time_;
}
inline int64_t GetLastMessageSeqByTimeReq::time() const {
  // @@protoc_insertion_point(field_get:msg.GetLastMessageSeqByTimeReq.time)
  return _internal_time();
}
inline void GetLastMessageSeqByTimeReq::_internal_set_time(int64_t value) {
  
  _impl_.time_ = value;
}
inline void GetLastMessageSeqByTimeReq::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:msg.GetLastMessageSeqByTimeReq.time)
}

// -------------------------------------------------------------------

// GetLastMessageSeqByTimeResp

// int64 seq = 1;
inline void GetLastMessageSeqByTimeResp::clear_seq() {
  _impl_.seq_ = int64_t{0};
}
inline int64_t GetLastMessageSeqByTimeResp::_internal_seq() const {
  return _impl_.seq_;
}
inline int64_t GetLastMessageSeqByTimeResp::seq() const {
  // @@protoc_insertion_point(field_get:msg.GetLastMessageSeqByTimeResp.seq)
  return _internal_seq();
}
inline void GetLastMessageSeqByTimeResp::_internal_set_seq(int64_t value) {
  
  _impl_.seq_ = value;
}
inline void GetLastMessageSeqByTimeResp::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:msg.GetLastMessageSeqByTimeResp.seq)
}

// -------------------------------------------------------------------

// GetLastMessageReq

// string userID = 1;
inline void GetLastMessageReq::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetLastMessageReq::userid() const {
  // @@protoc_insertion_point(field_get:msg.GetLastMessageReq.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLastMessageReq::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GetLastMessageReq.userID)
}
inline std::string* GetLastMessageReq::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:msg.GetLastMessageReq.userID)
  return _s;
}
inline const std::string& GetLastMessageReq::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetLastMessageReq::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLastMessageReq::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLastMessageReq::release_userid() {
  // @@protoc_insertion_point(field_release:msg.GetLastMessageReq.userID)
  return _impl_.userid_.Release();
}
inline void GetLastMessageReq::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GetLastMessageReq.userID)
}

// repeated string conversationIDs = 2;
inline int GetLastMessageReq::_internal_conversationids_size() const {
  return _impl_.conversationids_.size();
}
inline int GetLastMessageReq::conversationids_size() const {
  return _internal_conversationids_size();
}
inline void GetLastMessageReq::clear_conversationids() {
  _impl_.conversationids_.Clear();
}
inline std::string* GetLastMessageReq::add_conversationids() {
  std::string* _s = _internal_add_conversationids();
  // @@protoc_insertion_point(field_add_mutable:msg.GetLastMessageReq.conversationIDs)
  return _s;
}
inline const std::string& GetLastMessageReq::_internal_conversationids(int index) const {
  return _impl_.conversationids_.Get(index);
}
inline const std::string& GetLastMessageReq::conversationids(int index) const {
  // @@protoc_insertion_point(field_get:msg.GetLastMessageReq.conversationIDs)
  return _internal_conversationids(index);
}
inline std::string* GetLastMessageReq::mutable_conversationids(int index) {
  // @@protoc_insertion_point(field_mutable:msg.GetLastMessageReq.conversationIDs)
  return _impl_.conversationids_.Mutable(index);
}
inline void GetLastMessageReq::set_conversationids(int index, const std::string& value) {
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:msg.GetLastMessageReq.conversationIDs)
}
inline void GetLastMessageReq::set_conversationids(int index, std::string&& value) {
  _impl_.conversationids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:msg.GetLastMessageReq.conversationIDs)
}
inline void GetLastMessageReq::set_conversationids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:msg.GetLastMessageReq.conversationIDs)
}
inline void GetLastMessageReq::set_conversationids(int index, const char* value, size_t size) {
  _impl_.conversationids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:msg.GetLastMessageReq.conversationIDs)
}
inline std::string* GetLastMessageReq::_internal_add_conversationids() {
  return _impl_.conversationids_.Add();
}
inline void GetLastMessageReq::add_conversationids(const std::string& value) {
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:msg.GetLastMessageReq.conversationIDs)
}
inline void GetLastMessageReq::add_conversationids(std::string&& value) {
  _impl_.conversationids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:msg.GetLastMessageReq.conversationIDs)
}
inline void GetLastMessageReq::add_conversationids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.conversationids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:msg.GetLastMessageReq.conversationIDs)
}
inline void GetLastMessageReq::add_conversationids(const char* value, size_t size) {
  _impl_.conversationids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:msg.GetLastMessageReq.conversationIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetLastMessageReq::conversationids() const {
  // @@protoc_insertion_point(field_list:msg.GetLastMessageReq.conversationIDs)
  return _impl_.conversationids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetLastMessageReq::mutable_conversationids() {
  // @@protoc_insertion_point(field_mutable_list:msg.GetLastMessageReq.conversationIDs)
  return &_impl_.conversationids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetLastMessageResp

// map<string, .sdkws.MsgData> msgs = 1;
inline int GetLastMessageResp::_internal_msgs_size() const {
  return _impl_.msgs_.size();
}
inline int GetLastMessageResp::msgs_size() const {
  return _internal_msgs_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
GetLastMessageResp::_internal_msgs() const {
  return _impl_.msgs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >&
GetLastMessageResp::msgs() const {
  // @@protoc_insertion_point(field_map:msg.GetLastMessageResp.msgs)
  return _internal_msgs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
GetLastMessageResp::_internal_mutable_msgs() {
  return _impl_.msgs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sdkws::MsgData >*
GetLastMessageResp::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_map:msg.GetLastMessageResp.msgs)
  return _internal_mutable_msgs();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
